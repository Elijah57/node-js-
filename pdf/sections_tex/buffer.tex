\section{Buffer}\label{buffer}

\begin{quote}
Stability: 2 - Stable
\end{quote}

\texttt{Buffer} objects are used to represent a fixed-length sequence of
bytes. Many Node.js APIs support \texttt{Buffer}s.

The \texttt{Buffer} class is a subclass of JavaScript's
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}{\texttt{Uint8Array}}
class and extends it with methods that cover additional use cases.
Node.js APIs accept plain
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}{\texttt{Uint8Array}}s
wherever \texttt{Buffer}s are supported as well.

While the \texttt{Buffer} class is available within the global scope, it
is still recommended to explicitly reference it via an import or require
statement.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Creates a zero{-}filled Buffer of length 10.}
\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Creates a Buffer of length 10,}
\CommentTok{// filled with bytes which all have the value \textasciigrave{}1\textasciigrave{}.}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{10}\OperatorTok{,} \DecValTok{1}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Creates an uninitialized buffer of length 10.}
\CommentTok{// This is faster than calling Buffer.alloc() but the returned}
\CommentTok{// Buffer instance might contain old data that needs to be}
\CommentTok{// overwritten using fill(), write(), or other functions that fill the Buffer\textquotesingle{}s}
\CommentTok{// contents.}
\KeywordTok{const}\NormalTok{ buf3 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Creates a Buffer containing the bytes [1, 2, 3].}
\KeywordTok{const}\NormalTok{ buf4 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\NormalTok{])}\OperatorTok{;}

\CommentTok{// Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries}
\CommentTok{// are all truncated using \textasciigrave{}(value \& 255)\textasciigrave{} to fit into the range 0–255.}
\KeywordTok{const}\NormalTok{ buf5 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{257}\OperatorTok{,} \FloatTok{257.5}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{255}\OperatorTok{,} \StringTok{\textquotesingle{}1\textquotesingle{}}\NormalTok{])}\OperatorTok{;}

\CommentTok{// Creates a Buffer containing the UTF{-}8{-}encoded bytes for the string \textquotesingle{}tést\textquotesingle{}:}
\CommentTok{// [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)}
\CommentTok{// [116, 195, 169, 115, 116] (in decimal notation)}
\KeywordTok{const}\NormalTok{ buf6 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}tést\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Creates a Buffer containing the Latin{-}1 bytes [0x74, 0xe9, 0x73, 0x74].}
\KeywordTok{const}\NormalTok{ buf7 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}tést\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}latin1\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Creates a zero{-}filled Buffer of length 10.}
\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Creates a Buffer of length 10,}
\CommentTok{// filled with bytes which all have the value \textasciigrave{}1\textasciigrave{}.}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{10}\OperatorTok{,} \DecValTok{1}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Creates an uninitialized buffer of length 10.}
\CommentTok{// This is faster than calling Buffer.alloc() but the returned}
\CommentTok{// Buffer instance might contain old data that needs to be}
\CommentTok{// overwritten using fill(), write(), or other functions that fill the Buffer\textquotesingle{}s}
\CommentTok{// contents.}
\KeywordTok{const}\NormalTok{ buf3 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Creates a Buffer containing the bytes [1, 2, 3].}
\KeywordTok{const}\NormalTok{ buf4 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\NormalTok{])}\OperatorTok{;}

\CommentTok{// Creates a Buffer containing the bytes [1, 1, 1, 1] – the entries}
\CommentTok{// are all truncated using \textasciigrave{}(value \& 255)\textasciigrave{} to fit into the range 0–255.}
\KeywordTok{const}\NormalTok{ buf5 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{257}\OperatorTok{,} \FloatTok{257.5}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{255}\OperatorTok{,} \StringTok{\textquotesingle{}1\textquotesingle{}}\NormalTok{])}\OperatorTok{;}

\CommentTok{// Creates a Buffer containing the UTF{-}8{-}encoded bytes for the string \textquotesingle{}tést\textquotesingle{}:}
\CommentTok{// [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)}
\CommentTok{// [116, 195, 169, 115, 116] (in decimal notation)}
\KeywordTok{const}\NormalTok{ buf6 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}tést\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Creates a Buffer containing the Latin{-}1 bytes [0x74, 0xe9, 0x73, 0x74].}
\KeywordTok{const}\NormalTok{ buf7 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}tést\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}latin1\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{Buffers and character
encodings}\label{buffers-and-character-encodings}

When converting between \texttt{Buffer}s and strings, a character
encoding may be specified. If no character encoding is specified, UTF-8
will be used as the default.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}hello world\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 68656c6c6f20776f726c64}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}base64\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: aGVsbG8gd29ybGQ=}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}fhqwhgads\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 66 68 71 77 68 67 61 64 73\textgreater{}}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}fhqwhgads\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}hello world\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 68656c6c6f20776f726c64}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}base64\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: aGVsbG8gd29ybGQ=}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}fhqwhgads\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 66 68 71 77 68 67 61 64 73\textgreater{}}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}fhqwhgads\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 66 00 68 00 71 00 77 00 68 00 67 00 61 00 64 00 73 00\textgreater{}}
\end{Highlighting}
\end{Shaded}

Node.js buffers accept all case variations of encoding strings that they
receive. For example, UTF-8 can be specified as
\texttt{\textquotesingle{}utf8\textquotesingle{}},
\texttt{\textquotesingle{}UTF8\textquotesingle{}}, or
\texttt{\textquotesingle{}uTf8\textquotesingle{}}.

The character encodings currently supported by Node.js are the
following:

\begin{itemize}
\item
  \texttt{\textquotesingle{}utf8\textquotesingle{}} (alias:
  \texttt{\textquotesingle{}utf-8\textquotesingle{}}): Multi-byte
  encoded Unicode characters. Many web pages and other document formats
  use \href{https://en.wikipedia.org/wiki/UTF-8}{UTF-8}. This is the
  default character encoding. When decoding a \texttt{Buffer} into a
  string that does not exclusively contain valid UTF-8 data, the Unicode
  replacement character \texttt{U+FFFD} � will be used to represent
  those errors.
\item
  \texttt{\textquotesingle{}utf16le\textquotesingle{}} (alias:
  \texttt{\textquotesingle{}utf-16le\textquotesingle{}}): Multi-byte
  encoded Unicode characters. Unlike
  \texttt{\textquotesingle{}utf8\textquotesingle{}}, each character in
  the string will be encoded using either 2 or 4 bytes. Node.js only
  supports the
  \href{https://en.wikipedia.org/wiki/Endianness}{little-endian} variant
  of \href{https://en.wikipedia.org/wiki/UTF-16}{UTF-16}.
\item
  \texttt{\textquotesingle{}latin1\textquotesingle{}}: Latin-1 stands
  for \href{https://en.wikipedia.org/wiki/ISO-8859-1}{ISO-8859-1}. This
  character encoding only supports the Unicode characters from
  \texttt{U+0000} to \texttt{U+00FF}. Each character is encoded using a
  single byte. Characters that do not fit into that range are truncated
  and will be mapped to characters in that range.
\end{itemize}

Converting a \texttt{Buffer} into a string using one of the above is
referred to as decoding, and converting a string into a \texttt{Buffer}
is referred to as encoding.

Node.js also supports the following binary-to-text encodings. For
binary-to-text encodings, the naming convention is reversed: Converting
a \texttt{Buffer} into a string is typically referred to as encoding,
and converting a string into a \texttt{Buffer} as decoding.

\begin{itemize}
\item
  \texttt{\textquotesingle{}base64\textquotesingle{}}:
  \href{https://en.wikipedia.org/wiki/Base64}{Base64} encoding. When
  creating a \texttt{Buffer} from a string, this encoding will also
  correctly accept ``URL and Filename Safe Alphabet'' as specified in
  \href{https://tools.ietf.org/html/rfc4648\#section-5}{RFC 4648,
  Section 5}. Whitespace characters such as spaces, tabs, and new lines
  contained within the base64-encoded string are ignored.
\item
  \texttt{\textquotesingle{}base64url\textquotesingle{}}:
  \href{https://tools.ietf.org/html/rfc4648\#section-5}{base64url}
  encoding as specified in
  \href{https://tools.ietf.org/html/rfc4648\#section-5}{RFC 4648,
  Section 5}. When creating a \texttt{Buffer} from a string, this
  encoding will also correctly accept regular base64-encoded strings.
  When encoding a \texttt{Buffer} to a string, this encoding will omit
  padding.
\item
  \texttt{\textquotesingle{}hex\textquotesingle{}}: Encode each byte as
  two hexadecimal characters. Data truncation may occur when decoding
  strings that do not exclusively consist of an even number of
  hexadecimal characters. See below for an example.
\end{itemize}

The following legacy character encodings are also supported:

\begin{itemize}
\item
  \texttt{\textquotesingle{}ascii\textquotesingle{}}: For 7-bit
  \href{https://en.wikipedia.org/wiki/ASCII}{ASCII} data only. When
  encoding a string into a \texttt{Buffer}, this is equivalent to using
  \texttt{\textquotesingle{}latin1\textquotesingle{}}. When decoding a
  \texttt{Buffer} into a string, using this encoding will additionally
  unset the highest bit of each byte before decoding as
  \texttt{\textquotesingle{}latin1\textquotesingle{}}. Generally, there
  should be no reason to use this encoding, as
  \texttt{\textquotesingle{}utf8\textquotesingle{}} (or, if the data is
  known to always be ASCII-only,
  \texttt{\textquotesingle{}latin1\textquotesingle{}}) will be a better
  choice when encoding or decoding ASCII-only text. It is only provided
  for legacy compatibility.
\item
  \texttt{\textquotesingle{}binary\textquotesingle{}}: Alias for
  \texttt{\textquotesingle{}latin1\textquotesingle{}}. The name of this
  encoding can be very misleading, as all of the encodings listed here
  convert between strings and binary data. For converting between
  strings and \texttt{Buffer}s, typically
  \texttt{\textquotesingle{}utf8\textquotesingle{}} is the right choice.
\item
  \texttt{\textquotesingle{}ucs2\textquotesingle{}},
  \texttt{\textquotesingle{}ucs-2\textquotesingle{}}: Aliases of
  \texttt{\textquotesingle{}utf16le\textquotesingle{}}. UCS-2 used to
  refer to a variant of UTF-16 that did not support characters that had
  code points larger than U+FFFF. In Node.js, these code points are
  always supported.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}1ag123\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints \textless{}Buffer 1a\textgreater{}, data truncated when first non{-}hexadecimal value}
\CommentTok{// (\textquotesingle{}g\textquotesingle{}) encountered.}

\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}1a7\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints \textless{}Buffer 1a\textgreater{}, data truncated when data ends in single digit (\textquotesingle{}7\textquotesingle{}).}

\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}1634\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints \textless{}Buffer 16 34\textgreater{}, all data represented.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}1ag123\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints \textless{}Buffer 1a\textgreater{}, data truncated when first non{-}hexadecimal value}
\CommentTok{// (\textquotesingle{}g\textquotesingle{}) encountered.}

\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}1a7\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints \textless{}Buffer 1a\textgreater{}, data truncated when data ends in single digit (\textquotesingle{}7\textquotesingle{}).}

\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}1634\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints \textless{}Buffer 16 34\textgreater{}, all data represented.}
\end{Highlighting}
\end{Shaded}

Modern Web browsers follow the
\href{https://encoding.spec.whatwg.org/}{WHATWG Encoding Standard} which
aliases both \texttt{\textquotesingle{}latin1\textquotesingle{}} and
\texttt{\textquotesingle{}ISO-8859-1\textquotesingle{}} to
\texttt{\textquotesingle{}win-1252\textquotesingle{}}. This means that
while doing something like \texttt{http.get()}, if the returned charset
is one of those listed in the WHATWG specification it is possible that
the server actually returned
\texttt{\textquotesingle{}win-1252\textquotesingle{}}-encoded data, and
using \texttt{\textquotesingle{}latin1\textquotesingle{}} encoding may
incorrectly decode the characters.

\subsection{Buffers and TypedArrays}\label{buffers-and-typedarrays}

\texttt{Buffer} instances are also JavaScript
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}{\texttt{Uint8Array}}
and
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray}{\texttt{TypedArray}}
instances. All
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray}{\texttt{TypedArray}}
methods are available on \texttt{Buffer}s. There are, however, subtle
incompatibilities between the \texttt{Buffer} API and the
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray}{\texttt{TypedArray}}
API.

In particular:

\begin{itemize}
\tightlist
\item
  While
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice}{\texttt{TypedArray.prototype.slice()}}
  creates a copy of part of the \texttt{TypedArray},
  \hyperref[bufslicestart-end]{\texttt{Buffer.prototype.slice()}}
  creates a view over the existing \texttt{Buffer} without copying. This
  behavior can be surprising, and only exists for legacy compatibility.
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray}{\texttt{TypedArray.prototype.subarray()}}
  can be used to achieve the behavior of
  \hyperref[bufslicestart-end]{\texttt{Buffer.prototype.slice()}} on
  both \texttt{Buffer}s and other \texttt{TypedArray}s and should be
  preferred.
\item
  \hyperref[buftostringencoding-start-end]{\texttt{buf.toString()}} is
  incompatible with its \texttt{TypedArray} equivalent.
\item
  A number of methods,
  e.g.~\hyperref[bufindexofvalue-byteoffset-encoding]{\texttt{buf.indexOf()}},
  support additional arguments.
\end{itemize}

There are two ways to create new
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray}{\texttt{TypedArray}}
instances from a \texttt{Buffer}:

\begin{itemize}
\tightlist
\item
  Passing a \texttt{Buffer} to a
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray}{\texttt{TypedArray}}
  constructor will copy the \texttt{Buffer}s contents, interpreted as an
  array of integers, and not as a byte sequence of the target type.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ uint32array }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Uint32Array}\NormalTok{(buf)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(uint32array)}\OperatorTok{;}

\CommentTok{// Prints: Uint32Array(4) [ 1, 2, 3, 4 ]}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ uint32array }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Uint32Array}\NormalTok{(buf)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(uint32array)}\OperatorTok{;}

\CommentTok{// Prints: Uint32Array(4) [ 1, 2, 3, 4 ]}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Passing the \texttt{Buffer}s underlying
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}{\texttt{ArrayBuffer}}
  will create a
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray}{\texttt{TypedArray}}
  that shares its memory with the \texttt{Buffer}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}hello\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ uint16array }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Uint16Array}\NormalTok{(}
\NormalTok{  buf}\OperatorTok{.}\AttributeTok{buffer}\OperatorTok{,}
\NormalTok{  buf}\OperatorTok{.}\AttributeTok{byteOffset}\OperatorTok{,}
\NormalTok{  buf}\OperatorTok{.}\AttributeTok{length} \OperatorTok{/} \BuiltInTok{Uint16Array}\OperatorTok{.}\AttributeTok{BYTES\_PER\_ELEMENT}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(uint16array)}\OperatorTok{;}

\CommentTok{// Prints: Uint16Array(5) [ 104, 101, 108, 108, 111 ]}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}hello\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ uint16array }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Uint16Array}\NormalTok{(}
\NormalTok{  buf}\OperatorTok{.}\AttributeTok{buffer}\OperatorTok{,}
\NormalTok{  buf}\OperatorTok{.}\AttributeTok{byteOffset}\OperatorTok{,}
\NormalTok{  buf}\OperatorTok{.}\AttributeTok{length} \OperatorTok{/} \BuiltInTok{Uint16Array}\OperatorTok{.}\AttributeTok{BYTES\_PER\_ELEMENT}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(uint16array)}\OperatorTok{;}

\CommentTok{// Prints: Uint16Array(5) [ 104, 101, 108, 108, 111 ]}
\end{Highlighting}
\end{Shaded}

It is possible to create a new \texttt{Buffer} that shares the same
allocated memory as a
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray}{\texttt{TypedArray}}
instance by using the \texttt{TypedArray} object's \texttt{.buffer}
property in the same way.
\hyperref[static-method-bufferfromarraybuffer-byteoffset-length]{\texttt{Buffer.from()}}
behaves like \texttt{new\ Uint8Array()} in this context.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ arr }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Uint16Array}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{;}

\NormalTok{arr[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{5000}\OperatorTok{;}
\NormalTok{arr[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \DecValTok{4000}\OperatorTok{;}

\CommentTok{// Copies the contents of \textasciigrave{}arr\textasciigrave{}.}
\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(arr)}\OperatorTok{;}

\CommentTok{// Shares memory with \textasciigrave{}arr\textasciigrave{}.}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(arr}\OperatorTok{.}\AttributeTok{buffer}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 88 a0\textgreater{}}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 88 13 a0 0f\textgreater{}}

\NormalTok{arr[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \DecValTok{6000}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 88 a0\textgreater{}}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 88 13 70 17\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ arr }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Uint16Array}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{;}

\NormalTok{arr[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{5000}\OperatorTok{;}
\NormalTok{arr[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \DecValTok{4000}\OperatorTok{;}

\CommentTok{// Copies the contents of \textasciigrave{}arr\textasciigrave{}.}
\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(arr)}\OperatorTok{;}

\CommentTok{// Shares memory with \textasciigrave{}arr\textasciigrave{}.}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(arr}\OperatorTok{.}\AttributeTok{buffer}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 88 a0\textgreater{}}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 88 13 a0 0f\textgreater{}}

\NormalTok{arr[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \DecValTok{6000}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 88 a0\textgreater{}}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 88 13 70 17\textgreater{}}
\end{Highlighting}
\end{Shaded}

When creating a \texttt{Buffer} using a
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray}{\texttt{TypedArray}}'s
\texttt{.buffer}, it is possible to use only a portion of the underlying
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}{\texttt{ArrayBuffer}}
by passing in \texttt{byteOffset} and \texttt{length} parameters.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ arr }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Uint16Array}\NormalTok{(}\DecValTok{20}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(arr}\OperatorTok{.}\AttributeTok{buffer}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{16}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 16}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ arr }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Uint16Array}\NormalTok{(}\DecValTok{20}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(arr}\OperatorTok{.}\AttributeTok{buffer}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{16}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 16}
\end{Highlighting}
\end{Shaded}

The \texttt{Buffer.from()} and
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from}{\texttt{TypedArray.from()}}
have different signatures and implementations. Specifically, the
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray}{\texttt{TypedArray}}
variants accept a second argument that is a mapping function that is
invoked on every element of the typed array:

\begin{itemize}
\tightlist
\item
  \texttt{TypedArray.from(source{[},\ mapFn{[},\ thisArg{]}{]})}
\end{itemize}

The \texttt{Buffer.from()} method, however, does not support the use of
a mapping function:

\begin{itemize}
\tightlist
\item
  \hyperref[static-method-bufferfromarray]{\texttt{Buffer.from(array)}}
\item
  \hyperref[static-method-bufferfrombuffer]{\texttt{Buffer.from(buffer)}}
\item
  \hyperref[static-method-bufferfromarraybuffer-byteoffset-length]{\texttt{Buffer.from(arrayBuffer{[},\ byteOffset{[},\ length{]}{]})}}
\item
  \hyperref[static-method-bufferfromstring-encoding]{\texttt{Buffer.from(string{[},\ encoding{]})}}
\end{itemize}

\subsection{Buffers and iteration}\label{buffers-and-iteration}

\texttt{Buffer} instances can be iterated over using \texttt{for..of}
syntax:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\NormalTok{])}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ b }\KeywordTok{of}\NormalTok{ buf) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b)}\OperatorTok{;}
\NormalTok{\}}
\CommentTok{// Prints:}
\CommentTok{//   1}
\CommentTok{//   2}
\CommentTok{//   3}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\NormalTok{])}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ b }\KeywordTok{of}\NormalTok{ buf) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b)}\OperatorTok{;}
\NormalTok{\}}
\CommentTok{// Prints:}
\CommentTok{//   1}
\CommentTok{//   2}
\CommentTok{//   3}
\end{Highlighting}
\end{Shaded}

Additionally, the \hyperref[bufvalues]{\texttt{buf.values()}},
\hyperref[bufkeys]{\texttt{buf.keys()}}, and
\hyperref[bufentries]{\texttt{buf.entries()}} methods can be used to
create iterators.

\subsection{\texorpdfstring{Class:
\texttt{Blob}}{Class: Blob}}\label{class-blob}

A
\href{https://developer.mozilla.org/en-US/docs/Web/API/Blob}{\texttt{Blob}}
encapsulates immutable, raw data that can be safely shared across
multiple worker threads.

\subsubsection{\texorpdfstring{\texttt{new\ buffer.Blob({[}sources{[},\ options{]}{]})}}{new buffer.Blob({[}sources{[}, options{]}{]})}}\label{new-buffer.blobsources-options}

\begin{itemize}
\tightlist
\item
  \texttt{sources}
  \{string{[}{]}\textbar ArrayBuffer{[}{]}\textbar TypedArray{[}{]}\textbar DataView{[}{]}\textbar Blob{[}{]}\}
  An array of string, \{ArrayBuffer\}, \{TypedArray\}, \{DataView\}, or
  \{Blob\} objects, or any mix of such objects, that will be stored
  within the \texttt{Blob}.
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{endings} \{string\} One of either
    \texttt{\textquotesingle{}transparent\textquotesingle{}} or
    \texttt{\textquotesingle{}native\textquotesingle{}}. When set to
    \texttt{\textquotesingle{}native\textquotesingle{}}, line endings in
    string source parts will be converted to the platform native
    line-ending as specified by
    \texttt{require(\textquotesingle{}node:os\textquotesingle{}).EOL}.
  \item
    \texttt{type} \{string\} The Blob content-type. The intent is for
    \texttt{type} to convey the MIME media type of the data, however no
    validation of the type format is performed.
  \end{itemize}
\end{itemize}

Creates a new \texttt{Blob} object containing a concatenation of the
given sources.

\{ArrayBuffer\}, \{TypedArray\}, \{DataView\}, and \{Buffer\} sources
are copied into the `Blob' and can therefore be safely modified after
the `Blob' is created.

String sources are encoded as UTF-8 byte sequences and copied into the
Blob. Unmatched surrogate pairs within each string part will be replaced
by Unicode U+FFFD replacement characters.

\subsubsection{\texorpdfstring{\texttt{blob.arrayBuffer()}}{blob.arrayBuffer()}}\label{blob.arraybuffer}

\begin{itemize}
\tightlist
\item
  Returns: \{Promise\}
\end{itemize}

Returns a promise that fulfills with an \{ArrayBuffer\} containing a
copy of the \texttt{Blob} data.

\subsubsection{\texorpdfstring{\texttt{blob.size}}{blob.size}}\label{blob.size}

The total size of the \texttt{Blob} in bytes.

\subsubsection{\texorpdfstring{\texttt{blob.slice({[}start{[},\ end{[},\ type{]}{]}{]})}}{blob.slice({[}start{[}, end{[}, type{]}{]}{]})}}\label{blob.slicestart-end-type}

\begin{itemize}
\tightlist
\item
  \texttt{start} \{number\} The starting index.
\item
  \texttt{end} \{number\} The ending index.
\item
  \texttt{type} \{string\} The content-type for the new \texttt{Blob}
\end{itemize}

Creates and returns a new \texttt{Blob} containing a subset of this
\texttt{Blob} objects data. The original \texttt{Blob} is not altered.

\subsubsection{\texorpdfstring{\texttt{blob.stream()}}{blob.stream()}}\label{blob.stream}

\begin{itemize}
\tightlist
\item
  Returns: \{ReadableStream\}
\end{itemize}

Returns a new \texttt{ReadableStream} that allows the content of the
\texttt{Blob} to be read.

\subsubsection{\texorpdfstring{\texttt{blob.text()}}{blob.text()}}\label{blob.text}

\begin{itemize}
\tightlist
\item
  Returns: \{Promise\}
\end{itemize}

Returns a promise that fulfills with the contents of the \texttt{Blob}
decoded as a UTF-8 string.

\subsubsection{\texorpdfstring{\texttt{blob.type}}{blob.type}}\label{blob.type}

\begin{itemize}
\tightlist
\item
  Type: \{string\}
\end{itemize}

The content-type of the \texttt{Blob}.

\subsubsection{\texorpdfstring{\texttt{Blob} objects and
\texttt{MessageChannel}}{Blob objects and MessageChannel}}\label{blob-objects-and-messagechannel}

Once a \{Blob\} object is created, it can be sent via
\texttt{MessagePort} to multiple destinations without transferring or
immediately copying the data. The data contained by the \texttt{Blob} is
copied only when the \texttt{arrayBuffer()} or \texttt{text()} methods
are called.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Blob}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ setTimeout }\ImportTok{as}\NormalTok{ delay \} }\ImportTok{from} \StringTok{\textquotesingle{}node:timers/promises\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ blob }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Blob}\NormalTok{([}\StringTok{\textquotesingle{}hello there\textquotesingle{}}\NormalTok{])}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ mc1 }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{MessageChannel}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ mc2 }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{MessageChannel}\NormalTok{()}\OperatorTok{;}

\NormalTok{mc1}\OperatorTok{.}\AttributeTok{port1}\OperatorTok{.}\AttributeTok{onmessage} \OperatorTok{=} \KeywordTok{async}\NormalTok{ (\{ data \}) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\ControlFlowTok{await}\NormalTok{ data}\OperatorTok{.}\FunctionTok{arrayBuffer}\NormalTok{())}\OperatorTok{;}
\NormalTok{  mc1}\OperatorTok{.}\AttributeTok{port1}\OperatorTok{.}\FunctionTok{close}\NormalTok{()}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{;}

\NormalTok{mc2}\OperatorTok{.}\AttributeTok{port1}\OperatorTok{.}\AttributeTok{onmessage} \OperatorTok{=} \KeywordTok{async}\NormalTok{ (\{ data \}) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \ControlFlowTok{await} \FunctionTok{delay}\NormalTok{(}\DecValTok{1000}\NormalTok{)}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\ControlFlowTok{await}\NormalTok{ data}\OperatorTok{.}\FunctionTok{arrayBuffer}\NormalTok{())}\OperatorTok{;}
\NormalTok{  mc2}\OperatorTok{.}\AttributeTok{port1}\OperatorTok{.}\FunctionTok{close}\NormalTok{()}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{;}

\NormalTok{mc1}\OperatorTok{.}\AttributeTok{port2}\OperatorTok{.}\FunctionTok{postMessage}\NormalTok{(blob)}\OperatorTok{;}
\NormalTok{mc2}\OperatorTok{.}\AttributeTok{port2}\OperatorTok{.}\FunctionTok{postMessage}\NormalTok{(blob)}\OperatorTok{;}

\CommentTok{// The Blob is still usable after posting.}
\NormalTok{blob}\OperatorTok{.}\FunctionTok{text}\NormalTok{()}\OperatorTok{.}\FunctionTok{then}\NormalTok{(}\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Blob}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ \{ }\DataTypeTok{setTimeout}\OperatorTok{:}\NormalTok{ delay \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:timers/promises\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ blob }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Blob}\NormalTok{([}\StringTok{\textquotesingle{}hello there\textquotesingle{}}\NormalTok{])}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ mc1 }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{MessageChannel}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ mc2 }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{MessageChannel}\NormalTok{()}\OperatorTok{;}

\NormalTok{mc1}\OperatorTok{.}\AttributeTok{port1}\OperatorTok{.}\AttributeTok{onmessage} \OperatorTok{=} \KeywordTok{async}\NormalTok{ (\{ data \}) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\ControlFlowTok{await}\NormalTok{ data}\OperatorTok{.}\FunctionTok{arrayBuffer}\NormalTok{())}\OperatorTok{;}
\NormalTok{  mc1}\OperatorTok{.}\AttributeTok{port1}\OperatorTok{.}\FunctionTok{close}\NormalTok{()}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{;}

\NormalTok{mc2}\OperatorTok{.}\AttributeTok{port1}\OperatorTok{.}\AttributeTok{onmessage} \OperatorTok{=} \KeywordTok{async}\NormalTok{ (\{ data \}) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \ControlFlowTok{await} \FunctionTok{delay}\NormalTok{(}\DecValTok{1000}\NormalTok{)}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\ControlFlowTok{await}\NormalTok{ data}\OperatorTok{.}\FunctionTok{arrayBuffer}\NormalTok{())}\OperatorTok{;}
\NormalTok{  mc2}\OperatorTok{.}\AttributeTok{port1}\OperatorTok{.}\FunctionTok{close}\NormalTok{()}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{;}

\NormalTok{mc1}\OperatorTok{.}\AttributeTok{port2}\OperatorTok{.}\FunctionTok{postMessage}\NormalTok{(blob)}\OperatorTok{;}
\NormalTok{mc2}\OperatorTok{.}\AttributeTok{port2}\OperatorTok{.}\FunctionTok{postMessage}\NormalTok{(blob)}\OperatorTok{;}

\CommentTok{// The Blob is still usable after posting.}
\NormalTok{blob}\OperatorTok{.}\FunctionTok{text}\NormalTok{()}\OperatorTok{.}\FunctionTok{then}\NormalTok{(}\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{Class:
\texttt{Buffer}}{Class: Buffer}}\label{class-buffer}

The \texttt{Buffer} class is a global type for dealing with binary data
directly. It can be constructed in a variety of ways.

\subsubsection{\texorpdfstring{Static method:
\texttt{Buffer.alloc(size{[},\ fill{[},\ encoding{]}{]})}}{Static method: Buffer.alloc(size{[}, fill{[}, encoding{]}{]})}}\label{static-method-buffer.allocsize-fill-encoding}

\begin{itemize}
\tightlist
\item
  \texttt{size} \{integer\} The desired length of the new
  \texttt{Buffer}.
\item
  \texttt{fill}
  \{string\textbar Buffer\textbar Uint8Array\textbar integer\} A value
  to pre-fill the new \texttt{Buffer} with. \textbf{Default:}
  \texttt{0}.
\item
  \texttt{encoding} \{string\} If \texttt{fill} is a string, this is its
  encoding. \textbf{Default:}
  \texttt{\textquotesingle{}utf8\textquotesingle{}}.
\end{itemize}

Allocates a new \texttt{Buffer} of \texttt{size} bytes. If \texttt{fill}
is \texttt{undefined}, the \texttt{Buffer} will be zero-filled.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{5}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 00 00 00 00 00\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{5}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 00 00 00 00 00\textgreater{}}
\end{Highlighting}
\end{Shaded}

If \texttt{size} is larger than
\hyperref[bufferconstantsmax_length]{\texttt{buffer.constants.MAX\_LENGTH}}
or smaller than 0,
\href{errors.md\#err_out_of_range}{\texttt{ERR\_OUT\_OF\_RANGE}} is
thrown.

If \texttt{fill} is specified, the allocated \texttt{Buffer} will be
initialized by calling
\hyperref[buffillvalue-offset-end-encoding]{\texttt{buf.fill(fill)}}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{5}\OperatorTok{,} \StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 61 61 61 61 61\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{5}\OperatorTok{,} \StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 61 61 61 61 61\textgreater{}}
\end{Highlighting}
\end{Shaded}

If both \texttt{fill} and \texttt{encoding} are specified, the allocated
\texttt{Buffer} will be initialized by calling
\hyperref[buffillvalue-offset-end-encoding]{\texttt{buf.fill(fill,\ encoding)}}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{11}\OperatorTok{,} \StringTok{\textquotesingle{}aGVsbG8gd29ybGQ=\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}base64\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{11}\OperatorTok{,} \StringTok{\textquotesingle{}aGVsbG8gd29ybGQ=\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}base64\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64\textgreater{}}
\end{Highlighting}
\end{Shaded}

Calling
\hyperref[static-method-bufferallocsize-fill-encoding]{\texttt{Buffer.alloc()}}
can be measurably slower than the alternative
\hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe()}}
but ensures that the newly created \texttt{Buffer} instance contents
will never contain sensitive data from previous allocations, including
data that might not have been allocated for \texttt{Buffer}s.

A \texttt{TypeError} will be thrown if \texttt{size} is not a number.

\subsubsection{\texorpdfstring{Static method:
\texttt{Buffer.allocUnsafe(size)}}{Static method: Buffer.allocUnsafe(size)}}\label{static-method-buffer.allocunsafesize}

\begin{itemize}
\tightlist
\item
  \texttt{size} \{integer\} The desired length of the new
  \texttt{Buffer}.
\end{itemize}

Allocates a new \texttt{Buffer} of \texttt{size} bytes. If \texttt{size}
is larger than
\hyperref[bufferconstantsmax_length]{\texttt{buffer.constants.MAX\_LENGTH}}
or smaller than 0,
\href{errors.md\#err_out_of_range}{\texttt{ERR\_OUT\_OF\_RANGE}} is
thrown.

The underlying memory for \texttt{Buffer} instances created in this way
is \emph{not initialized}. The contents of the newly created
\texttt{Buffer} are unknown and \emph{may contain sensitive data}. Use
\hyperref[static-method-bufferallocsize-fill-encoding]{\texttt{Buffer.alloc()}}
instead to initialize \texttt{Buffer} instances with zeroes.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints (contents may vary): \textless{}Buffer a0 8b 28 3f 01 00 00 00 50 32\textgreater{}}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 00 00 00 00 00 00 00 00 00 00\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints (contents may vary): \textless{}Buffer a0 8b 28 3f 01 00 00 00 50 32\textgreater{}}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 00 00 00 00 00 00 00 00 00 00\textgreater{}}
\end{Highlighting}
\end{Shaded}

A \texttt{TypeError} will be thrown if \texttt{size} is not a number.

The \texttt{Buffer} module pre-allocates an internal \texttt{Buffer}
instance of size
\hyperref[class-property-bufferpoolsize]{\texttt{Buffer.poolSize}} that
is used as a pool for the fast allocation of new \texttt{Buffer}
instances created using
\hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe()}},
\hyperref[static-method-bufferfromarray]{\texttt{Buffer.from(array)}},
and
\hyperref[static-method-bufferconcatlist-totallength]{\texttt{Buffer.concat()}}
only when \texttt{size} is less than
\texttt{Buffer.poolSize\ \textgreater{}\textgreater{}\textgreater{}\ 1}
(floor of
\hyperref[class-property-bufferpoolsize]{\texttt{Buffer.poolSize}}
divided by two).

Use of this pre-allocated internal memory pool is a key difference
between calling \texttt{Buffer.alloc(size,\ fill)}
vs.~\texttt{Buffer.allocUnsafe(size).fill(fill)}. Specifically,
\texttt{Buffer.alloc(size,\ fill)} will \emph{never} use the internal
\texttt{Buffer} pool, while \texttt{Buffer.allocUnsafe(size).fill(fill)}
\emph{will} use the internal \texttt{Buffer} pool if \texttt{size} is
less than or equal to half
\hyperref[class-property-bufferpoolsize]{\texttt{Buffer.poolSize}}. The
difference is subtle but can be important when an application requires
the additional performance that
\hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe()}}
provides.

\subsubsection{\texorpdfstring{Static method:
\texttt{Buffer.allocUnsafeSlow(size)}}{Static method: Buffer.allocUnsafeSlow(size)}}\label{static-method-buffer.allocunsafeslowsize}

\begin{itemize}
\tightlist
\item
  \texttt{size} \{integer\} The desired length of the new
  \texttt{Buffer}.
\end{itemize}

Allocates a new \texttt{Buffer} of \texttt{size} bytes. If \texttt{size}
is larger than
\hyperref[bufferconstantsmax_length]{\texttt{buffer.constants.MAX\_LENGTH}}
or smaller than 0,
\href{errors.md\#err_out_of_range}{\texttt{ERR\_OUT\_OF\_RANGE}} is
thrown. A zero-length \texttt{Buffer} is created if \texttt{size} is 0.

The underlying memory for \texttt{Buffer} instances created in this way
is \emph{not initialized}. The contents of the newly created
\texttt{Buffer} are unknown and \emph{may contain sensitive data}. Use
\hyperref[buffillvalue-offset-end-encoding]{\texttt{buf.fill(0)}} to
initialize such \texttt{Buffer} instances with zeroes.

When using
\hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe()}}
to allocate new \texttt{Buffer} instances, allocations under 4 KiB are
sliced from a single pre-allocated \texttt{Buffer}. This allows
applications to avoid the garbage collection overhead of creating many
individually allocated \texttt{Buffer} instances. This approach improves
both performance and memory usage by eliminating the need to track and
clean up as many individual \texttt{ArrayBuffer} objects.

However, in the case where a developer may need to retain a small chunk
of memory from a pool for an indeterminate amount of time, it may be
appropriate to create an un-pooled \texttt{Buffer} instance using
\texttt{Buffer.allocUnsafeSlow()} and then copying out the relevant
bits.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Need to keep around a few small chunks of memory.}
\KeywordTok{const}\NormalTok{ store }\OperatorTok{=}\NormalTok{ []}\OperatorTok{;}

\NormalTok{socket}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}readable\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{let}\NormalTok{ data}\OperatorTok{;}
  \ControlFlowTok{while}\NormalTok{ (}\KeywordTok{null} \OperatorTok{!==}\NormalTok{ (data }\OperatorTok{=}\NormalTok{ readable}\OperatorTok{.}\FunctionTok{read}\NormalTok{())) \{}
    \CommentTok{// Allocate for retained data.}
    \KeywordTok{const}\NormalTok{ sb }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafeSlow}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}

    \CommentTok{// Copy the data into the new allocation.}
\NormalTok{    data}\OperatorTok{.}\FunctionTok{copy}\NormalTok{(sb}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{10}\NormalTok{)}\OperatorTok{;}

\NormalTok{    store}\OperatorTok{.}\FunctionTok{push}\NormalTok{(sb)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Need to keep around a few small chunks of memory.}
\KeywordTok{const}\NormalTok{ store }\OperatorTok{=}\NormalTok{ []}\OperatorTok{;}

\NormalTok{socket}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}readable\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{let}\NormalTok{ data}\OperatorTok{;}
  \ControlFlowTok{while}\NormalTok{ (}\KeywordTok{null} \OperatorTok{!==}\NormalTok{ (data }\OperatorTok{=}\NormalTok{ readable}\OperatorTok{.}\FunctionTok{read}\NormalTok{())) \{}
    \CommentTok{// Allocate for retained data.}
    \KeywordTok{const}\NormalTok{ sb }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafeSlow}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}

    \CommentTok{// Copy the data into the new allocation.}
\NormalTok{    data}\OperatorTok{.}\FunctionTok{copy}\NormalTok{(sb}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{10}\NormalTok{)}\OperatorTok{;}

\NormalTok{    store}\OperatorTok{.}\FunctionTok{push}\NormalTok{(sb)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

A \texttt{TypeError} will be thrown if \texttt{size} is not a number.

\subsubsection{\texorpdfstring{Static method:
\texttt{Buffer.byteLength(string{[},\ encoding{]})}}{Static method: Buffer.byteLength(string{[}, encoding{]})}}\label{static-method-buffer.bytelengthstring-encoding}

\begin{itemize}
\tightlist
\item
  \texttt{string}
  \{string\textbar Buffer\textbar TypedArray\textbar DataView\textbar ArrayBuffer\textbar SharedArrayBuffer\}
  A value to calculate the length of.
\item
  \texttt{encoding} \{string\} If \texttt{string} is a string, this is
  its encoding. \textbf{Default:}
  \texttt{\textquotesingle{}utf8\textquotesingle{}}.
\item
  Returns: \{integer\} The number of bytes contained within
  \texttt{string}.
\end{itemize}

Returns the byte length of a string when encoded using
\texttt{encoding}. This is not the same as
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length}{\texttt{String.prototype.length}},
which does not account for the encoding that is used to convert the
string into bytes.

For \texttt{\textquotesingle{}base64\textquotesingle{}},
\texttt{\textquotesingle{}base64url\textquotesingle{}}, and
\texttt{\textquotesingle{}hex\textquotesingle{}}, this function assumes
valid input. For strings that contain non-base64/hex-encoded data
(e.g.~whitespace), the return value might be greater than the length of
a \texttt{Buffer} created from the string.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ str }\OperatorTok{=} \StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u00bd}\StringTok{ + }\SpecialCharTok{\textbackslash{}u00bc}\StringTok{ = }\SpecialCharTok{\textbackslash{}u00be}\StringTok{\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}}\SpecialCharTok{$\{}\NormalTok{str}\SpecialCharTok{\}}\VerbatimStringTok{: }\SpecialCharTok{$\{}\NormalTok{str}\OperatorTok{.}\AttributeTok{length}\SpecialCharTok{\}}\VerbatimStringTok{ characters, \textasciigrave{}} \OperatorTok{+}
            \VerbatimStringTok{\textasciigrave{}}\SpecialCharTok{$\{}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{byteLength}\NormalTok{(str}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\SpecialCharTok{\}}\VerbatimStringTok{ bytes\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: ½ + ¼ = ¾: 9 characters, 12 bytes}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ str }\OperatorTok{=} \StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u00bd}\StringTok{ + }\SpecialCharTok{\textbackslash{}u00bc}\StringTok{ = }\SpecialCharTok{\textbackslash{}u00be}\StringTok{\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}}\SpecialCharTok{$\{}\NormalTok{str}\SpecialCharTok{\}}\VerbatimStringTok{: }\SpecialCharTok{$\{}\NormalTok{str}\OperatorTok{.}\AttributeTok{length}\SpecialCharTok{\}}\VerbatimStringTok{ characters, \textasciigrave{}} \OperatorTok{+}
            \VerbatimStringTok{\textasciigrave{}}\SpecialCharTok{$\{}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{byteLength}\NormalTok{(str}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\SpecialCharTok{\}}\VerbatimStringTok{ bytes\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: ½ + ¼ = ¾: 9 characters, 12 bytes}
\end{Highlighting}
\end{Shaded}

When \texttt{string} is a
\texttt{Buffer}/\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView}{\texttt{DataView}}/\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray}{\texttt{TypedArray}}/\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}{\texttt{ArrayBuffer}}/
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer}{\texttt{SharedArrayBuffer}},
the byte length as reported by \texttt{.byteLength} is returned.

\subsubsection{\texorpdfstring{Static method:
\texttt{Buffer.compare(buf1,\ buf2)}}{Static method: Buffer.compare(buf1, buf2)}}\label{static-method-buffer.comparebuf1-buf2}

\begin{itemize}
\tightlist
\item
  \texttt{buf1} \{Buffer\textbar Uint8Array\}
\item
  \texttt{buf2} \{Buffer\textbar Uint8Array\}
\item
  Returns: \{integer\} Either \texttt{-1}, \texttt{0}, or \texttt{1},
  depending on the result of the comparison. See
  \hyperref[bufcomparetarget-targetstart-targetend-sourcestart-sourceend]{\texttt{buf.compare()}}
  for details.
\end{itemize}

Compares \texttt{buf1} to \texttt{buf2}, typically for the purpose of
sorting arrays of \texttt{Buffer} instances. This is equivalent to
calling
\hyperref[bufcomparetarget-targetstart-targetend-sourcestart-sourceend]{\texttt{buf1.compare(buf2)}}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}1234\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}0123\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ arr }\OperatorTok{=}\NormalTok{ [buf1}\OperatorTok{,}\NormalTok{ buf2]}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(arr}\OperatorTok{.}\FunctionTok{sort}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\AttributeTok{compare}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: [ \textless{}Buffer 30 31 32 33\textgreater{}, \textless{}Buffer 31 32 33 34\textgreater{} ]}
\CommentTok{// (This result is equal to: [buf2, buf1].)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}1234\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}0123\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ arr }\OperatorTok{=}\NormalTok{ [buf1}\OperatorTok{,}\NormalTok{ buf2]}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(arr}\OperatorTok{.}\FunctionTok{sort}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\AttributeTok{compare}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: [ \textless{}Buffer 30 31 32 33\textgreater{}, \textless{}Buffer 31 32 33 34\textgreater{} ]}
\CommentTok{// (This result is equal to: [buf2, buf1].)}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Static method:
\texttt{Buffer.concat(list{[},\ totalLength{]})}}{Static method: Buffer.concat(list{[}, totalLength{]})}}\label{static-method-buffer.concatlist-totallength}

\begin{itemize}
\tightlist
\item
  \texttt{list} \{Buffer{[}{]} \textbar{} Uint8Array{[}{]}\} List of
  \texttt{Buffer} or
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}{\texttt{Uint8Array}}
  instances to concatenate.
\item
  \texttt{totalLength} \{integer\} Total length of the \texttt{Buffer}
  instances in \texttt{list} when concatenated.
\item
  Returns: \{Buffer\}
\end{itemize}

Returns a new \texttt{Buffer} which is the result of concatenating all
the \texttt{Buffer} instances in the \texttt{list} together.

If the list has no items, or if the \texttt{totalLength} is 0, then a
new zero-length \texttt{Buffer} is returned.

If \texttt{totalLength} is not provided, it is calculated from the
\texttt{Buffer} instances in \texttt{list} by adding their lengths.

If \texttt{totalLength} is provided, it is coerced to an unsigned
integer. If the combined length of the \texttt{Buffer}s in \texttt{list}
exceeds \texttt{totalLength}, the result is truncated to
\texttt{totalLength}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Create a single \textasciigrave{}Buffer\textasciigrave{} from a list of three \textasciigrave{}Buffer\textasciigrave{} instances.}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{14}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf3 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{18}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ totalLength }\OperatorTok{=}\NormalTok{ buf1}\OperatorTok{.}\AttributeTok{length} \OperatorTok{+}\NormalTok{ buf2}\OperatorTok{.}\AttributeTok{length} \OperatorTok{+}\NormalTok{ buf3}\OperatorTok{.}\AttributeTok{length}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(totalLength)}\OperatorTok{;}
\CommentTok{// Prints: 42}

\KeywordTok{const}\NormalTok{ bufA }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{concat}\NormalTok{([buf1}\OperatorTok{,}\NormalTok{ buf2}\OperatorTok{,}\NormalTok{ buf3]}\OperatorTok{,}\NormalTok{ totalLength)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(bufA)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 00 00 00 00 ...\textgreater{}}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(bufA}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 42}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Create a single \textasciigrave{}Buffer\textasciigrave{} from a list of three \textasciigrave{}Buffer\textasciigrave{} instances.}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{14}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf3 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{18}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ totalLength }\OperatorTok{=}\NormalTok{ buf1}\OperatorTok{.}\AttributeTok{length} \OperatorTok{+}\NormalTok{ buf2}\OperatorTok{.}\AttributeTok{length} \OperatorTok{+}\NormalTok{ buf3}\OperatorTok{.}\AttributeTok{length}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(totalLength)}\OperatorTok{;}
\CommentTok{// Prints: 42}

\KeywordTok{const}\NormalTok{ bufA }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{concat}\NormalTok{([buf1}\OperatorTok{,}\NormalTok{ buf2}\OperatorTok{,}\NormalTok{ buf3]}\OperatorTok{,}\NormalTok{ totalLength)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(bufA)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 00 00 00 00 ...\textgreater{}}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(bufA}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 42}
\end{Highlighting}
\end{Shaded}

\texttt{Buffer.concat()} may also use the internal \texttt{Buffer} pool
like
\hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe()}}
does.

\subsubsection{\texorpdfstring{Static method:
\texttt{Buffer.copyBytesFrom(view{[},\ offset{[},\ length{]}{]})}}{Static method: Buffer.copyBytesFrom(view{[}, offset{[}, length{]}{]})}}\label{static-method-buffer.copybytesfromview-offset-length}

\begin{itemize}
\tightlist
\item
  \texttt{view} \{TypedArray\} The \{TypedArray\} to copy.
\item
  \texttt{offset} \{integer\} The starting offset within \texttt{view}.
  \textbf{Default:}: \texttt{0}.
\item
  \texttt{length} \{integer\} The number of elements from \texttt{view}
  to copy. \textbf{Default:} \texttt{view.length\ -\ offset}.
\end{itemize}

Copies the underlying memory of \texttt{view} into a new
\texttt{Buffer}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ u16 }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Uint16Array}\NormalTok{([}\DecValTok{0}\OperatorTok{,} \BaseNTok{0xffff}\NormalTok{])}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{copyBytesFrom}\NormalTok{(u16}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{1}\NormalTok{)}\OperatorTok{;}
\NormalTok{u16[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;} \CommentTok{// 2}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf[}\DecValTok{0}\NormalTok{])}\OperatorTok{;} \CommentTok{// 255}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf[}\DecValTok{1}\NormalTok{])}\OperatorTok{;} \CommentTok{// 255}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Static method:
\texttt{Buffer.from(array)}}{Static method: Buffer.from(array)}}\label{static-method-buffer.fromarray}

\begin{itemize}
\tightlist
\item
  \texttt{array} \{integer{[}{]}\}
\end{itemize}

Allocates a new \texttt{Buffer} using an \texttt{array} of bytes in the
range \texttt{0} -- \texttt{255}. Array entries outside that range will
be truncated to fit into it.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Creates a new Buffer containing the UTF{-}8 bytes of the string \textquotesingle{}buffer\textquotesingle{}.}
\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x62}\OperatorTok{,} \BaseNTok{0x75}\OperatorTok{,} \BaseNTok{0x66}\OperatorTok{,} \BaseNTok{0x66}\OperatorTok{,} \BaseNTok{0x65}\OperatorTok{,} \BaseNTok{0x72}\NormalTok{])}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Creates a new Buffer containing the UTF{-}8 bytes of the string \textquotesingle{}buffer\textquotesingle{}.}
\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x62}\OperatorTok{,} \BaseNTok{0x75}\OperatorTok{,} \BaseNTok{0x66}\OperatorTok{,} \BaseNTok{0x66}\OperatorTok{,} \BaseNTok{0x65}\OperatorTok{,} \BaseNTok{0x72}\NormalTok{])}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

If \texttt{array} is an \texttt{Array}-like object (that is, one with a
\texttt{length} property of type \texttt{number}), it is treated as if
it is an array, unless it is a \texttt{Buffer} or a \texttt{Uint8Array}.
This means all other \texttt{TypedArray} variants get treated as an
\texttt{Array}. To create a \texttt{Buffer} from the bytes backing a
\texttt{TypedArray}, use
\hyperref[static-method-buffercopybytesfromview-offset-length]{\texttt{Buffer.copyBytesFrom()}}.

A \texttt{TypeError} will be thrown if \texttt{array} is not an
\texttt{Array} or another type appropriate for \texttt{Buffer.from()}
variants.

\texttt{Buffer.from(array)} and
\hyperref[static-method-bufferfromstring-encoding]{\texttt{Buffer.from(string)}}
may also use the internal \texttt{Buffer} pool like
\hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe()}}
does.

\subsubsection{\texorpdfstring{Static method:
\texttt{Buffer.from(arrayBuffer{[},\ byteOffset{[},\ length{]}{]})}}{Static method: Buffer.from(arrayBuffer{[}, byteOffset{[}, length{]}{]})}}\label{static-method-buffer.fromarraybuffer-byteoffset-length}

\begin{itemize}
\tightlist
\item
  \texttt{arrayBuffer} \{ArrayBuffer\textbar SharedArrayBuffer\} An
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}{\texttt{ArrayBuffer}},
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer}{\texttt{SharedArrayBuffer}},
  for example the \texttt{.buffer} property of a
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray}{\texttt{TypedArray}}.
\item
  \texttt{byteOffset} \{integer\} Index of first byte to expose.
  \textbf{Default:} \texttt{0}.
\item
  \texttt{length} \{integer\} Number of bytes to expose.
  \textbf{Default:} \texttt{arrayBuffer.byteLength\ -\ byteOffset}.
\end{itemize}

This creates a view of the
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}{\texttt{ArrayBuffer}}
without copying the underlying memory. For example, when passed a
reference to the \texttt{.buffer} property of a
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray}{\texttt{TypedArray}}
instance, the newly created \texttt{Buffer} will share the same
allocated memory as the
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray}{\texttt{TypedArray}}'s
underlying \texttt{ArrayBuffer}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ arr }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Uint16Array}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{;}

\NormalTok{arr[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{5000}\OperatorTok{;}
\NormalTok{arr[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \DecValTok{4000}\OperatorTok{;}

\CommentTok{// Shares memory with \textasciigrave{}arr\textasciigrave{}.}
\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(arr}\OperatorTok{.}\AttributeTok{buffer}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 88 13 a0 0f\textgreater{}}

\CommentTok{// Changing the original Uint16Array changes the Buffer also.}
\NormalTok{arr[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \DecValTok{6000}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 88 13 70 17\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ arr }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Uint16Array}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{;}

\NormalTok{arr[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{5000}\OperatorTok{;}
\NormalTok{arr[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \DecValTok{4000}\OperatorTok{;}

\CommentTok{// Shares memory with \textasciigrave{}arr\textasciigrave{}.}
\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(arr}\OperatorTok{.}\AttributeTok{buffer}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 88 13 a0 0f\textgreater{}}

\CommentTok{// Changing the original Uint16Array changes the Buffer also.}
\NormalTok{arr[}\DecValTok{1}\NormalTok{] }\OperatorTok{=} \DecValTok{6000}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 88 13 70 17\textgreater{}}
\end{Highlighting}
\end{Shaded}

The optional \texttt{byteOffset} and \texttt{length} arguments specify a
memory range within the \texttt{arrayBuffer} that will be shared by the
\texttt{Buffer}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ ab }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{ArrayBuffer}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(ab}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{2}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 2}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ ab }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{ArrayBuffer}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(ab}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{2}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 2}
\end{Highlighting}
\end{Shaded}

A \texttt{TypeError} will be thrown if \texttt{arrayBuffer} is not an
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}{\texttt{ArrayBuffer}}
or a
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer}{\texttt{SharedArrayBuffer}}
or another type appropriate for \texttt{Buffer.from()} variants.

It is important to remember that a backing \texttt{ArrayBuffer} can
cover a range of memory that extends beyond the bounds of a
\texttt{TypedArray} view. A new \texttt{Buffer} created using the
\texttt{buffer} property of a \texttt{TypedArray} may extend beyond the
range of the \texttt{TypedArray}:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ arrA }\OperatorTok{=} \BuiltInTok{Uint8Array}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x63}\OperatorTok{,} \BaseNTok{0x64}\OperatorTok{,} \BaseNTok{0x65}\OperatorTok{,} \BaseNTok{0x66}\NormalTok{])}\OperatorTok{;} \CommentTok{// 4 elements}
\KeywordTok{const}\NormalTok{ arrB }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Uint8Array}\NormalTok{(arrA}\OperatorTok{.}\AttributeTok{buffer}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{2}\NormalTok{)}\OperatorTok{;} \CommentTok{// 2 elements}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(arrA}\OperatorTok{.}\AttributeTok{buffer} \OperatorTok{===}\NormalTok{ arrB}\OperatorTok{.}\AttributeTok{buffer}\NormalTok{)}\OperatorTok{;} \CommentTok{// true}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(arrB}\OperatorTok{.}\AttributeTok{buffer}\NormalTok{)}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 63 64 65 66\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ arrA }\OperatorTok{=} \BuiltInTok{Uint8Array}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x63}\OperatorTok{,} \BaseNTok{0x64}\OperatorTok{,} \BaseNTok{0x65}\OperatorTok{,} \BaseNTok{0x66}\NormalTok{])}\OperatorTok{;} \CommentTok{// 4 elements}
\KeywordTok{const}\NormalTok{ arrB }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Uint8Array}\NormalTok{(arrA}\OperatorTok{.}\AttributeTok{buffer}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{2}\NormalTok{)}\OperatorTok{;} \CommentTok{// 2 elements}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(arrA}\OperatorTok{.}\AttributeTok{buffer} \OperatorTok{===}\NormalTok{ arrB}\OperatorTok{.}\AttributeTok{buffer}\NormalTok{)}\OperatorTok{;} \CommentTok{// true}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(arrB}\OperatorTok{.}\AttributeTok{buffer}\NormalTok{)}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 63 64 65 66\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Static method:
\texttt{Buffer.from(buffer)}}{Static method: Buffer.from(buffer)}}\label{static-method-buffer.frombuffer}

\begin{itemize}
\tightlist
\item
  \texttt{buffer} \{Buffer\textbar Uint8Array\} An existing
  \texttt{Buffer} or
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}{\texttt{Uint8Array}}
  from which to copy data.
\end{itemize}

Copies the passed \texttt{buffer} data onto a new \texttt{Buffer}
instance.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(buf1)}\OperatorTok{;}

\NormalTok{buf1[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \BaseNTok{0x61}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: auffer}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: buffer}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(buf1)}\OperatorTok{;}

\NormalTok{buf1[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \BaseNTok{0x61}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: auffer}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: buffer}
\end{Highlighting}
\end{Shaded}

A \texttt{TypeError} will be thrown if \texttt{buffer} is not a
\texttt{Buffer} or another type appropriate for \texttt{Buffer.from()}
variants.

\subsubsection{\texorpdfstring{Static method:
\texttt{Buffer.from(object{[},\ offsetOrEncoding{[},\ length{]}{]})}}{Static method: Buffer.from(object{[}, offsetOrEncoding{[}, length{]}{]})}}\label{static-method-buffer.fromobject-offsetorencoding-length}

\begin{itemize}
\tightlist
\item
  \texttt{object} \{Object\} An object supporting
  \texttt{Symbol.toPrimitive} or \texttt{valueOf()}.
\item
  \texttt{offsetOrEncoding} \{integer\textbar string\} A byte-offset or
  encoding.
\item
  \texttt{length} \{integer\} A length.
\end{itemize}

For objects whose \texttt{valueOf()} function returns a value not
strictly equal to \texttt{object}, returns
\texttt{Buffer.from(object.valueOf(),\ offsetOrEncoding,\ length)}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\KeywordTok{new} \BuiltInTok{String}\NormalTok{(}\StringTok{\textquotesingle{}this is a test\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\KeywordTok{new} \BuiltInTok{String}\NormalTok{(}\StringTok{\textquotesingle{}this is a test\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74\textgreater{}}
\end{Highlighting}
\end{Shaded}

For objects that support \texttt{Symbol.toPrimitive}, returns
\texttt{Buffer.from(object{[}Symbol.toPrimitive{]}(\textquotesingle{}string\textquotesingle{}),\ offsetOrEncoding)}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{class}\NormalTok{ Foo \{}
\NormalTok{  [}\BuiltInTok{Symbol}\OperatorTok{.}\AttributeTok{toPrimitive}\NormalTok{]() \{}
    \ControlFlowTok{return} \StringTok{\textquotesingle{}this is a test\textquotesingle{}}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\KeywordTok{new} \FunctionTok{Foo}\NormalTok{()}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{class}\NormalTok{ Foo \{}
\NormalTok{  [}\BuiltInTok{Symbol}\OperatorTok{.}\AttributeTok{toPrimitive}\NormalTok{]() \{}
    \ControlFlowTok{return} \StringTok{\textquotesingle{}this is a test\textquotesingle{}}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\KeywordTok{new} \FunctionTok{Foo}\NormalTok{()}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 74 68 69 73 20 69 73 20 61 20 74 65 73 74\textgreater{}}
\end{Highlighting}
\end{Shaded}

A \texttt{TypeError} will be thrown if \texttt{object} does not have the
mentioned methods or is not of another type appropriate for
\texttt{Buffer.from()} variants.

\subsubsection{\texorpdfstring{Static method:
\texttt{Buffer.from(string{[},\ encoding{]})}}{Static method: Buffer.from(string{[}, encoding{]})}}\label{static-method-buffer.fromstring-encoding}

\begin{itemize}
\tightlist
\item
  \texttt{string} \{string\} A string to encode.
\item
  \texttt{encoding} \{string\} The encoding of \texttt{string}.
  \textbf{Default:} \texttt{\textquotesingle{}utf8\textquotesingle{}}.
\end{itemize}

Creates a new \texttt{Buffer} containing \texttt{string}. The
\texttt{encoding} parameter identifies the character encoding to be used
when converting \texttt{string} into bytes.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}this is a tést\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}7468697320697320612074c3a97374\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: this is a tést}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: this is a tést}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}latin1\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: this is a tÃ©st}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}this is a tést\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}7468697320697320612074c3a97374\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: this is a tést}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: this is a tést}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}latin1\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: this is a tÃ©st}
\end{Highlighting}
\end{Shaded}

A \texttt{TypeError} will be thrown if \texttt{string} is not a string
or another type appropriate for \texttt{Buffer.from()} variants.

\subsubsection{\texorpdfstring{Static method:
\texttt{Buffer.isBuffer(obj)}}{Static method: Buffer.isBuffer(obj)}}\label{static-method-buffer.isbufferobj}

\begin{itemize}
\tightlist
\item
  \texttt{obj} \{Object\}
\item
  Returns: \{boolean\}
\end{itemize}

Returns \texttt{true} if \texttt{obj} is a \texttt{Buffer},
\texttt{false} otherwise.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isBuffer}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{10}\NormalTok{))}\OperatorTok{;} \CommentTok{// true}
\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isBuffer}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}foo\textquotesingle{}}\NormalTok{))}\OperatorTok{;} \CommentTok{// true}
\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isBuffer}\NormalTok{(}\StringTok{\textquotesingle{}a string\textquotesingle{}}\NormalTok{)}\OperatorTok{;} \CommentTok{// false}
\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isBuffer}\NormalTok{([])}\OperatorTok{;} \CommentTok{// false}
\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isBuffer}\NormalTok{(}\KeywordTok{new} \BuiltInTok{Uint8Array}\NormalTok{(}\DecValTok{1024}\NormalTok{))}\OperatorTok{;} \CommentTok{// false}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isBuffer}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{10}\NormalTok{))}\OperatorTok{;} \CommentTok{// true}
\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isBuffer}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}foo\textquotesingle{}}\NormalTok{))}\OperatorTok{;} \CommentTok{// true}
\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isBuffer}\NormalTok{(}\StringTok{\textquotesingle{}a string\textquotesingle{}}\NormalTok{)}\OperatorTok{;} \CommentTok{// false}
\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isBuffer}\NormalTok{([])}\OperatorTok{;} \CommentTok{// false}
\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isBuffer}\NormalTok{(}\KeywordTok{new} \BuiltInTok{Uint8Array}\NormalTok{(}\DecValTok{1024}\NormalTok{))}\OperatorTok{;} \CommentTok{// false}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Static method:
\texttt{Buffer.isEncoding(encoding)}}{Static method: Buffer.isEncoding(encoding)}}\label{static-method-buffer.isencodingencoding}

\begin{itemize}
\tightlist
\item
  \texttt{encoding} \{string\} A character encoding name to check.
\item
  Returns: \{boolean\}
\end{itemize}

Returns \texttt{true} if \texttt{encoding} is the name of a supported
character encoding, or \texttt{false} otherwise.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isEncoding}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: true}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isEncoding}\NormalTok{(}\StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: true}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isEncoding}\NormalTok{(}\StringTok{\textquotesingle{}utf/8\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: false}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isEncoding}\NormalTok{(}\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: false}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isEncoding}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: true}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isEncoding}\NormalTok{(}\StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: true}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isEncoding}\NormalTok{(}\StringTok{\textquotesingle{}utf/8\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: false}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isEncoding}\NormalTok{(}\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: false}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Class property:
\texttt{Buffer.poolSize}}{Class property: Buffer.poolSize}}\label{class-property-buffer.poolsize}

\begin{itemize}
\tightlist
\item
  \{integer\} \textbf{Default:} \texttt{8192}
\end{itemize}

This is the size (in bytes) of pre-allocated internal \texttt{Buffer}
instances used for pooling. This value may be modified.

\subsubsection{\texorpdfstring{\texttt{buf{[}index{]}}}{buf{[}index{]}}}\label{bufindex}

\begin{itemize}
\tightlist
\item
  \texttt{index} \{integer\}
\end{itemize}

The index operator \texttt{{[}index{]}} can be used to get and set the
octet at position \texttt{index} in \texttt{buf}. The values refer to
individual bytes, so the legal value range is between \texttt{0x00} and
\texttt{0xFF} (hex) or \texttt{0} and \texttt{255} (decimal).

This operator is inherited from \texttt{Uint8Array}, so its behavior on
out-of-bounds access is the same as \texttt{Uint8Array}. In other words,
\texttt{buf{[}index{]}} returns \texttt{undefined} when \texttt{index}
is negative or greater or equal to \texttt{buf.length}, and
\texttt{buf{[}index{]}\ =\ value} does not modify the buffer if
\texttt{index} is negative or \texttt{\textgreater{}=\ buf.length}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Copy an ASCII string into a \textasciigrave{}Buffer\textasciigrave{} one byte at a time.}
\CommentTok{// (This only works for ASCII{-}only strings. In general, one should use}
\CommentTok{// \textasciigrave{}Buffer.from()\textasciigrave{} to perform this conversion.)}

\KeywordTok{const}\NormalTok{ str }\OperatorTok{=} \StringTok{\textquotesingle{}Node.js\textquotesingle{}}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(str}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ str}\OperatorTok{.}\AttributeTok{length}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) \{}
\NormalTok{  buf[i] }\OperatorTok{=}\NormalTok{ str}\OperatorTok{.}\FunctionTok{charCodeAt}\NormalTok{(i)}\OperatorTok{;}
\NormalTok{\}}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: Node.js}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Copy an ASCII string into a \textasciigrave{}Buffer\textasciigrave{} one byte at a time.}
\CommentTok{// (This only works for ASCII{-}only strings. In general, one should use}
\CommentTok{// \textasciigrave{}Buffer.from()\textasciigrave{} to perform this conversion.)}

\KeywordTok{const}\NormalTok{ str }\OperatorTok{=} \StringTok{\textquotesingle{}Node.js\textquotesingle{}}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(str}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ str}\OperatorTok{.}\AttributeTok{length}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) \{}
\NormalTok{  buf[i] }\OperatorTok{=}\NormalTok{ str}\OperatorTok{.}\FunctionTok{charCodeAt}\NormalTok{(i)}\OperatorTok{;}
\NormalTok{\}}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: Node.js}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.buffer}}{buf.buffer}}\label{buf.buffer}

\begin{itemize}
\tightlist
\item
  \{ArrayBuffer\} The underlying \texttt{ArrayBuffer} object based on
  which this \texttt{Buffer} object is created.
\end{itemize}

This \texttt{ArrayBuffer} is not guaranteed to correspond exactly to the
original \texttt{Buffer}. See the notes on \texttt{buf.byteOffset} for
details.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ arrayBuffer }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{ArrayBuffer}\NormalTok{(}\DecValTok{16}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buffer }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(arrayBuffer)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buffer}\OperatorTok{.}\AttributeTok{buffer} \OperatorTok{===}\NormalTok{ arrayBuffer)}\OperatorTok{;}
\CommentTok{// Prints: true}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ arrayBuffer }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{ArrayBuffer}\NormalTok{(}\DecValTok{16}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buffer }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(arrayBuffer)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buffer}\OperatorTok{.}\AttributeTok{buffer} \OperatorTok{===}\NormalTok{ arrayBuffer)}\OperatorTok{;}
\CommentTok{// Prints: true}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.byteOffset}}{buf.byteOffset}}\label{buf.byteoffset}

\begin{itemize}
\tightlist
\item
  \{integer\} The \texttt{byteOffset} of the \texttt{Buffer}s underlying
  \texttt{ArrayBuffer} object.
\end{itemize}

When setting \texttt{byteOffset} in
\texttt{Buffer.from(ArrayBuffer,\ byteOffset,\ length)}, or sometimes
when allocating a \texttt{Buffer} smaller than \texttt{Buffer.poolSize},
the buffer does not start from a zero offset on the underlying
\texttt{ArrayBuffer}.

This can cause problems when accessing the underlying
\texttt{ArrayBuffer} directly using \texttt{buf.buffer}, as other parts
of the \texttt{ArrayBuffer} may be unrelated to the \texttt{Buffer}
object itself.

A common issue when creating a \texttt{TypedArray} object that shares
its memory with a \texttt{Buffer} is that in this case one needs to
specify the \texttt{byteOffset} correctly:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Create a buffer smaller than \textasciigrave{}Buffer.poolSize\textasciigrave{}.}
\KeywordTok{const}\NormalTok{ nodeBuffer }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{0}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{7}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{9}\NormalTok{])}\OperatorTok{;}

\CommentTok{// When casting the Node.js Buffer to an Int8Array, use the byteOffset}
\CommentTok{// to refer only to the part of \textasciigrave{}nodeBuffer.buffer\textasciigrave{} that contains the memory}
\CommentTok{// for \textasciigrave{}nodeBuffer\textasciigrave{}.}
\KeywordTok{new} \BuiltInTok{Int8Array}\NormalTok{(nodeBuffer}\OperatorTok{.}\AttributeTok{buffer}\OperatorTok{,}\NormalTok{ nodeBuffer}\OperatorTok{.}\AttributeTok{byteOffset}\OperatorTok{,}\NormalTok{ nodeBuffer}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Create a buffer smaller than \textasciigrave{}Buffer.poolSize\textasciigrave{}.}
\KeywordTok{const}\NormalTok{ nodeBuffer }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{0}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{7}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{9}\NormalTok{])}\OperatorTok{;}

\CommentTok{// When casting the Node.js Buffer to an Int8Array, use the byteOffset}
\CommentTok{// to refer only to the part of \textasciigrave{}nodeBuffer.buffer\textasciigrave{} that contains the memory}
\CommentTok{// for \textasciigrave{}nodeBuffer\textasciigrave{}.}
\KeywordTok{new} \BuiltInTok{Int8Array}\NormalTok{(nodeBuffer}\OperatorTok{.}\AttributeTok{buffer}\OperatorTok{,}\NormalTok{ nodeBuffer}\OperatorTok{.}\AttributeTok{byteOffset}\OperatorTok{,}\NormalTok{ nodeBuffer}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.compare(target{[},\ targetStart{[},\ targetEnd{[},\ sourceStart{[},\ sourceEnd{]}{]}{]}{]})}}{buf.compare(target{[}, targetStart{[}, targetEnd{[}, sourceStart{[}, sourceEnd{]}{]}{]}{]})}}\label{buf.comparetarget-targetstart-targetend-sourcestart-sourceend}

\begin{itemize}
\tightlist
\item
  \texttt{target} \{Buffer\textbar Uint8Array\} A \texttt{Buffer} or
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}{\texttt{Uint8Array}}
  with which to compare \texttt{buf}.
\item
  \texttt{targetStart} \{integer\} The offset within \texttt{target} at
  which to begin comparison. \textbf{Default:} \texttt{0}.
\item
  \texttt{targetEnd} \{integer\} The offset within \texttt{target} at
  which to end comparison (not inclusive). \textbf{Default:}
  \texttt{target.length}.
\item
  \texttt{sourceStart} \{integer\} The offset within \texttt{buf} at
  which to begin comparison. \textbf{Default:} \texttt{0}.
\item
  \texttt{sourceEnd} \{integer\} The offset within \texttt{buf} at which
  to end comparison (not inclusive). \textbf{Default:}
  \hyperref[buflength]{\texttt{buf.length}}.
\item
  Returns: \{integer\}
\end{itemize}

Compares \texttt{buf} with \texttt{target} and returns a number
indicating whether \texttt{buf} comes before, after, or is the same as
\texttt{target} in sort order. Comparison is based on the actual
sequence of bytes in each \texttt{Buffer}.

\begin{itemize}
\tightlist
\item
  \texttt{0} is returned if \texttt{target} is the same as \texttt{buf}
\item
  \texttt{1} is returned if \texttt{target} should come \emph{before}
  \texttt{buf} when sorted.
\item
  \texttt{-1} is returned if \texttt{target} should come \emph{after}
  \texttt{buf} when sorted.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}ABC\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}BCD\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf3 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}ABCD\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf1))}\OperatorTok{;}
\CommentTok{// Prints: 0}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf2))}\OperatorTok{;}
\CommentTok{// Prints: {-}1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf3))}\OperatorTok{;}
\CommentTok{// Prints: {-}1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf1))}\OperatorTok{;}
\CommentTok{// Prints: 1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf3))}\OperatorTok{;}
\CommentTok{// Prints: 1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{([buf1}\OperatorTok{,}\NormalTok{ buf2}\OperatorTok{,}\NormalTok{ buf3]}\OperatorTok{.}\FunctionTok{sort}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\AttributeTok{compare}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: [ \textless{}Buffer 41 42 43\textgreater{}, \textless{}Buffer 41 42 43 44\textgreater{}, \textless{}Buffer 42 43 44\textgreater{} ]}
\CommentTok{// (This result is equal to: [buf1, buf3, buf2].)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}ABC\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}BCD\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf3 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}ABCD\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf1))}\OperatorTok{;}
\CommentTok{// Prints: 0}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf2))}\OperatorTok{;}
\CommentTok{// Prints: {-}1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf3))}\OperatorTok{;}
\CommentTok{// Prints: {-}1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf1))}\OperatorTok{;}
\CommentTok{// Prints: 1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf3))}\OperatorTok{;}
\CommentTok{// Prints: 1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{([buf1}\OperatorTok{,}\NormalTok{ buf2}\OperatorTok{,}\NormalTok{ buf3]}\OperatorTok{.}\FunctionTok{sort}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\AttributeTok{compare}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: [ \textless{}Buffer 41 42 43\textgreater{}, \textless{}Buffer 41 42 43 44\textgreater{}, \textless{}Buffer 42 43 44\textgreater{} ]}
\CommentTok{// (This result is equal to: [buf1, buf3, buf2].)}
\end{Highlighting}
\end{Shaded}

The optional \texttt{targetStart}, \texttt{targetEnd},
\texttt{sourceStart}, and \texttt{sourceEnd} arguments can be used to
limit the comparison to specific ranges within \texttt{target} and
\texttt{buf} respectively.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{7}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{9}\NormalTok{])}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{7}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{9}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf2}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{9}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{4}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 0}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf2}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{4}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: {-}1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf2}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{5}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 1}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{7}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{9}\NormalTok{])}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{7}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{9}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf2}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{9}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{4}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 0}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf2}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{4}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: {-}1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{compare}\NormalTok{(buf2}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{5}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 1}
\end{Highlighting}
\end{Shaded}

\href{errors.md\#err_out_of_range}{\texttt{ERR\_OUT\_OF\_RANGE}} is
thrown if \texttt{targetStart\ \textless{}\ 0},
\texttt{sourceStart\ \textless{}\ 0},
\texttt{targetEnd\ \textgreater{}\ target.byteLength}, or
\texttt{sourceEnd\ \textgreater{}\ source.byteLength}.

\subsubsection{\texorpdfstring{\texttt{buf.copy(target{[},\ targetStart{[},\ sourceStart{[},\ sourceEnd{]}{]}{]})}}{buf.copy(target{[}, targetStart{[}, sourceStart{[}, sourceEnd{]}{]}{]})}}\label{buf.copytarget-targetstart-sourcestart-sourceend}

\begin{itemize}
\tightlist
\item
  \texttt{target} \{Buffer\textbar Uint8Array\} A \texttt{Buffer} or
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}{\texttt{Uint8Array}}
  to copy into.
\item
  \texttt{targetStart} \{integer\} The offset within \texttt{target} at
  which to begin writing. \textbf{Default:} \texttt{0}.
\item
  \texttt{sourceStart} \{integer\} The offset within \texttt{buf} from
  which to begin copying. \textbf{Default:} \texttt{0}.
\item
  \texttt{sourceEnd} \{integer\} The offset within \texttt{buf} at which
  to stop copying (not inclusive). \textbf{Default:}
  \hyperref[buflength]{\texttt{buf.length}}.
\item
  Returns: \{integer\} The number of bytes copied.
\end{itemize}

Copies data from a region of \texttt{buf} to a region in
\texttt{target}, even if the \texttt{target} memory region overlaps with
\texttt{buf}.

\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set}{\texttt{TypedArray.prototype.set()}}
performs the same operation, and is available for all TypedArrays,
including Node.js \texttt{Buffer}s, although it takes different function
arguments.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Create two \textasciigrave{}Buffer\textasciigrave{} instances.}
\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{26}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{26}\NormalTok{)}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}!\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{26}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) \{}
  \CommentTok{// 97 is the decimal ASCII value for \textquotesingle{}a\textquotesingle{}.}
\NormalTok{  buf1[i] }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \DecValTok{97}\OperatorTok{;}
\NormalTok{\}}

\CommentTok{// Copy \textasciigrave{}buf1\textasciigrave{} bytes 16 through 19 into \textasciigrave{}buf2\textasciigrave{} starting at byte 8 of \textasciigrave{}buf2\textasciigrave{}.}
\NormalTok{buf1}\OperatorTok{.}\FunctionTok{copy}\NormalTok{(buf2}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{16}\OperatorTok{,} \DecValTok{20}\NormalTok{)}\OperatorTok{;}
\CommentTok{// This is equivalent to:}
\CommentTok{// buf2.set(buf1.subarray(16, 20), 8);}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}ascii\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{25}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: !!!!!!!!qrst!!!!!!!!!!!!!}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Create two \textasciigrave{}Buffer\textasciigrave{} instances.}
\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{26}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{26}\NormalTok{)}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}!\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{26}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) \{}
  \CommentTok{// 97 is the decimal ASCII value for \textquotesingle{}a\textquotesingle{}.}
\NormalTok{  buf1[i] }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \DecValTok{97}\OperatorTok{;}
\NormalTok{\}}

\CommentTok{// Copy \textasciigrave{}buf1\textasciigrave{} bytes 16 through 19 into \textasciigrave{}buf2\textasciigrave{} starting at byte 8 of \textasciigrave{}buf2\textasciigrave{}.}
\NormalTok{buf1}\OperatorTok{.}\FunctionTok{copy}\NormalTok{(buf2}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{16}\OperatorTok{,} \DecValTok{20}\NormalTok{)}\OperatorTok{;}
\CommentTok{// This is equivalent to:}
\CommentTok{// buf2.set(buf1.subarray(16, 20), 8);}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}ascii\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{25}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: !!!!!!!!qrst!!!!!!!!!!!!!}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Create a \textasciigrave{}Buffer\textasciigrave{} and copy data from one region to an overlapping region}
\CommentTok{// within the same \textasciigrave{}Buffer\textasciigrave{}.}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{26}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{26}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) \{}
  \CommentTok{// 97 is the decimal ASCII value for \textquotesingle{}a\textquotesingle{}.}
\NormalTok{  buf[i] }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \DecValTok{97}\OperatorTok{;}
\NormalTok{\}}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{copy}\NormalTok{(buf}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{10}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: efghijghijklmnopqrstuvwxyz}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Create a \textasciigrave{}Buffer\textasciigrave{} and copy data from one region to an overlapping region}
\CommentTok{// within the same \textasciigrave{}Buffer\textasciigrave{}.}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{26}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{26}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) \{}
  \CommentTok{// 97 is the decimal ASCII value for \textquotesingle{}a\textquotesingle{}.}
\NormalTok{  buf[i] }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \DecValTok{97}\OperatorTok{;}
\NormalTok{\}}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{copy}\NormalTok{(buf}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{10}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: efghijghijklmnopqrstuvwxyz}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.entries()}}{buf.entries()}}\label{buf.entries}

\begin{itemize}
\tightlist
\item
  Returns: \{Iterator\}
\end{itemize}

Creates and returns an
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols}{iterator}
of \texttt{{[}index,\ byte{]}} pairs from the contents of \texttt{buf}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Log the entire contents of a \textasciigrave{}Buffer\textasciigrave{}.}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ pair }\KeywordTok{of}\NormalTok{ buf}\OperatorTok{.}\FunctionTok{entries}\NormalTok{()) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(pair)}\OperatorTok{;}
\NormalTok{\}}
\CommentTok{// Prints:}
\CommentTok{//   [0, 98]}
\CommentTok{//   [1, 117]}
\CommentTok{//   [2, 102]}
\CommentTok{//   [3, 102]}
\CommentTok{//   [4, 101]}
\CommentTok{//   [5, 114]}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Log the entire contents of a \textasciigrave{}Buffer\textasciigrave{}.}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ pair }\KeywordTok{of}\NormalTok{ buf}\OperatorTok{.}\FunctionTok{entries}\NormalTok{()) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(pair)}\OperatorTok{;}
\NormalTok{\}}
\CommentTok{// Prints:}
\CommentTok{//   [0, 98]}
\CommentTok{//   [1, 117]}
\CommentTok{//   [2, 102]}
\CommentTok{//   [3, 102]}
\CommentTok{//   [4, 101]}
\CommentTok{//   [5, 114]}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.equals(otherBuffer)}}{buf.equals(otherBuffer)}}\label{buf.equalsotherbuffer}

\begin{itemize}
\tightlist
\item
  \texttt{otherBuffer} \{Buffer\textbar Uint8Array\} A \texttt{Buffer}
  or
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}{\texttt{Uint8Array}}
  with which to compare \texttt{buf}.
\item
  Returns: \{boolean\}
\end{itemize}

Returns \texttt{true} if both \texttt{buf} and \texttt{otherBuffer} have
exactly the same bytes, \texttt{false} otherwise. Equivalent to
\hyperref[bufcomparetarget-targetstart-targetend-sourcestart-sourceend]{\texttt{buf.compare(otherBuffer)\ ===\ 0}}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}ABC\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}414243\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf3 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}ABCD\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{equals}\NormalTok{(buf2))}\OperatorTok{;}
\CommentTok{// Prints: true}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{equals}\NormalTok{(buf3))}\OperatorTok{;}
\CommentTok{// Prints: false}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}ABC\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}414243\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ buf3 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}ABCD\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{equals}\NormalTok{(buf2))}\OperatorTok{;}
\CommentTok{// Prints: true}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{equals}\NormalTok{(buf3))}\OperatorTok{;}
\CommentTok{// Prints: false}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.fill(value{[},\ offset{[},\ end{]}{]}{[},\ encoding{]})}}{buf.fill(value{[}, offset{[}, end{]}{]}{[}, encoding{]})}}\label{buf.fillvalue-offset-end-encoding}

\begin{itemize}
\tightlist
\item
  \texttt{value}
  \{string\textbar Buffer\textbar Uint8Array\textbar integer\} The value
  with which to fill \texttt{buf}. Empty value (string, Uint8Array,
  Buffer) is coerced to \texttt{0}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  fill \texttt{buf}. \textbf{Default:} \texttt{0}.
\item
  \texttt{end} \{integer\} Where to stop filling \texttt{buf} (not
  inclusive). \textbf{Default:}
  \hyperref[buflength]{\texttt{buf.length}}.
\item
  \texttt{encoding} \{string\} The encoding for \texttt{value} if
  \texttt{value} is a string. \textbf{Default:}
  \texttt{\textquotesingle{}utf8\textquotesingle{}}.
\item
  Returns: \{Buffer\} A reference to \texttt{buf}.
\end{itemize}

Fills \texttt{buf} with the specified \texttt{value}. If the
\texttt{offset} and \texttt{end} are not given, the entire \texttt{buf}
will be filled:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Fill a \textasciigrave{}Buffer\textasciigrave{} with the ASCII character \textquotesingle{}h\textquotesingle{}.}

\KeywordTok{const}\NormalTok{ b }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{50}\NormalTok{)}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh}

\CommentTok{// Fill a buffer with empty string}
\KeywordTok{const}\NormalTok{ c }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{5}\NormalTok{)}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(c}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 00 00 00 00 00\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Fill a \textasciigrave{}Buffer\textasciigrave{} with the ASCII character \textquotesingle{}h\textquotesingle{}.}

\KeywordTok{const}\NormalTok{ b }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{50}\NormalTok{)}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh}

\CommentTok{// Fill a buffer with empty string}
\KeywordTok{const}\NormalTok{ c }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{5}\NormalTok{)}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(c}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 00 00 00 00 00\textgreater{}}
\end{Highlighting}
\end{Shaded}

\texttt{value} is coerced to a \texttt{uint32} value if it is not a
string, \texttt{Buffer}, or integer. If the resulting integer is greater
than \texttt{255} (decimal), \texttt{buf} will be filled with
\texttt{value\ \&\ 255}.

If the final write of a \texttt{fill()} operation falls on a multi-byte
character, then only the bytes of that character that fit into
\texttt{buf} are written:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Fill a \textasciigrave{}Buffer\textasciigrave{} with character that takes up two bytes in UTF{-}8.}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{5}\NormalTok{)}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u0222}\StringTok{\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer c8 a2 c8 a2 c8\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Fill a \textasciigrave{}Buffer\textasciigrave{} with character that takes up two bytes in UTF{-}8.}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{5}\NormalTok{)}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u0222}\StringTok{\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer c8 a2 c8 a2 c8\textgreater{}}
\end{Highlighting}
\end{Shaded}

If \texttt{value} contains invalid characters, it is truncated; if no
valid fill data remains, an exception is thrown:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{5}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 61 61 61 61 61\textgreater{}}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}aazz\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer aa aa aa aa aa\textgreater{}}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}zz\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws an exception.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{5}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 61 61 61 61 61\textgreater{}}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}aazz\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer aa aa aa aa aa\textgreater{}}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{fill}\NormalTok{(}\StringTok{\textquotesingle{}zz\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws an exception.}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.includes(value{[},\ byteOffset{]}{[},\ encoding{]})}}{buf.includes(value{[}, byteOffset{]}{[}, encoding{]})}}\label{buf.includesvalue-byteoffset-encoding}

\begin{itemize}
\tightlist
\item
  \texttt{value}
  \{string\textbar Buffer\textbar Uint8Array\textbar integer\} What to
  search for.
\item
  \texttt{byteOffset} \{integer\} Where to begin searching in
  \texttt{buf}. If negative, then offset is calculated from the end of
  \texttt{buf}. \textbf{Default:} \texttt{0}.
\item
  \texttt{encoding} \{string\} If \texttt{value} is a string, this is
  its encoding. \textbf{Default:}
  \texttt{\textquotesingle{}utf8\textquotesingle{}}.
\item
  Returns: \{boolean\} \texttt{true} if \texttt{value} was found in
  \texttt{buf}, \texttt{false} otherwise.
\end{itemize}

Equivalent to
\hyperref[bufindexofvalue-byteoffset-encoding]{\texttt{buf.indexOf()\ !==\ -1}}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}this is a buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\StringTok{\textquotesingle{}this\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: true}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\StringTok{\textquotesingle{}is\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: true}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}a buffer\textquotesingle{}}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: true}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\DecValTok{97}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: true (97 is the decimal ASCII value for \textquotesingle{}a\textquotesingle{})}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}a buffer example\textquotesingle{}}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: false}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}a buffer example\textquotesingle{}}\NormalTok{)}\OperatorTok{.}\FunctionTok{slice}\NormalTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{8}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: true}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\StringTok{\textquotesingle{}this\textquotesingle{}}\OperatorTok{,} \DecValTok{4}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: false}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}this is a buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\StringTok{\textquotesingle{}this\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: true}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\StringTok{\textquotesingle{}is\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: true}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}a buffer\textquotesingle{}}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: true}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\DecValTok{97}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: true (97 is the decimal ASCII value for \textquotesingle{}a\textquotesingle{})}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}a buffer example\textquotesingle{}}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: false}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}a buffer example\textquotesingle{}}\NormalTok{)}\OperatorTok{.}\FunctionTok{slice}\NormalTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{8}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: true}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\StringTok{\textquotesingle{}this\textquotesingle{}}\OperatorTok{,} \DecValTok{4}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: false}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.indexOf(value{[},\ byteOffset{]}{[},\ encoding{]})}}{buf.indexOf(value{[}, byteOffset{]}{[}, encoding{]})}}\label{buf.indexofvalue-byteoffset-encoding}

\begin{itemize}
\tightlist
\item
  \texttt{value}
  \{string\textbar Buffer\textbar Uint8Array\textbar integer\} What to
  search for.
\item
  \texttt{byteOffset} \{integer\} Where to begin searching in
  \texttt{buf}. If negative, then offset is calculated from the end of
  \texttt{buf}. \textbf{Default:} \texttt{0}.
\item
  \texttt{encoding} \{string\} If \texttt{value} is a string, this is
  the encoding used to determine the binary representation of the string
  that will be searched for in \texttt{buf}. \textbf{Default:}
  \texttt{\textquotesingle{}utf8\textquotesingle{}}.
\item
  Returns: \{integer\} The index of the first occurrence of
  \texttt{value} in \texttt{buf}, or \texttt{-1} if \texttt{buf} does
  not contain \texttt{value}.
\end{itemize}

If \texttt{value} is:

\begin{itemize}
\tightlist
\item
  a string, \texttt{value} is interpreted according to the character
  encoding in \texttt{encoding}.
\item
  a \texttt{Buffer} or
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}{\texttt{Uint8Array}},
  \texttt{value} will be used in its entirety. To compare a partial
  \texttt{Buffer}, use
  \hyperref[bufsubarraystart-end]{\texttt{buf.subarray}}.
\item
  a number, \texttt{value} will be interpreted as an unsigned 8-bit
  integer value between \texttt{0} and \texttt{255}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}this is a buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}this\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 0}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}is\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 2}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}a buffer\textquotesingle{}}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: 8}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\DecValTok{97}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 8 (97 is the decimal ASCII value for \textquotesingle{}a\textquotesingle{})}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}a buffer example\textquotesingle{}}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: {-}1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}a buffer example\textquotesingle{}}\NormalTok{)}\OperatorTok{.}\FunctionTok{slice}\NormalTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{8}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: 8}

\KeywordTok{const}\NormalTok{ utf16Buffer }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u039a\textbackslash{}u0391\textbackslash{}u03a3\textbackslash{}u03a3\textbackslash{}u0395}\StringTok{\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(utf16Buffer}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u03a3}\StringTok{\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 4}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(utf16Buffer}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u03a3}\StringTok{\textquotesingle{}}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{4}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 6}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}this is a buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}this\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 0}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}is\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 2}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}a buffer\textquotesingle{}}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: 8}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\DecValTok{97}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 8 (97 is the decimal ASCII value for \textquotesingle{}a\textquotesingle{})}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}a buffer example\textquotesingle{}}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: {-}1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}a buffer example\textquotesingle{}}\NormalTok{)}\OperatorTok{.}\FunctionTok{slice}\NormalTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{8}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: 8}

\KeywordTok{const}\NormalTok{ utf16Buffer }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u039a\textbackslash{}u0391\textbackslash{}u03a3\textbackslash{}u03a3\textbackslash{}u0395}\StringTok{\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(utf16Buffer}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u03a3}\StringTok{\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 4}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(utf16Buffer}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u03a3}\StringTok{\textquotesingle{}}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{4}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 6}
\end{Highlighting}
\end{Shaded}

If \texttt{value} is not a string, number, or \texttt{Buffer}, this
method will throw a \texttt{TypeError}. If \texttt{value} is a number,
it will be coerced to a valid byte value, an integer between 0 and 255.

If \texttt{byteOffset} is not a number, it will be coerced to a number.
If the result of coercion is \texttt{NaN} or \texttt{0}, then the entire
buffer will be searched. This behavior matches
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf}{\texttt{String.prototype.indexOf()}}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ b }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}abcdef\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Passing a value that\textquotesingle{}s a number, but not a valid byte.}
\CommentTok{// Prints: 2, equivalent to searching for 99 or \textquotesingle{}c\textquotesingle{}.}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\FloatTok{99.9}\NormalTok{))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\DecValTok{256} \OperatorTok{+} \DecValTok{99}\NormalTok{))}\OperatorTok{;}

\CommentTok{// Passing a byteOffset that coerces to NaN or 0.}
\CommentTok{// Prints: 1, searching the whole buffer.}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,} \KeywordTok{undefined}\NormalTok{))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,}\NormalTok{ \{\}))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,} \KeywordTok{null}\NormalTok{))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,}\NormalTok{ []))}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ b }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}abcdef\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Passing a value that\textquotesingle{}s a number, but not a valid byte.}
\CommentTok{// Prints: 2, equivalent to searching for 99 or \textquotesingle{}c\textquotesingle{}.}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\FloatTok{99.9}\NormalTok{))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\DecValTok{256} \OperatorTok{+} \DecValTok{99}\NormalTok{))}\OperatorTok{;}

\CommentTok{// Passing a byteOffset that coerces to NaN or 0.}
\CommentTok{// Prints: 1, searching the whole buffer.}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,} \KeywordTok{undefined}\NormalTok{))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,}\NormalTok{ \{\}))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,} \KeywordTok{null}\NormalTok{))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,}\NormalTok{ []))}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

If \texttt{value} is an empty string or empty \texttt{Buffer} and
\texttt{byteOffset} is less than \texttt{buf.length},
\texttt{byteOffset} will be returned. If \texttt{value} is empty and
\texttt{byteOffset} is at least \texttt{buf.length}, \texttt{buf.length}
will be returned.

\subsubsection{\texorpdfstring{\texttt{buf.keys()}}{buf.keys()}}\label{buf.keys}

\begin{itemize}
\tightlist
\item
  Returns: \{Iterator\}
\end{itemize}

Creates and returns an
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols}{iterator}
of \texttt{buf} keys (indices).

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ key }\KeywordTok{of}\NormalTok{ buf}\OperatorTok{.}\FunctionTok{keys}\NormalTok{()) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(key)}\OperatorTok{;}
\NormalTok{\}}
\CommentTok{// Prints:}
\CommentTok{//   0}
\CommentTok{//   1}
\CommentTok{//   2}
\CommentTok{//   3}
\CommentTok{//   4}
\CommentTok{//   5}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ key }\KeywordTok{of}\NormalTok{ buf}\OperatorTok{.}\FunctionTok{keys}\NormalTok{()) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(key)}\OperatorTok{;}
\NormalTok{\}}
\CommentTok{// Prints:}
\CommentTok{//   0}
\CommentTok{//   1}
\CommentTok{//   2}
\CommentTok{//   3}
\CommentTok{//   4}
\CommentTok{//   5}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.lastIndexOf(value{[},\ byteOffset{]}{[},\ encoding{]})}}{buf.lastIndexOf(value{[}, byteOffset{]}{[}, encoding{]})}}\label{buf.lastindexofvalue-byteoffset-encoding}

\begin{itemize}
\tightlist
\item
  \texttt{value}
  \{string\textbar Buffer\textbar Uint8Array\textbar integer\} What to
  search for.
\item
  \texttt{byteOffset} \{integer\} Where to begin searching in
  \texttt{buf}. If negative, then offset is calculated from the end of
  \texttt{buf}. \textbf{Default:} \texttt{buf.length\ -\ 1}.
\item
  \texttt{encoding} \{string\} If \texttt{value} is a string, this is
  the encoding used to determine the binary representation of the string
  that will be searched for in \texttt{buf}. \textbf{Default:}
  \texttt{\textquotesingle{}utf8\textquotesingle{}}.
\item
  Returns: \{integer\} The index of the last occurrence of
  \texttt{value} in \texttt{buf}, or \texttt{-1} if \texttt{buf} does
  not contain \texttt{value}.
\end{itemize}

Identical to
\hyperref[bufindexofvalue-byteoffset-encoding]{\texttt{buf.indexOf()}},
except the last occurrence of \texttt{value} is found rather than the
first occurrence.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}this buffer is a buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}this\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 0}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 17}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: 17}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\DecValTok{97}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 15 (97 is the decimal ASCII value for \textquotesingle{}a\textquotesingle{})}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}yolo\textquotesingle{}}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: {-}1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\OperatorTok{,} \DecValTok{5}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 5}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\OperatorTok{,} \DecValTok{4}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: {-}1}

\KeywordTok{const}\NormalTok{ utf16Buffer }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u039a\textbackslash{}u0391\textbackslash{}u03a3\textbackslash{}u03a3\textbackslash{}u0395}\StringTok{\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(utf16Buffer}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u03a3}\StringTok{\textquotesingle{}}\OperatorTok{,} \KeywordTok{undefined}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 6}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(utf16Buffer}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u03a3}\StringTok{\textquotesingle{}}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{5}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 4}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}this buffer is a buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}this\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 0}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 17}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: 17}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\DecValTok{97}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 15 (97 is the decimal ASCII value for \textquotesingle{}a\textquotesingle{})}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}yolo\textquotesingle{}}\NormalTok{)))}\OperatorTok{;}
\CommentTok{// Prints: {-}1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\OperatorTok{,} \DecValTok{5}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 5}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\OperatorTok{,} \DecValTok{4}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: {-}1}

\KeywordTok{const}\NormalTok{ utf16Buffer }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u039a\textbackslash{}u0391\textbackslash{}u03a3\textbackslash{}u03a3\textbackslash{}u0395}\StringTok{\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(utf16Buffer}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u03a3}\StringTok{\textquotesingle{}}\OperatorTok{,} \KeywordTok{undefined}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 6}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(utf16Buffer}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u03a3}\StringTok{\textquotesingle{}}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{5}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 4}
\end{Highlighting}
\end{Shaded}

If \texttt{value} is not a string, number, or \texttt{Buffer}, this
method will throw a \texttt{TypeError}. If \texttt{value} is a number,
it will be coerced to a valid byte value, an integer between 0 and 255.

If \texttt{byteOffset} is not a number, it will be coerced to a number.
Any arguments that coerce to \texttt{NaN}, like \texttt{\{\}} or
\texttt{undefined}, will search the whole buffer. This behavior matches
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf}{\texttt{String.prototype.lastIndexOf()}}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ b }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}abcdef\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Passing a value that\textquotesingle{}s a number, but not a valid byte.}
\CommentTok{// Prints: 2, equivalent to searching for 99 or \textquotesingle{}c\textquotesingle{}.}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\FloatTok{99.9}\NormalTok{))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\DecValTok{256} \OperatorTok{+} \DecValTok{99}\NormalTok{))}\OperatorTok{;}

\CommentTok{// Passing a byteOffset that coerces to NaN.}
\CommentTok{// Prints: 1, searching the whole buffer.}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,} \KeywordTok{undefined}\NormalTok{))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,}\NormalTok{ \{\}))}\OperatorTok{;}

\CommentTok{// Passing a byteOffset that coerces to 0.}
\CommentTok{// Prints: {-}1, equivalent to passing 0.}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,} \KeywordTok{null}\NormalTok{))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,}\NormalTok{ []))}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ b }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}abcdef\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Passing a value that\textquotesingle{}s a number, but not a valid byte.}
\CommentTok{// Prints: 2, equivalent to searching for 99 or \textquotesingle{}c\textquotesingle{}.}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\FloatTok{99.9}\NormalTok{))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\DecValTok{256} \OperatorTok{+} \DecValTok{99}\NormalTok{))}\OperatorTok{;}

\CommentTok{// Passing a byteOffset that coerces to NaN.}
\CommentTok{// Prints: 1, searching the whole buffer.}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,} \KeywordTok{undefined}\NormalTok{))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,}\NormalTok{ \{\}))}\OperatorTok{;}

\CommentTok{// Passing a byteOffset that coerces to 0.}
\CommentTok{// Prints: {-}1, equivalent to passing 0.}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,} \KeywordTok{null}\NormalTok{))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(b}\OperatorTok{.}\FunctionTok{lastIndexOf}\NormalTok{(}\StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{,}\NormalTok{ []))}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

If \texttt{value} is an empty string or empty \texttt{Buffer},
\texttt{byteOffset} will be returned.

\subsubsection{\texorpdfstring{\texttt{buf.length}}{buf.length}}\label{buf.length}

\begin{itemize}
\tightlist
\item
  \{integer\}
\end{itemize}

Returns the number of bytes in \texttt{buf}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Create a \textasciigrave{}Buffer\textasciigrave{} and write a shorter string to it using UTF{-}8.}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{1234}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 1234}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}some string\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 1234}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Create a \textasciigrave{}Buffer\textasciigrave{} and write a shorter string to it using UTF{-}8.}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{1234}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 1234}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}some string\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 1234}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.parent}}{buf.parent}}\label{buf.parent}

\begin{quote}
Stability: 0 - Deprecated: Use \hyperref[bufbuffer]{\texttt{buf.buffer}}
instead.
\end{quote}

The \texttt{buf.parent} property is a deprecated alias for
\texttt{buf.buffer}.

\subsubsection{\texorpdfstring{\texttt{buf.readBigInt64BE({[}offset{]})}}{buf.readBigInt64BE({[}offset{]})}}\label{buf.readbigint64beoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy:
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 8}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{bigint\}
\end{itemize}

Reads a signed, big-endian 64-bit integer from \texttt{buf} at the
specified \texttt{offset}.

Integers read from a \texttt{Buffer} are interpreted as two's complement
signed values.

\subsubsection{\texorpdfstring{\texttt{buf.readBigInt64LE({[}offset{]})}}{buf.readBigInt64LE({[}offset{]})}}\label{buf.readbigint64leoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy:
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 8}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{bigint\}
\end{itemize}

Reads a signed, little-endian 64-bit integer from \texttt{buf} at the
specified \texttt{offset}.

Integers read from a \texttt{Buffer} are interpreted as two's complement
signed values.

\subsubsection{\texorpdfstring{\texttt{buf.readBigUInt64BE({[}offset{]})}}{buf.readBigUInt64BE({[}offset{]})}}\label{buf.readbiguint64beoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy:
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 8}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{bigint\}
\end{itemize}

Reads an unsigned, big-endian 64-bit integer from \texttt{buf} at the
specified \texttt{offset}.

This function is also available under the \texttt{readBigUint64BE}
alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0xff}\OperatorTok{,} \BaseNTok{0xff}\OperatorTok{,} \BaseNTok{0xff}\OperatorTok{,} \BaseNTok{0xff}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readBigUInt64BE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 4294967295n}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0xff}\OperatorTok{,} \BaseNTok{0xff}\OperatorTok{,} \BaseNTok{0xff}\OperatorTok{,} \BaseNTok{0xff}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readBigUInt64BE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 4294967295n}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readBigUInt64LE({[}offset{]})}}{buf.readBigUInt64LE({[}offset{]})}}\label{buf.readbiguint64leoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy:
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 8}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{bigint\}
\end{itemize}

Reads an unsigned, little-endian 64-bit integer from \texttt{buf} at the
specified \texttt{offset}.

This function is also available under the \texttt{readBigUint64LE}
alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0xff}\OperatorTok{,} \BaseNTok{0xff}\OperatorTok{,} \BaseNTok{0xff}\OperatorTok{,} \BaseNTok{0xff}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readBigUInt64LE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 18446744069414584320n}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0x00}\OperatorTok{,} \BaseNTok{0xff}\OperatorTok{,} \BaseNTok{0xff}\OperatorTok{,} \BaseNTok{0xff}\OperatorTok{,} \BaseNTok{0xff}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readBigUInt64LE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 18446744069414584320n}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readDoubleBE({[}offset{]})}}{buf.readDoubleBE({[}offset{]})}}\label{buf.readdoublebeoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 8}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{number\}
\end{itemize}

Reads a 64-bit, big-endian double from \texttt{buf} at the specified
\texttt{offset}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{7}\OperatorTok{,} \DecValTok{8}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readDoubleBE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 8.20788039913184e{-}304}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{7}\OperatorTok{,} \DecValTok{8}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readDoubleBE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 8.20788039913184e{-}304}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readDoubleLE({[}offset{]})}}{buf.readDoubleLE({[}offset{]})}}\label{buf.readdoubleleoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 8}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{number\}
\end{itemize}

Reads a 64-bit, little-endian double from \texttt{buf} at the specified
\texttt{offset}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{7}\OperatorTok{,} \DecValTok{8}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readDoubleLE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 5.447603722011605e{-}270}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readDoubleLE}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\OperatorTok{,} \DecValTok{5}\OperatorTok{,} \DecValTok{6}\OperatorTok{,} \DecValTok{7}\OperatorTok{,} \DecValTok{8}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readDoubleLE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 5.447603722011605e{-}270}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readDoubleLE}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readFloatBE({[}offset{]})}}{buf.readFloatBE({[}offset{]})}}\label{buf.readfloatbeoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 4}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{number\}
\end{itemize}

Reads a 32-bit, big-endian float from \texttt{buf} at the specified
\texttt{offset}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readFloatBE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 2.387939260590663e{-}38}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readFloatBE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 2.387939260590663e{-}38}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readFloatLE({[}offset{]})}}{buf.readFloatLE({[}offset{]})}}\label{buf.readfloatleoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 4}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{number\}
\end{itemize}

Reads a 32-bit, little-endian float from \texttt{buf} at the specified
\texttt{offset}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readFloatLE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 1.539989614439558e{-}36}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readFloatLE}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readFloatLE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 1.539989614439558e{-}36}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readFloatLE}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readInt8({[}offset{]})}}{buf.readInt8({[}offset{]})}}\label{buf.readint8offset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 1}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\}
\end{itemize}

Reads a signed 8-bit integer from \texttt{buf} at the specified
\texttt{offset}.

Integers read from a \texttt{Buffer} are interpreted as two's complement
signed values.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{,} \DecValTok{5}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt8}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: {-}1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt8}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 5}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt8}\NormalTok{(}\DecValTok{2}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\OperatorTok{{-}}\DecValTok{1}\OperatorTok{,} \DecValTok{5}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt8}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: {-}1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt8}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 5}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt8}\NormalTok{(}\DecValTok{2}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readInt16BE({[}offset{]})}}{buf.readInt16BE({[}offset{]})}}\label{buf.readint16beoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 2}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\}
\end{itemize}

Reads a signed, big-endian 16-bit integer from \texttt{buf} at the
specified \texttt{offset}.

Integers read from a \texttt{Buffer} are interpreted as two's complement
signed values.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{0}\OperatorTok{,} \DecValTok{5}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt16BE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 5}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{0}\OperatorTok{,} \DecValTok{5}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt16BE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 5}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readInt16LE({[}offset{]})}}{buf.readInt16LE({[}offset{]})}}\label{buf.readint16leoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 2}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\}
\end{itemize}

Reads a signed, little-endian 16-bit integer from \texttt{buf} at the
specified \texttt{offset}.

Integers read from a \texttt{Buffer} are interpreted as two's complement
signed values.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{0}\OperatorTok{,} \DecValTok{5}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt16LE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 1280}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt16LE}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{0}\OperatorTok{,} \DecValTok{5}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt16LE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 1280}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt16LE}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readInt32BE({[}offset{]})}}{buf.readInt32BE({[}offset{]})}}\label{buf.readint32beoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 4}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\}
\end{itemize}

Reads a signed, big-endian 32-bit integer from \texttt{buf} at the
specified \texttt{offset}.

Integers read from a \texttt{Buffer} are interpreted as two's complement
signed values.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{5}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt32BE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 5}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{5}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt32BE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 5}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readInt32LE({[}offset{]})}}{buf.readInt32LE({[}offset{]})}}\label{buf.readint32leoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 4}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\}
\end{itemize}

Reads a signed, little-endian 32-bit integer from \texttt{buf} at the
specified \texttt{offset}.

Integers read from a \texttt{Buffer} are interpreted as two's complement
signed values.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{5}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt32LE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 83886080}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt32LE}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{5}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt32LE}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 83886080}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readInt32LE}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readIntBE(offset,\ byteLength)}}{buf.readIntBE(offset, byteLength)}}\label{buf.readintbeoffset-bytelength}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ byteLength}.
\item
  \texttt{byteLength} \{integer\} Number of bytes to read. Must satisfy
  \texttt{0\ \textless{}\ byteLength\ \textless{}=\ 6}.
\item
  Returns: \{integer\}
\end{itemize}

Reads \texttt{byteLength} number of bytes from \texttt{buf} at the
specified \texttt{offset} and interprets the result as a big-endian,
two's complement signed value supporting up to 48 bits of accuracy.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\OperatorTok{,} \BaseNTok{0x78}\OperatorTok{,} \BaseNTok{0x90}\OperatorTok{,} \BaseNTok{0xab}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readIntBE}\NormalTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 1234567890ab}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readIntBE}\NormalTok{(}\DecValTok{1}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readIntBE}\NormalTok{(}\DecValTok{1}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\OperatorTok{,} \BaseNTok{0x78}\OperatorTok{,} \BaseNTok{0x90}\OperatorTok{,} \BaseNTok{0xab}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readIntBE}\NormalTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 1234567890ab}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readIntBE}\NormalTok{(}\DecValTok{1}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readIntBE}\NormalTok{(}\DecValTok{1}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readIntLE(offset,\ byteLength)}}{buf.readIntLE(offset, byteLength)}}\label{buf.readintleoffset-bytelength}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ byteLength}.
\item
  \texttt{byteLength} \{integer\} Number of bytes to read. Must satisfy
  \texttt{0\ \textless{}\ byteLength\ \textless{}=\ 6}.
\item
  Returns: \{integer\}
\end{itemize}

Reads \texttt{byteLength} number of bytes from \texttt{buf} at the
specified \texttt{offset} and interprets the result as a little-endian,
two's complement signed value supporting up to 48 bits of accuracy.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\OperatorTok{,} \BaseNTok{0x78}\OperatorTok{,} \BaseNTok{0x90}\OperatorTok{,} \BaseNTok{0xab}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readIntLE}\NormalTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: {-}546f87a9cbee}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\OperatorTok{,} \BaseNTok{0x78}\OperatorTok{,} \BaseNTok{0x90}\OperatorTok{,} \BaseNTok{0xab}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readIntLE}\NormalTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: {-}546f87a9cbee}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readUInt8({[}offset{]})}}{buf.readUInt8({[}offset{]})}}\label{buf.readuint8offset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 1}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\}
\end{itemize}

Reads an unsigned 8-bit integer from \texttt{buf} at the specified
\texttt{offset}.

This function is also available under the \texttt{readUint8} alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{2}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt8}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt8}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 254}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt8}\NormalTok{(}\DecValTok{2}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{2}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt8}\NormalTok{(}\DecValTok{0}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 1}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt8}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 254}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt8}\NormalTok{(}\DecValTok{2}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readUInt16BE({[}offset{]})}}{buf.readUInt16BE({[}offset{]})}}\label{buf.readuint16beoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 2}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\}
\end{itemize}

Reads an unsigned, big-endian 16-bit integer from \texttt{buf} at the
specified \texttt{offset}.

This function is also available under the \texttt{readUint16BE} alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt16BE}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 1234}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt16BE}\NormalTok{(}\DecValTok{1}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 3456}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt16BE}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 1234}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt16BE}\NormalTok{(}\DecValTok{1}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 3456}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readUInt16LE({[}offset{]})}}{buf.readUInt16LE({[}offset{]})}}\label{buf.readuint16leoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 2}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\}
\end{itemize}

Reads an unsigned, little-endian 16-bit integer from \texttt{buf} at the
specified \texttt{offset}.

This function is also available under the \texttt{readUint16LE} alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt16LE}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 3412}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt16LE}\NormalTok{(}\DecValTok{1}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 5634}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt16LE}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt16LE}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 3412}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt16LE}\NormalTok{(}\DecValTok{1}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 5634}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt16LE}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readUInt32BE({[}offset{]})}}{buf.readUInt32BE({[}offset{]})}}\label{buf.readuint32beoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 4}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\}
\end{itemize}

Reads an unsigned, big-endian 32-bit integer from \texttt{buf} at the
specified \texttt{offset}.

This function is also available under the \texttt{readUint32BE} alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\OperatorTok{,} \BaseNTok{0x78}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt32BE}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 12345678}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\OperatorTok{,} \BaseNTok{0x78}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt32BE}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 12345678}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readUInt32LE({[}offset{]})}}{buf.readUInt32LE({[}offset{]})}}\label{buf.readuint32leoffset}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 4}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\}
\end{itemize}

Reads an unsigned, little-endian 32-bit integer from \texttt{buf} at the
specified \texttt{offset}.

This function is also available under the \texttt{readUint32LE} alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\OperatorTok{,} \BaseNTok{0x78}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt32LE}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 78563412}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt32LE}\NormalTok{(}\DecValTok{1}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\OperatorTok{,} \BaseNTok{0x78}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt32LE}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 78563412}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUInt32LE}\NormalTok{(}\DecValTok{1}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readUIntBE(offset,\ byteLength)}}{buf.readUIntBE(offset, byteLength)}}\label{buf.readuintbeoffset-bytelength}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ byteLength}.
\item
  \texttt{byteLength} \{integer\} Number of bytes to read. Must satisfy
  \texttt{0\ \textless{}\ byteLength\ \textless{}=\ 6}.
\item
  Returns: \{integer\}
\end{itemize}

Reads \texttt{byteLength} number of bytes from \texttt{buf} at the
specified \texttt{offset} and interprets the result as an unsigned
big-endian integer supporting up to 48 bits of accuracy.

This function is also available under the \texttt{readUintBE} alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\OperatorTok{,} \BaseNTok{0x78}\OperatorTok{,} \BaseNTok{0x90}\OperatorTok{,} \BaseNTok{0xab}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUIntBE}\NormalTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 1234567890ab}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUIntBE}\NormalTok{(}\DecValTok{1}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\OperatorTok{,} \BaseNTok{0x78}\OperatorTok{,} \BaseNTok{0x90}\OperatorTok{,} \BaseNTok{0xab}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUIntBE}\NormalTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 1234567890ab}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUIntBE}\NormalTok{(}\DecValTok{1}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Throws ERR\_OUT\_OF\_RANGE.}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.readUIntLE(offset,\ byteLength)}}{buf.readUIntLE(offset, byteLength)}}\label{buf.readuintleoffset-bytelength}

\begin{itemize}
\tightlist
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  read. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ byteLength}.
\item
  \texttt{byteLength} \{integer\} Number of bytes to read. Must satisfy
  \texttt{0\ \textless{}\ byteLength\ \textless{}=\ 6}.
\item
  Returns: \{integer\}
\end{itemize}

Reads \texttt{byteLength} number of bytes from \texttt{buf} at the
specified \texttt{offset} and interprets the result as an unsigned,
little-endian integer supporting up to 48 bits of accuracy.

This function is also available under the \texttt{readUintLE} alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\OperatorTok{,} \BaseNTok{0x78}\OperatorTok{,} \BaseNTok{0x90}\OperatorTok{,} \BaseNTok{0xab}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUIntLE}\NormalTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: ab9078563412}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x12}\OperatorTok{,} \BaseNTok{0x34}\OperatorTok{,} \BaseNTok{0x56}\OperatorTok{,} \BaseNTok{0x78}\OperatorTok{,} \BaseNTok{0x90}\OperatorTok{,} \BaseNTok{0xab}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{readUIntLE}\NormalTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: ab9078563412}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.subarray({[}start{[},\ end{]}{]})}}{buf.subarray({[}start{[}, end{]}{]})}}\label{buf.subarraystart-end}

\begin{itemize}
\tightlist
\item
  \texttt{start} \{integer\} Where the new \texttt{Buffer} will start.
  \textbf{Default:} \texttt{0}.
\item
  \texttt{end} \{integer\} Where the new \texttt{Buffer} will end (not
  inclusive). \textbf{Default:}
  \hyperref[buflength]{\texttt{buf.length}}.
\item
  Returns: \{Buffer\}
\end{itemize}

Returns a new \texttt{Buffer} that references the same memory as the
original, but offset and cropped by the \texttt{start} and \texttt{end}
indices.

Specifying \texttt{end} greater than
\hyperref[buflength]{\texttt{buf.length}} will return the same result as
that of \texttt{end} equal to \hyperref[buflength]{\texttt{buf.length}}.

This method is inherited from
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray}{\texttt{TypedArray.prototype.subarray()}}.

Modifying the new \texttt{Buffer} slice will modify the memory in the
original \texttt{Buffer} because the allocated memory of the two objects
overlap.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Create a \textasciigrave{}Buffer\textasciigrave{} with the ASCII alphabet, take a slice, and modify one byte}
\CommentTok{// from the original \textasciigrave{}Buffer\textasciigrave{}.}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{26}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{26}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) \{}
  \CommentTok{// 97 is the decimal ASCII value for \textquotesingle{}a\textquotesingle{}.}
\NormalTok{  buf1[i] }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \DecValTok{97}\OperatorTok{;}
\NormalTok{\}}

\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=}\NormalTok{ buf1}\OperatorTok{.}\FunctionTok{subarray}\NormalTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{3}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}ascii\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ buf2}\OperatorTok{.}\AttributeTok{length}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: abc}

\NormalTok{buf1[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{33}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}ascii\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ buf2}\OperatorTok{.}\AttributeTok{length}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: !bc}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Create a \textasciigrave{}Buffer\textasciigrave{} with the ASCII alphabet, take a slice, and modify one byte}
\CommentTok{// from the original \textasciigrave{}Buffer\textasciigrave{}.}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{26}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{26}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) \{}
  \CommentTok{// 97 is the decimal ASCII value for \textquotesingle{}a\textquotesingle{}.}
\NormalTok{  buf1[i] }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \DecValTok{97}\OperatorTok{;}
\NormalTok{\}}

\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=}\NormalTok{ buf1}\OperatorTok{.}\FunctionTok{subarray}\NormalTok{(}\DecValTok{0}\OperatorTok{,} \DecValTok{3}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}ascii\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ buf2}\OperatorTok{.}\AttributeTok{length}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: abc}

\NormalTok{buf1[}\DecValTok{0}\NormalTok{] }\OperatorTok{=} \DecValTok{33}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}ascii\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ buf2}\OperatorTok{.}\AttributeTok{length}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: !bc}
\end{Highlighting}
\end{Shaded}

Specifying negative indexes causes the slice to be generated relative to
the end of \texttt{buf} rather than the beginning.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{subarray}\NormalTok{(}\OperatorTok{{-}}\DecValTok{6}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{1}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: buffe}
\CommentTok{// (Equivalent to buf.subarray(0, 5).)}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{subarray}\NormalTok{(}\OperatorTok{{-}}\DecValTok{6}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{2}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: buff}
\CommentTok{// (Equivalent to buf.subarray(0, 4).)}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{subarray}\NormalTok{(}\OperatorTok{{-}}\DecValTok{5}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{2}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: uff}
\CommentTok{// (Equivalent to buf.subarray(1, 4).)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{subarray}\NormalTok{(}\OperatorTok{{-}}\DecValTok{6}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{1}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: buffe}
\CommentTok{// (Equivalent to buf.subarray(0, 5).)}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{subarray}\NormalTok{(}\OperatorTok{{-}}\DecValTok{6}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{2}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: buff}
\CommentTok{// (Equivalent to buf.subarray(0, 4).)}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{subarray}\NormalTok{(}\OperatorTok{{-}}\DecValTok{5}\OperatorTok{,} \OperatorTok{{-}}\DecValTok{2}\NormalTok{)}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: uff}
\CommentTok{// (Equivalent to buf.subarray(1, 4).)}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.slice({[}start{[},\ end{]}{]})}}{buf.slice({[}start{[}, end{]}{]})}}\label{buf.slicestart-end}

\begin{itemize}
\tightlist
\item
  \texttt{start} \{integer\} Where the new \texttt{Buffer} will start.
  \textbf{Default:} \texttt{0}.
\item
  \texttt{end} \{integer\} Where the new \texttt{Buffer} will end (not
  inclusive). \textbf{Default:}
  \hyperref[buflength]{\texttt{buf.length}}.
\item
  Returns: \{Buffer\}
\end{itemize}

\begin{quote}
Stability: 0 - Deprecated: Use
\hyperref[bufsubarraystart-end]{\texttt{buf.subarray}} instead.
\end{quote}

Returns a new \texttt{Buffer} that references the same memory as the
original, but offset and cropped by the \texttt{start} and \texttt{end}
indices.

This method is not compatible with the
\texttt{Uint8Array.prototype.slice()}, which is a superclass of
\texttt{Buffer}. To copy the slice, use
\texttt{Uint8Array.prototype.slice()}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ copiedBuf }\OperatorTok{=} \BuiltInTok{Uint8Array}\OperatorTok{.}\AttributeTok{prototype}\OperatorTok{.}\AttributeTok{slice}\OperatorTok{.}\FunctionTok{call}\NormalTok{(buf)}\OperatorTok{;}
\NormalTok{copiedBuf[}\DecValTok{0}\NormalTok{]}\OperatorTok{++;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(copiedBuf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: cuffer}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: buffer}

\CommentTok{// With buf.slice(), the original buffer is modified.}
\KeywordTok{const}\NormalTok{ notReallyCopiedBuf }\OperatorTok{=}\NormalTok{ buf}\OperatorTok{.}\FunctionTok{slice}\NormalTok{()}\OperatorTok{;}
\NormalTok{notReallyCopiedBuf[}\DecValTok{0}\NormalTok{]}\OperatorTok{++;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(notReallyCopiedBuf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: cuffer}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Also prints: cuffer (!)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ copiedBuf }\OperatorTok{=} \BuiltInTok{Uint8Array}\OperatorTok{.}\AttributeTok{prototype}\OperatorTok{.}\AttributeTok{slice}\OperatorTok{.}\FunctionTok{call}\NormalTok{(buf)}\OperatorTok{;}
\NormalTok{copiedBuf[}\DecValTok{0}\NormalTok{]}\OperatorTok{++;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(copiedBuf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: cuffer}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: buffer}

\CommentTok{// With buf.slice(), the original buffer is modified.}
\KeywordTok{const}\NormalTok{ notReallyCopiedBuf }\OperatorTok{=}\NormalTok{ buf}\OperatorTok{.}\FunctionTok{slice}\NormalTok{()}\OperatorTok{;}
\NormalTok{notReallyCopiedBuf[}\DecValTok{0}\NormalTok{]}\OperatorTok{++;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(notReallyCopiedBuf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints: cuffer}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Also prints: cuffer (!)}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.swap16()}}{buf.swap16()}}\label{buf.swap16}

\begin{itemize}
\tightlist
\item
  Returns: \{Buffer\} A reference to \texttt{buf}.
\end{itemize}

Interprets \texttt{buf} as an array of unsigned 16-bit integers and
swaps the byte order \emph{in-place}. Throws
\href{errors.md\#err_invalid_buffer_size}{\texttt{ERR\_INVALID\_BUFFER\_SIZE}}
if \hyperref[buflength]{\texttt{buf.length}} is not a multiple of 2.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x1}\OperatorTok{,} \BaseNTok{0x2}\OperatorTok{,} \BaseNTok{0x3}\OperatorTok{,} \BaseNTok{0x4}\OperatorTok{,} \BaseNTok{0x5}\OperatorTok{,} \BaseNTok{0x6}\OperatorTok{,} \BaseNTok{0x7}\OperatorTok{,} \BaseNTok{0x8}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 01 02 03 04 05 06 07 08\textgreater{}}

\NormalTok{buf1}\OperatorTok{.}\FunctionTok{swap16}\NormalTok{()}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 02 01 04 03 06 05 08 07\textgreater{}}

\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x1}\OperatorTok{,} \BaseNTok{0x2}\OperatorTok{,} \BaseNTok{0x3}\NormalTok{])}\OperatorTok{;}

\NormalTok{buf2}\OperatorTok{.}\FunctionTok{swap16}\NormalTok{()}\OperatorTok{;}
\CommentTok{// Throws ERR\_INVALID\_BUFFER\_SIZE.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x1}\OperatorTok{,} \BaseNTok{0x2}\OperatorTok{,} \BaseNTok{0x3}\OperatorTok{,} \BaseNTok{0x4}\OperatorTok{,} \BaseNTok{0x5}\OperatorTok{,} \BaseNTok{0x6}\OperatorTok{,} \BaseNTok{0x7}\OperatorTok{,} \BaseNTok{0x8}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 01 02 03 04 05 06 07 08\textgreater{}}

\NormalTok{buf1}\OperatorTok{.}\FunctionTok{swap16}\NormalTok{()}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 02 01 04 03 06 05 08 07\textgreater{}}

\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x1}\OperatorTok{,} \BaseNTok{0x2}\OperatorTok{,} \BaseNTok{0x3}\NormalTok{])}\OperatorTok{;}

\NormalTok{buf2}\OperatorTok{.}\FunctionTok{swap16}\NormalTok{()}\OperatorTok{;}
\CommentTok{// Throws ERR\_INVALID\_BUFFER\_SIZE.}
\end{Highlighting}
\end{Shaded}

One convenient use of \texttt{buf.swap16()} is to perform a fast
in-place conversion between UTF-16 little-endian and UTF-16 big-endian:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}This is little{-}endian UTF{-}16\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{buf}\OperatorTok{.}\FunctionTok{swap16}\NormalTok{()}\OperatorTok{;} \CommentTok{// Convert to big{-}endian UTF{-}16 text.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}This is little{-}endian UTF{-}16\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}utf16le\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{buf}\OperatorTok{.}\FunctionTok{swap16}\NormalTok{()}\OperatorTok{;} \CommentTok{// Convert to big{-}endian UTF{-}16 text.}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.swap32()}}{buf.swap32()}}\label{buf.swap32}

\begin{itemize}
\tightlist
\item
  Returns: \{Buffer\} A reference to \texttt{buf}.
\end{itemize}

Interprets \texttt{buf} as an array of unsigned 32-bit integers and
swaps the byte order \emph{in-place}. Throws
\href{errors.md\#err_invalid_buffer_size}{\texttt{ERR\_INVALID\_BUFFER\_SIZE}}
if \hyperref[buflength]{\texttt{buf.length}} is not a multiple of 4.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x1}\OperatorTok{,} \BaseNTok{0x2}\OperatorTok{,} \BaseNTok{0x3}\OperatorTok{,} \BaseNTok{0x4}\OperatorTok{,} \BaseNTok{0x5}\OperatorTok{,} \BaseNTok{0x6}\OperatorTok{,} \BaseNTok{0x7}\OperatorTok{,} \BaseNTok{0x8}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 01 02 03 04 05 06 07 08\textgreater{}}

\NormalTok{buf1}\OperatorTok{.}\FunctionTok{swap32}\NormalTok{()}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 04 03 02 01 08 07 06 05\textgreater{}}

\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x1}\OperatorTok{,} \BaseNTok{0x2}\OperatorTok{,} \BaseNTok{0x3}\NormalTok{])}\OperatorTok{;}

\NormalTok{buf2}\OperatorTok{.}\FunctionTok{swap32}\NormalTok{()}\OperatorTok{;}
\CommentTok{// Throws ERR\_INVALID\_BUFFER\_SIZE.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x1}\OperatorTok{,} \BaseNTok{0x2}\OperatorTok{,} \BaseNTok{0x3}\OperatorTok{,} \BaseNTok{0x4}\OperatorTok{,} \BaseNTok{0x5}\OperatorTok{,} \BaseNTok{0x6}\OperatorTok{,} \BaseNTok{0x7}\OperatorTok{,} \BaseNTok{0x8}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 01 02 03 04 05 06 07 08\textgreater{}}

\NormalTok{buf1}\OperatorTok{.}\FunctionTok{swap32}\NormalTok{()}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 04 03 02 01 08 07 06 05\textgreater{}}

\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x1}\OperatorTok{,} \BaseNTok{0x2}\OperatorTok{,} \BaseNTok{0x3}\NormalTok{])}\OperatorTok{;}

\NormalTok{buf2}\OperatorTok{.}\FunctionTok{swap32}\NormalTok{()}\OperatorTok{;}
\CommentTok{// Throws ERR\_INVALID\_BUFFER\_SIZE.}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.swap64()}}{buf.swap64()}}\label{buf.swap64}

\begin{itemize}
\tightlist
\item
  Returns: \{Buffer\} A reference to \texttt{buf}.
\end{itemize}

Interprets \texttt{buf} as an array of 64-bit numbers and swaps byte
order \emph{in-place}. Throws
\href{errors.md\#err_invalid_buffer_size}{\texttt{ERR\_INVALID\_BUFFER\_SIZE}}
if \hyperref[buflength]{\texttt{buf.length}} is not a multiple of 8.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x1}\OperatorTok{,} \BaseNTok{0x2}\OperatorTok{,} \BaseNTok{0x3}\OperatorTok{,} \BaseNTok{0x4}\OperatorTok{,} \BaseNTok{0x5}\OperatorTok{,} \BaseNTok{0x6}\OperatorTok{,} \BaseNTok{0x7}\OperatorTok{,} \BaseNTok{0x8}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 01 02 03 04 05 06 07 08\textgreater{}}

\NormalTok{buf1}\OperatorTok{.}\FunctionTok{swap64}\NormalTok{()}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 08 07 06 05 04 03 02 01\textgreater{}}

\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x1}\OperatorTok{,} \BaseNTok{0x2}\OperatorTok{,} \BaseNTok{0x3}\NormalTok{])}\OperatorTok{;}

\NormalTok{buf2}\OperatorTok{.}\FunctionTok{swap64}\NormalTok{()}\OperatorTok{;}
\CommentTok{// Throws ERR\_INVALID\_BUFFER\_SIZE.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x1}\OperatorTok{,} \BaseNTok{0x2}\OperatorTok{,} \BaseNTok{0x3}\OperatorTok{,} \BaseNTok{0x4}\OperatorTok{,} \BaseNTok{0x5}\OperatorTok{,} \BaseNTok{0x6}\OperatorTok{,} \BaseNTok{0x7}\OperatorTok{,} \BaseNTok{0x8}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 01 02 03 04 05 06 07 08\textgreater{}}

\NormalTok{buf1}\OperatorTok{.}\FunctionTok{swap64}\NormalTok{()}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 08 07 06 05 04 03 02 01\textgreater{}}

\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x1}\OperatorTok{,} \BaseNTok{0x2}\OperatorTok{,} \BaseNTok{0x3}\NormalTok{])}\OperatorTok{;}

\NormalTok{buf2}\OperatorTok{.}\FunctionTok{swap64}\NormalTok{()}\OperatorTok{;}
\CommentTok{// Throws ERR\_INVALID\_BUFFER\_SIZE.}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.toJSON()}}{buf.toJSON()}}\label{buf.tojson}

\begin{itemize}
\tightlist
\item
  Returns: \{Object\}
\end{itemize}

Returns a JSON representation of \texttt{buf}.
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify}{\texttt{JSON.stringify()}}
implicitly calls this function when stringifying a \texttt{Buffer}
instance.

\texttt{Buffer.from()} accepts objects in the format returned from this
method. In particular, \texttt{Buffer.from(buf.toJSON())} works like
\texttt{Buffer.from(buf)}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x1}\OperatorTok{,} \BaseNTok{0x2}\OperatorTok{,} \BaseNTok{0x3}\OperatorTok{,} \BaseNTok{0x4}\OperatorTok{,} \BaseNTok{0x5}\NormalTok{])}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ json }\OperatorTok{=} \BuiltInTok{JSON}\OperatorTok{.}\FunctionTok{stringify}\NormalTok{(buf)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(json)}\OperatorTok{;}
\CommentTok{// Prints: \{"type":"Buffer","data":[1,2,3,4,5]\}}

\KeywordTok{const}\NormalTok{ copy }\OperatorTok{=} \BuiltInTok{JSON}\OperatorTok{.}\FunctionTok{parse}\NormalTok{(json}\OperatorTok{,}\NormalTok{ (key}\OperatorTok{,}\NormalTok{ value) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \ControlFlowTok{return}\NormalTok{ value }\OperatorTok{\&\&}\NormalTok{ value}\OperatorTok{.}\AttributeTok{type} \OperatorTok{===} \StringTok{\textquotesingle{}Buffer\textquotesingle{}} \OperatorTok{?}
    \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(value) }\OperatorTok{:}
\NormalTok{    value}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(copy)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 01 02 03 04 05\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\BaseNTok{0x1}\OperatorTok{,} \BaseNTok{0x2}\OperatorTok{,} \BaseNTok{0x3}\OperatorTok{,} \BaseNTok{0x4}\OperatorTok{,} \BaseNTok{0x5}\NormalTok{])}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ json }\OperatorTok{=} \BuiltInTok{JSON}\OperatorTok{.}\FunctionTok{stringify}\NormalTok{(buf)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(json)}\OperatorTok{;}
\CommentTok{// Prints: \{"type":"Buffer","data":[1,2,3,4,5]\}}

\KeywordTok{const}\NormalTok{ copy }\OperatorTok{=} \BuiltInTok{JSON}\OperatorTok{.}\FunctionTok{parse}\NormalTok{(json}\OperatorTok{,}\NormalTok{ (key}\OperatorTok{,}\NormalTok{ value) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \ControlFlowTok{return}\NormalTok{ value }\OperatorTok{\&\&}\NormalTok{ value}\OperatorTok{.}\AttributeTok{type} \OperatorTok{===} \StringTok{\textquotesingle{}Buffer\textquotesingle{}} \OperatorTok{?}
    \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(value) }\OperatorTok{:}
\NormalTok{    value}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(copy)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 01 02 03 04 05\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.toString({[}encoding{[},\ start{[},\ end{]}{]}{]})}}{buf.toString({[}encoding{[}, start{[}, end{]}{]}{]})}}\label{buf.tostringencoding-start-end}

\begin{itemize}
\tightlist
\item
  \texttt{encoding} \{string\} The character encoding to use.
  \textbf{Default:} \texttt{\textquotesingle{}utf8\textquotesingle{}}.
\item
  \texttt{start} \{integer\} The byte offset to start decoding at.
  \textbf{Default:} \texttt{0}.
\item
  \texttt{end} \{integer\} The byte offset to stop decoding at (not
  inclusive). \textbf{Default:}
  \hyperref[buflength]{\texttt{buf.length}}.
\item
  Returns: \{string\}
\end{itemize}

Decodes \texttt{buf} to a string according to the specified character
encoding in \texttt{encoding}. \texttt{start} and \texttt{end} may be
passed to decode only a subset of \texttt{buf}.

If \texttt{encoding} is
\texttt{\textquotesingle{}utf8\textquotesingle{}} and a byte sequence in
the input is not valid UTF-8, then each invalid byte is replaced with
the replacement character \texttt{U+FFFD}.

The maximum length of a string instance (in UTF-16 code units) is
available as
\hyperref[bufferconstantsmax_string_length]{\texttt{buffer.constants.MAX\_STRING\_LENGTH}}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{26}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{26}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) \{}
  \CommentTok{// 97 is the decimal ASCII value for \textquotesingle{}a\textquotesingle{}.}
\NormalTok{  buf1[i] }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \DecValTok{97}\OperatorTok{;}
\NormalTok{\}}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: abcdefghijklmnopqrstuvwxyz}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{5}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: abcde}

\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}tést\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 74c3a97374}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{3}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: té}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\KeywordTok{undefined}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{3}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: té}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf1 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{26}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{26}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) \{}
  \CommentTok{// 97 is the decimal ASCII value for \textquotesingle{}a\textquotesingle{}.}
\NormalTok{  buf1[i] }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \DecValTok{97}\OperatorTok{;}
\NormalTok{\}}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: abcdefghijklmnopqrstuvwxyz}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf1}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{5}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: abcde}

\KeywordTok{const}\NormalTok{ buf2 }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}tést\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: 74c3a97374}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{3}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: té}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf2}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\KeywordTok{undefined}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{3}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: té}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.values()}}{buf.values()}}\label{buf.values}

\begin{itemize}
\tightlist
\item
  Returns: \{Iterator\}
\end{itemize}

Creates and returns an
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols}{iterator}
for \texttt{buf} values (bytes). This function is called automatically
when a \texttt{Buffer} is used in a \texttt{for..of} statement.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ value }\KeywordTok{of}\NormalTok{ buf}\OperatorTok{.}\FunctionTok{values}\NormalTok{()) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(value)}\OperatorTok{;}
\NormalTok{\}}
\CommentTok{// Prints:}
\CommentTok{//   98}
\CommentTok{//   117}
\CommentTok{//   102}
\CommentTok{//   102}
\CommentTok{//   101}
\CommentTok{//   114}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ value }\KeywordTok{of}\NormalTok{ buf) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(value)}\OperatorTok{;}
\NormalTok{\}}
\CommentTok{// Prints:}
\CommentTok{//   98}
\CommentTok{//   117}
\CommentTok{//   102}
\CommentTok{//   102}
\CommentTok{//   101}
\CommentTok{//   114}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ value }\KeywordTok{of}\NormalTok{ buf}\OperatorTok{.}\FunctionTok{values}\NormalTok{()) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(value)}\OperatorTok{;}
\NormalTok{\}}
\CommentTok{// Prints:}
\CommentTok{//   98}
\CommentTok{//   117}
\CommentTok{//   102}
\CommentTok{//   102}
\CommentTok{//   101}
\CommentTok{//   114}

\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ value }\KeywordTok{of}\NormalTok{ buf) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(value)}\OperatorTok{;}
\NormalTok{\}}
\CommentTok{// Prints:}
\CommentTok{//   98}
\CommentTok{//   117}
\CommentTok{//   102}
\CommentTok{//   102}
\CommentTok{//   101}
\CommentTok{//   114}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.write(string{[},\ offset{[},\ length{]}{]}{[},\ encoding{]})}}{buf.write(string{[}, offset{[}, length{]}{]}{[}, encoding{]})}}\label{buf.writestring-offset-length-encoding}

\begin{itemize}
\tightlist
\item
  \texttt{string} \{string\} String to write to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write \texttt{string}. \textbf{Default:} \texttt{0}.
\item
  \texttt{length} \{integer\} Maximum number of bytes to write (written
  bytes will not exceed \texttt{buf.length\ -\ offset}).
  \textbf{Default:} \texttt{buf.length\ -\ offset}.
\item
  \texttt{encoding} \{string\} The character encoding of
  \texttt{string}. \textbf{Default:}
  \texttt{\textquotesingle{}utf8\textquotesingle{}}.
\item
  Returns: \{integer\} Number of bytes written.
\end{itemize}

Writes \texttt{string} to \texttt{buf} at \texttt{offset} according to
the character encoding in \texttt{encoding}. The \texttt{length}
parameter is the number of bytes to write. If \texttt{buf} did not
contain enough space to fit the entire string, only part of
\texttt{string} will be written. However, partially encoded characters
will not be written.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{256}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ len }\OperatorTok{=}\NormalTok{ buf}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u00bd}\StringTok{ + }\SpecialCharTok{\textbackslash{}u00bc}\StringTok{ = }\SpecialCharTok{\textbackslash{}u00be}\StringTok{\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}}\SpecialCharTok{$\{}\NormalTok{len}\SpecialCharTok{\}}\VerbatimStringTok{ bytes: }\SpecialCharTok{$\{}\NormalTok{buf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ len)}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 12 bytes: ½ + ¼ = ¾}

\KeywordTok{const}\NormalTok{ buffer }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ length }\OperatorTok{=}\NormalTok{ buffer}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}abcd\textquotesingle{}}\OperatorTok{,} \DecValTok{8}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}}\SpecialCharTok{$\{}\NormalTok{length}\SpecialCharTok{\}}\VerbatimStringTok{ bytes: }\SpecialCharTok{$\{}\NormalTok{buffer}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{10}\NormalTok{)}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 2 bytes : ab}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{256}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ len }\OperatorTok{=}\NormalTok{ buf}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}u00bd}\StringTok{ + }\SpecialCharTok{\textbackslash{}u00bc}\StringTok{ = }\SpecialCharTok{\textbackslash{}u00be}\StringTok{\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}}\SpecialCharTok{$\{}\NormalTok{len}\SpecialCharTok{\}}\VerbatimStringTok{ bytes: }\SpecialCharTok{$\{}\NormalTok{buf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ len)}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 12 bytes: ½ + ¼ = ¾}

\KeywordTok{const}\NormalTok{ buffer }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ length }\OperatorTok{=}\NormalTok{ buffer}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}abcd\textquotesingle{}}\OperatorTok{,} \DecValTok{8}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}}\SpecialCharTok{$\{}\NormalTok{length}\SpecialCharTok{\}}\VerbatimStringTok{ bytes: }\SpecialCharTok{$\{}\NormalTok{buffer}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\OperatorTok{,} \DecValTok{8}\OperatorTok{,} \DecValTok{10}\NormalTok{)}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 2 bytes : ab}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeBigInt64BE(value{[},\ offset{]})}}{buf.writeBigInt64BE(value{[}, offset{]})}}\label{buf.writebigint64bevalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{bigint\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy:
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 8}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as big-endian.

\texttt{value} is interpreted and written as a two's complement signed
integer.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{8}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeBigInt64BE}\NormalTok{(}\BaseNTok{0x0102030405060708}\NormalTok{n}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 01 02 03 04 05 06 07 08\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{8}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeBigInt64BE}\NormalTok{(}\BaseNTok{0x0102030405060708}\NormalTok{n}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 01 02 03 04 05 06 07 08\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeBigInt64LE(value{[},\ offset{]})}}{buf.writeBigInt64LE(value{[}, offset{]})}}\label{buf.writebigint64levalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{bigint\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy:
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 8}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as little-endian.

\texttt{value} is interpreted and written as a two's complement signed
integer.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{8}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeBigInt64LE}\NormalTok{(}\BaseNTok{0x0102030405060708}\NormalTok{n}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 08 07 06 05 04 03 02 01\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{8}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeBigInt64LE}\NormalTok{(}\BaseNTok{0x0102030405060708}\NormalTok{n}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 08 07 06 05 04 03 02 01\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeBigUInt64BE(value{[},\ offset{]})}}{buf.writeBigUInt64BE(value{[}, offset{]})}}\label{buf.writebiguint64bevalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{bigint\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy:
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 8}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as big-endian.

This function is also available under the \texttt{writeBigUint64BE}
alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{8}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeBigUInt64BE}\NormalTok{(}\BaseNTok{0xdecafafecacefade}\NormalTok{n}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer de ca fa fe ca ce fa de\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{8}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeBigUInt64BE}\NormalTok{(}\BaseNTok{0xdecafafecacefade}\NormalTok{n}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer de ca fa fe ca ce fa de\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeBigUInt64LE(value{[},\ offset{]})}}{buf.writeBigUInt64LE(value{[}, offset{]})}}\label{buf.writebiguint64levalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{bigint\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy:
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 8}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as little-endian

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{8}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeBigUInt64LE}\NormalTok{(}\BaseNTok{0xdecafafecacefade}\NormalTok{n}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer de fa ce ca fe fa ca de\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{8}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeBigUInt64LE}\NormalTok{(}\BaseNTok{0xdecafafecacefade}\NormalTok{n}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer de fa ce ca fe fa ca de\textgreater{}}
\end{Highlighting}
\end{Shaded}

This function is also available under the \texttt{writeBigUint64LE}
alias.

\subsubsection{\texorpdfstring{\texttt{buf.writeDoubleBE(value{[},\ offset{]})}}{buf.writeDoubleBE(value{[}, offset{]})}}\label{buf.writedoublebevalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{number\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 8}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as big-endian. The \texttt{value} must be a JavaScript number. Behavior
is undefined when \texttt{value} is anything other than a JavaScript
number.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{8}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeDoubleBE}\NormalTok{(}\FloatTok{123.456}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 40 5e dd 2f 1a 9f be 77\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{8}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeDoubleBE}\NormalTok{(}\FloatTok{123.456}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 40 5e dd 2f 1a 9f be 77\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeDoubleLE(value{[},\ offset{]})}}{buf.writeDoubleLE(value{[}, offset{]})}}\label{buf.writedoublelevalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{number\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 8}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as little-endian. The \texttt{value} must be a JavaScript number.
Behavior is undefined when \texttt{value} is anything other than a
JavaScript number.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{8}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeDoubleLE}\NormalTok{(}\FloatTok{123.456}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 77 be 9f 1a 2f dd 5e 40\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{8}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeDoubleLE}\NormalTok{(}\FloatTok{123.456}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 77 be 9f 1a 2f dd 5e 40\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeFloatBE(value{[},\ offset{]})}}{buf.writeFloatBE(value{[}, offset{]})}}\label{buf.writefloatbevalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{number\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 4}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as big-endian. Behavior is undefined when \texttt{value} is anything
other than a JavaScript number.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeFloatBE}\NormalTok{(}\BaseNTok{0xcafebabe}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 4f 4a fe bb\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeFloatBE}\NormalTok{(}\BaseNTok{0xcafebabe}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 4f 4a fe bb\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeFloatLE(value{[},\ offset{]})}}{buf.writeFloatLE(value{[}, offset{]})}}\label{buf.writefloatlevalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{number\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 4}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as little-endian. Behavior is undefined when \texttt{value} is anything
other than a JavaScript number.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeFloatLE}\NormalTok{(}\BaseNTok{0xcafebabe}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer bb fe 4a 4f\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeFloatLE}\NormalTok{(}\BaseNTok{0xcafebabe}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer bb fe 4a 4f\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeInt8(value{[},\ offset{]})}}{buf.writeInt8(value{[}, offset{]})}}\label{buf.writeint8value-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{integer\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 1}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}.
\texttt{value} must be a valid signed 8-bit integer. Behavior is
undefined when \texttt{value} is anything other than a signed 8-bit
integer.

\texttt{value} is interpreted and written as a two's complement signed
integer.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeInt8}\NormalTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}
\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeInt8}\NormalTok{(}\OperatorTok{{-}}\DecValTok{2}\OperatorTok{,} \DecValTok{1}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 02 fe\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeInt8}\NormalTok{(}\DecValTok{2}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}
\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeInt8}\NormalTok{(}\OperatorTok{{-}}\DecValTok{2}\OperatorTok{,} \DecValTok{1}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 02 fe\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeInt16BE(value{[},\ offset{]})}}{buf.writeInt16BE(value{[}, offset{]})}}\label{buf.writeint16bevalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{integer\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 2}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as big-endian. The \texttt{value} must be a valid signed 16-bit integer.
Behavior is undefined when \texttt{value} is anything other than a
signed 16-bit integer.

The \texttt{value} is interpreted and written as a two's complement
signed integer.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeInt16BE}\NormalTok{(}\BaseNTok{0x0102}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 01 02\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeInt16BE}\NormalTok{(}\BaseNTok{0x0102}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 01 02\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeInt16LE(value{[},\ offset{]})}}{buf.writeInt16LE(value{[}, offset{]})}}\label{buf.writeint16levalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{integer\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 2}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as little-endian. The \texttt{value} must be a valid signed 16-bit
integer. Behavior is undefined when \texttt{value} is anything other
than a signed 16-bit integer.

The \texttt{value} is interpreted and written as a two's complement
signed integer.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeInt16LE}\NormalTok{(}\BaseNTok{0x0304}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 04 03\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeInt16LE}\NormalTok{(}\BaseNTok{0x0304}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 04 03\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeInt32BE(value{[},\ offset{]})}}{buf.writeInt32BE(value{[}, offset{]})}}\label{buf.writeint32bevalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{integer\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 4}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as big-endian. The \texttt{value} must be a valid signed 32-bit integer.
Behavior is undefined when \texttt{value} is anything other than a
signed 32-bit integer.

The \texttt{value} is interpreted and written as a two's complement
signed integer.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeInt32BE}\NormalTok{(}\BaseNTok{0x01020304}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 01 02 03 04\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeInt32BE}\NormalTok{(}\BaseNTok{0x01020304}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 01 02 03 04\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeInt32LE(value{[},\ offset{]})}}{buf.writeInt32LE(value{[}, offset{]})}}\label{buf.writeint32levalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{integer\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 4}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as little-endian. The \texttt{value} must be a valid signed 32-bit
integer. Behavior is undefined when \texttt{value} is anything other
than a signed 32-bit integer.

The \texttt{value} is interpreted and written as a two's complement
signed integer.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeInt32LE}\NormalTok{(}\BaseNTok{0x05060708}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 08 07 06 05\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeInt32LE}\NormalTok{(}\BaseNTok{0x05060708}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 08 07 06 05\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeIntBE(value,\ offset,\ byteLength)}}{buf.writeIntBE(value, offset, byteLength)}}\label{buf.writeintbevalue-offset-bytelength}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{integer\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ byteLength}.
\item
  \texttt{byteLength} \{integer\} Number of bytes to write. Must satisfy
  \texttt{0\ \textless{}\ byteLength\ \textless{}=\ 6}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{byteLength} bytes of \texttt{value} to \texttt{buf} at
the specified \texttt{offset} as big-endian. Supports up to 48 bits of
accuracy. Behavior is undefined when \texttt{value} is anything other
than a signed integer.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{6}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeIntBE}\NormalTok{(}\BaseNTok{0x1234567890ab}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 12 34 56 78 90 ab\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{6}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeIntBE}\NormalTok{(}\BaseNTok{0x1234567890ab}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 12 34 56 78 90 ab\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeIntLE(value,\ offset,\ byteLength)}}{buf.writeIntLE(value, offset, byteLength)}}\label{buf.writeintlevalue-offset-bytelength}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{integer\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ byteLength}.
\item
  \texttt{byteLength} \{integer\} Number of bytes to write. Must satisfy
  \texttt{0\ \textless{}\ byteLength\ \textless{}=\ 6}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{byteLength} bytes of \texttt{value} to \texttt{buf} at
the specified \texttt{offset} as little-endian. Supports up to 48 bits
of accuracy. Behavior is undefined when \texttt{value} is anything other
than a signed integer.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{6}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeIntLE}\NormalTok{(}\BaseNTok{0x1234567890ab}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer ab 90 78 56 34 12\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{6}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeIntLE}\NormalTok{(}\BaseNTok{0x1234567890ab}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer ab 90 78 56 34 12\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeUInt8(value{[},\ offset{]})}}{buf.writeUInt8(value{[}, offset{]})}}\label{buf.writeuint8value-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{integer\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 1}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}.
\texttt{value} must be a valid unsigned 8-bit integer. Behavior is
undefined when \texttt{value} is anything other than an unsigned 8-bit
integer.

This function is also available under the \texttt{writeUint8} alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt8}\NormalTok{(}\BaseNTok{0x3}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}
\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt8}\NormalTok{(}\BaseNTok{0x4}\OperatorTok{,} \DecValTok{1}\NormalTok{)}\OperatorTok{;}
\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt8}\NormalTok{(}\BaseNTok{0x23}\OperatorTok{,} \DecValTok{2}\NormalTok{)}\OperatorTok{;}
\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt8}\NormalTok{(}\BaseNTok{0x42}\OperatorTok{,} \DecValTok{3}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 03 04 23 42\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt8}\NormalTok{(}\BaseNTok{0x3}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}
\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt8}\NormalTok{(}\BaseNTok{0x4}\OperatorTok{,} \DecValTok{1}\NormalTok{)}\OperatorTok{;}
\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt8}\NormalTok{(}\BaseNTok{0x23}\OperatorTok{,} \DecValTok{2}\NormalTok{)}\OperatorTok{;}
\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt8}\NormalTok{(}\BaseNTok{0x42}\OperatorTok{,} \DecValTok{3}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 03 04 23 42\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeUInt16BE(value{[},\ offset{]})}}{buf.writeUInt16BE(value{[}, offset{]})}}\label{buf.writeuint16bevalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{integer\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 2}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as big-endian. The \texttt{value} must be a valid unsigned 16-bit
integer. Behavior is undefined when \texttt{value} is anything other
than an unsigned 16-bit integer.

This function is also available under the \texttt{writeUint16BE} alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt16BE}\NormalTok{(}\BaseNTok{0xdead}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}
\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt16BE}\NormalTok{(}\BaseNTok{0xbeef}\OperatorTok{,} \DecValTok{2}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer de ad be ef\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt16BE}\NormalTok{(}\BaseNTok{0xdead}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}
\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt16BE}\NormalTok{(}\BaseNTok{0xbeef}\OperatorTok{,} \DecValTok{2}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer de ad be ef\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeUInt16LE(value{[},\ offset{]})}}{buf.writeUInt16LE(value{[}, offset{]})}}\label{buf.writeuint16levalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{integer\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 2}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as little-endian. The \texttt{value} must be a valid unsigned 16-bit
integer. Behavior is undefined when \texttt{value} is anything other
than an unsigned 16-bit integer.

This function is also available under the \texttt{writeUint16LE} alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt16LE}\NormalTok{(}\BaseNTok{0xdead}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}
\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt16LE}\NormalTok{(}\BaseNTok{0xbeef}\OperatorTok{,} \DecValTok{2}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer ad de ef be\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt16LE}\NormalTok{(}\BaseNTok{0xdead}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}
\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt16LE}\NormalTok{(}\BaseNTok{0xbeef}\OperatorTok{,} \DecValTok{2}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer ad de ef be\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeUInt32BE(value{[},\ offset{]})}}{buf.writeUInt32BE(value{[}, offset{]})}}\label{buf.writeuint32bevalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{integer\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 4}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as big-endian. The \texttt{value} must be a valid unsigned 32-bit
integer. Behavior is undefined when \texttt{value} is anything other
than an unsigned 32-bit integer.

This function is also available under the \texttt{writeUint32BE} alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt32BE}\NormalTok{(}\BaseNTok{0xfeedface}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer fe ed fa ce\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt32BE}\NormalTok{(}\BaseNTok{0xfeedface}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer fe ed fa ce\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeUInt32LE(value{[},\ offset{]})}}{buf.writeUInt32LE(value{[}, offset{]})}}\label{buf.writeuint32levalue-offset}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{integer\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ 4}.
  \textbf{Default:} \texttt{0}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{value} to \texttt{buf} at the specified \texttt{offset}
as little-endian. The \texttt{value} must be a valid unsigned 32-bit
integer. Behavior is undefined when \texttt{value} is anything other
than an unsigned 32-bit integer.

This function is also available under the \texttt{writeUint32LE} alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt32LE}\NormalTok{(}\BaseNTok{0xfeedface}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer ce fa ed fe\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{4}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUInt32LE}\NormalTok{(}\BaseNTok{0xfeedface}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer ce fa ed fe\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeUIntBE(value,\ offset,\ byteLength)}}{buf.writeUIntBE(value, offset, byteLength)}}\label{buf.writeuintbevalue-offset-bytelength}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{integer\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ byteLength}.
\item
  \texttt{byteLength} \{integer\} Number of bytes to write. Must satisfy
  \texttt{0\ \textless{}\ byteLength\ \textless{}=\ 6}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{byteLength} bytes of \texttt{value} to \texttt{buf} at
the specified \texttt{offset} as big-endian. Supports up to 48 bits of
accuracy. Behavior is undefined when \texttt{value} is anything other
than an unsigned integer.

This function is also available under the \texttt{writeUintBE} alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{6}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUIntBE}\NormalTok{(}\BaseNTok{0x1234567890ab}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 12 34 56 78 90 ab\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{6}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUIntBE}\NormalTok{(}\BaseNTok{0x1234567890ab}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer 12 34 56 78 90 ab\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{buf.writeUIntLE(value,\ offset,\ byteLength)}}{buf.writeUIntLE(value, offset, byteLength)}}\label{buf.writeuintlevalue-offset-bytelength}

\begin{itemize}
\tightlist
\item
  \texttt{value} \{integer\} Number to be written to \texttt{buf}.
\item
  \texttt{offset} \{integer\} Number of bytes to skip before starting to
  write. Must satisfy
  \texttt{0\ \textless{}=\ offset\ \textless{}=\ buf.length\ -\ byteLength}.
\item
  \texttt{byteLength} \{integer\} Number of bytes to write. Must satisfy
  \texttt{0\ \textless{}\ byteLength\ \textless{}=\ 6}.
\item
  Returns: \{integer\} \texttt{offset} plus the number of bytes written.
\end{itemize}

Writes \texttt{byteLength} bytes of \texttt{value} to \texttt{buf} at
the specified \texttt{offset} as little-endian. Supports up to 48 bits
of accuracy. Behavior is undefined when \texttt{value} is anything other
than an unsigned integer.

This function is also available under the \texttt{writeUintLE} alias.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{6}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUIntLE}\NormalTok{(}\BaseNTok{0x1234567890ab}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer ab 90 78 56 34 12\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\NormalTok{ \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{allocUnsafe}\NormalTok{(}\DecValTok{6}\NormalTok{)}\OperatorTok{;}

\NormalTok{buf}\OperatorTok{.}\FunctionTok{writeUIntLE}\NormalTok{(}\BaseNTok{0x1234567890ab}\OperatorTok{,} \DecValTok{0}\OperatorTok{,} \DecValTok{6}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(buf)}\OperatorTok{;}
\CommentTok{// Prints: \textless{}Buffer ab 90 78 56 34 12\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{new\ Buffer(array)}}{new Buffer(array)}}\label{new-bufferarray}

\begin{quote}
Stability: 0 - Deprecated: Use
\hyperref[static-method-bufferfromarray]{\texttt{Buffer.from(array)}}
instead.
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{array} \{integer{[}{]}\} An array of bytes to copy from.
\end{itemize}

See
\hyperref[static-method-bufferfromarray]{\texttt{Buffer.from(array)}}.

\subsubsection{\texorpdfstring{\texttt{new\ Buffer(arrayBuffer{[},\ byteOffset{[},\ length{]}{]})}}{new Buffer(arrayBuffer{[}, byteOffset{[}, length{]}{]})}}\label{new-bufferarraybuffer-byteoffset-length}

\begin{quote}
Stability: 0 - Deprecated: Use
\hyperref[static-method-bufferfromarraybuffer-byteoffset-length]{\texttt{Buffer.from(arrayBuffer{[},\ byteOffset{[},\ length{]}{]})}}
instead.
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{arrayBuffer} \{ArrayBuffer\textbar SharedArrayBuffer\} An
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}{\texttt{ArrayBuffer}},
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer}{\texttt{SharedArrayBuffer}}
  or the \texttt{.buffer} property of a
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray}{\texttt{TypedArray}}.
\item
  \texttt{byteOffset} \{integer\} Index of first byte to expose.
  \textbf{Default:} \texttt{0}.
\item
  \texttt{length} \{integer\} Number of bytes to expose.
  \textbf{Default:} \texttt{arrayBuffer.byteLength\ -\ byteOffset}.
\end{itemize}

See
\hyperref[static-method-bufferfromarraybuffer-byteoffset-length]{\texttt{Buffer.from(arrayBuffer{[},\ byteOffset{[},\ length{]}{]})}}.

\subsubsection{\texorpdfstring{\texttt{new\ Buffer(buffer)}}{new Buffer(buffer)}}\label{new-bufferbuffer}

\begin{quote}
Stability: 0 - Deprecated: Use
\hyperref[static-method-bufferfrombuffer]{\texttt{Buffer.from(buffer)}}
instead.
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{buffer} \{Buffer\textbar Uint8Array\} An existing
  \texttt{Buffer} or
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array}{\texttt{Uint8Array}}
  from which to copy data.
\end{itemize}

See
\hyperref[static-method-bufferfrombuffer]{\texttt{Buffer.from(buffer)}}.

\subsubsection{\texorpdfstring{\texttt{new\ Buffer(size)}}{new Buffer(size)}}\label{new-buffersize}

\begin{quote}
Stability: 0 - Deprecated: Use
\hyperref[static-method-bufferallocsize-fill-encoding]{\texttt{Buffer.alloc()}}
instead (also see
\hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe()}}).
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{size} \{integer\} The desired length of the new
  \texttt{Buffer}.
\end{itemize}

See
\hyperref[static-method-bufferallocsize-fill-encoding]{\texttt{Buffer.alloc()}}
and
\hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe()}}.
This variant of the constructor is equivalent to
\hyperref[static-method-bufferallocsize-fill-encoding]{\texttt{Buffer.alloc()}}.

\subsubsection{\texorpdfstring{\texttt{new\ Buffer(string{[},\ encoding{]})}}{new Buffer(string{[}, encoding{]})}}\label{new-bufferstring-encoding}

\begin{quote}
Stability: 0 - Deprecated: Use
\hyperref[static-method-bufferfromstring-encoding]{\texttt{Buffer.from(string{[},\ encoding{]})}}
instead.
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{string} \{string\} String to encode.
\item
  \texttt{encoding} \{string\} The encoding of \texttt{string}.
  \textbf{Default:} \texttt{\textquotesingle{}utf8\textquotesingle{}}.
\end{itemize}

See
\hyperref[static-method-bufferfromstring-encoding]{\texttt{Buffer.from(string{[},\ encoding{]})}}.

\subsection{\texorpdfstring{Class:
\texttt{File}}{Class: File}}\label{class-file}

\begin{itemize}
\tightlist
\item
  Extends: \{Blob\}
\end{itemize}

A
\href{https://developer.mozilla.org/en-US/docs/Web/API/File}{\texttt{File}}
provides information about files.

\subsubsection{\texorpdfstring{\texttt{new\ buffer.File(sources,\ fileName{[},\ options{]})}}{new buffer.File(sources, fileName{[}, options{]})}}\label{new-buffer.filesources-filename-options}

\begin{itemize}
\tightlist
\item
  \texttt{sources}
  \{string{[}{]}\textbar ArrayBuffer{[}{]}\textbar TypedArray{[}{]}\textbar DataView{[}{]}\textbar Blob{[}{]}\textbar File{[}{]}\}
  An array of string, \{ArrayBuffer\}, \{TypedArray\}, \{DataView\},
  \{File\}, or \{Blob\} objects, or any mix of such objects, that will
  be stored within the \texttt{File}.
\item
  \texttt{fileName} \{string\} The name of the file.
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{endings} \{string\} One of either
    \texttt{\textquotesingle{}transparent\textquotesingle{}} or
    \texttt{\textquotesingle{}native\textquotesingle{}}. When set to
    \texttt{\textquotesingle{}native\textquotesingle{}}, line endings in
    string source parts will be converted to the platform native
    line-ending as specified by
    \texttt{require(\textquotesingle{}node:os\textquotesingle{}).EOL}.
  \item
    \texttt{type} \{string\} The File content-type.
  \item
    \texttt{lastModified} \{number\} The last modified date of the file.
    \textbf{Default:} \texttt{Date.now()}.
  \end{itemize}
\end{itemize}

\subsubsection{\texorpdfstring{\texttt{file.name}}{file.name}}\label{file.name}

\begin{itemize}
\tightlist
\item
  Type: \{string\}
\end{itemize}

The name of the \texttt{File}.

\subsubsection{\texorpdfstring{\texttt{file.lastModified}}{file.lastModified}}\label{file.lastmodified}

\begin{itemize}
\tightlist
\item
  Type: \{number\}
\end{itemize}

The last modified date of the \texttt{File}.

\subsection{\texorpdfstring{\texttt{node:buffer} module
APIs}{node:buffer module APIs}}\label{nodebuffer-module-apis}

While, the \texttt{Buffer} object is available as a global, there are
additional \texttt{Buffer}-related APIs that are available only via the
\texttt{node:buffer} module accessed using
\texttt{require(\textquotesingle{}node:buffer\textquotesingle{})}.

\subsubsection{\texorpdfstring{\texttt{buffer.atob(data)}}{buffer.atob(data)}}\label{buffer.atobdata}

\begin{quote}
Stability: 3 - Legacy. Use
\texttt{Buffer.from(data,\ \textquotesingle{}base64\textquotesingle{})}
instead.
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{data} \{any\} The Base64-encoded input string.
\end{itemize}

Decodes a string of Base64-encoded data into bytes, and encodes those
bytes into a string using Latin-1 (ISO-8859-1).

The \texttt{data} may be any JavaScript-value that can be coerced into a
string.

\textbf{This function is only provided for compatibility with legacy web
platform APIs and should never be used in new code, because they use
strings to represent binary data and predate the introduction of typed
arrays in JavaScript. For code running using Node.js APIs, converting
between base64-encoded strings and binary data should be performed using
\texttt{Buffer.from(str,\ \textquotesingle{}base64\textquotesingle{})}
and \texttt{buf.toString(\textquotesingle{}base64\textquotesingle{})}.}

\subsubsection{\texorpdfstring{\texttt{buffer.btoa(data)}}{buffer.btoa(data)}}\label{buffer.btoadata}

\begin{quote}
Stability: 3 - Legacy. Use
\texttt{buf.toString(\textquotesingle{}base64\textquotesingle{})}
instead.
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{data} \{any\} An ASCII (Latin1) string.
\end{itemize}

Decodes a string into bytes using Latin-1 (ISO-8859), and encodes those
bytes into a string using Base64.

The \texttt{data} may be any JavaScript-value that can be coerced into a
string.

\textbf{This function is only provided for compatibility with legacy web
platform APIs and should never be used in new code, because they use
strings to represent binary data and predate the introduction of typed
arrays in JavaScript. For code running using Node.js APIs, converting
between base64-encoded strings and binary data should be performed using
\texttt{Buffer.from(str,\ \textquotesingle{}base64\textquotesingle{})}
and \texttt{buf.toString(\textquotesingle{}base64\textquotesingle{})}.}

\subsubsection{\texorpdfstring{\texttt{buffer.isAscii(input)}}{buffer.isAscii(input)}}\label{buffer.isasciiinput}

\begin{itemize}
\tightlist
\item
  input \{Buffer \textbar{} ArrayBuffer \textbar{} TypedArray\} The
  input to validate.
\item
  Returns: \{boolean\}
\end{itemize}

This function returns \texttt{true} if \texttt{input} contains only
valid ASCII-encoded data, including the case in which \texttt{input} is
empty.

Throws if the \texttt{input} is a detached array buffer.

\subsubsection{\texorpdfstring{\texttt{buffer.isUtf8(input)}}{buffer.isUtf8(input)}}\label{buffer.isutf8input}

\begin{itemize}
\tightlist
\item
  input \{Buffer \textbar{} ArrayBuffer \textbar{} TypedArray\} The
  input to validate.
\item
  Returns: \{boolean\}
\end{itemize}

This function returns \texttt{true} if \texttt{input} contains only
valid UTF-8-encoded data, including the case in which \texttt{input} is
empty.

Throws if the \texttt{input} is a detached array buffer.

\subsubsection{\texorpdfstring{\texttt{buffer.INSPECT\_MAX\_BYTES}}{buffer.INSPECT\_MAX\_BYTES}}\label{buffer.inspect_max_bytes}

\begin{itemize}
\tightlist
\item
  \{integer\} \textbf{Default:} \texttt{50}
\end{itemize}

Returns the maximum number of bytes that will be returned when
\texttt{buf.inspect()} is called. This can be overridden by user
modules. See
\href{util.md\#utilinspectobject-options}{\texttt{util.inspect()}} for
more details on \texttt{buf.inspect()} behavior.

\subsubsection{\texorpdfstring{\texttt{buffer.kMaxLength}}{buffer.kMaxLength}}\label{buffer.kmaxlength}

\begin{itemize}
\tightlist
\item
  \{integer\} The largest size allowed for a single \texttt{Buffer}
  instance.
\end{itemize}

An alias for
\hyperref[bufferconstantsmax_length]{\texttt{buffer.constants.MAX\_LENGTH}}.

\subsubsection{\texorpdfstring{\texttt{buffer.kStringMaxLength}}{buffer.kStringMaxLength}}\label{buffer.kstringmaxlength}

\begin{itemize}
\tightlist
\item
  \{integer\} The largest length allowed for a single \texttt{string}
  instance.
\end{itemize}

An alias for
\hyperref[bufferconstantsmax_string_length]{\texttt{buffer.constants.MAX\_STRING\_LENGTH}}.

\subsubsection{\texorpdfstring{\texttt{buffer.resolveObjectURL(id)}}{buffer.resolveObjectURL(id)}}\label{buffer.resolveobjecturlid}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{id} \{string\} A \texttt{\textquotesingle{}blob:nodedata:...}
  URL string returned by a prior call to \texttt{URL.createObjectURL()}.
\item
  Returns: \{Blob\}
\end{itemize}

Resolves a
\texttt{\textquotesingle{}blob:nodedata:...\textquotesingle{}} an
associated \{Blob\} object registered using a prior call to
\texttt{URL.createObjectURL()}.

\subsubsection{\texorpdfstring{\texttt{buffer.transcode(source,\ fromEnc,\ toEnc)}}{buffer.transcode(source, fromEnc, toEnc)}}\label{buffer.transcodesource-fromenc-toenc}

\begin{itemize}
\tightlist
\item
  \texttt{source} \{Buffer\textbar Uint8Array\} A \texttt{Buffer} or
  \texttt{Uint8Array} instance.
\item
  \texttt{fromEnc} \{string\} The current encoding.
\item
  \texttt{toEnc} \{string\} To target encoding.
\item
  Returns: \{Buffer\}
\end{itemize}

Re-encodes the given \texttt{Buffer} or \texttt{Uint8Array} instance
from one character encoding to another. Returns a new \texttt{Buffer}
instance.

Throws if the \texttt{fromEnc} or \texttt{toEnc} specify invalid
character encodings or if conversion from \texttt{fromEnc} to
\texttt{toEnc} is not permitted.

Encodings supported by \texttt{buffer.transcode()} are:
\texttt{\textquotesingle{}ascii\textquotesingle{}},
\texttt{\textquotesingle{}utf8\textquotesingle{}},
\texttt{\textquotesingle{}utf16le\textquotesingle{}},
\texttt{\textquotesingle{}ucs2\textquotesingle{}},
\texttt{\textquotesingle{}latin1\textquotesingle{}}, and
\texttt{\textquotesingle{}binary\textquotesingle{}}.

The transcoding process will use substitution characters if a given byte
sequence cannot be adequately represented in the target encoding. For
instance:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ }\BuiltInTok{Buffer}\OperatorTok{,}\NormalTok{ transcode \} }\ImportTok{from} \StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ newBuf }\OperatorTok{=} \FunctionTok{transcode}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}€\textquotesingle{}}\NormalTok{)}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}ascii\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(newBuf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}ascii\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textquotesingle{}?\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ }\BuiltInTok{Buffer}\OperatorTok{,}\NormalTok{ transcode \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:buffer\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ newBuf }\OperatorTok{=} \FunctionTok{transcode}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\StringTok{\textquotesingle{}€\textquotesingle{}}\NormalTok{)}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}ascii\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(newBuf}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}ascii\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Prints: \textquotesingle{}?\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Because the Euro (\texttt{€}) sign is not representable in US-ASCII, it
is replaced with \texttt{?} in the transcoded \texttt{Buffer}.

\subsubsection{\texorpdfstring{Class:
\texttt{SlowBuffer}}{Class: SlowBuffer}}\label{class-slowbuffer}

\begin{quote}
Stability: 0 - Deprecated: Use
\hyperref[static-method-bufferallocunsafeslowsize]{\texttt{Buffer.allocUnsafeSlow()}}
instead.
\end{quote}

See
\hyperref[static-method-bufferallocunsafeslowsize]{\texttt{Buffer.allocUnsafeSlow()}}.
This was never a class in the sense that the constructor always returned
a \texttt{Buffer} instance, rather than a \texttt{SlowBuffer} instance.

\paragraph{\texorpdfstring{\texttt{new\ SlowBuffer(size)}}{new SlowBuffer(size)}}\label{new-slowbuffersize}

\begin{quote}
Stability: 0 - Deprecated: Use
\hyperref[static-method-bufferallocunsafeslowsize]{\texttt{Buffer.allocUnsafeSlow()}}
instead.
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{size} \{integer\} The desired length of the new
  \texttt{SlowBuffer}.
\end{itemize}

See
\hyperref[static-method-bufferallocunsafeslowsize]{\texttt{Buffer.allocUnsafeSlow()}}.

\subsubsection{Buffer constants}\label{buffer-constants}

\paragraph{\texorpdfstring{\texttt{buffer.constants.MAX\_LENGTH}}{buffer.constants.MAX\_LENGTH}}\label{buffer.constants.max_length}

\begin{itemize}
\tightlist
\item
  \{integer\} The largest size allowed for a single \texttt{Buffer}
  instance.
\end{itemize}

On 32-bit architectures, this value currently is 230 - 1 (about 1 GiB).

On 64-bit architectures, this value currently is 232 (about 4 GiB).

It reflects
\href{https://v8.github.io/api/head/classv8_1_1TypedArray.html\#a54a48f4373da0850663c4393d843b9b0}{\texttt{v8::TypedArray::kMaxLength}}
under the hood.

This value is also available as
\hyperref[bufferkmaxlength]{\texttt{buffer.kMaxLength}}.

\paragraph{\texorpdfstring{\texttt{buffer.constants.MAX\_STRING\_LENGTH}}{buffer.constants.MAX\_STRING\_LENGTH}}\label{buffer.constants.max_string_length}

\begin{itemize}
\tightlist
\item
  \{integer\} The largest length allowed for a single \texttt{string}
  instance.
\end{itemize}

Represents the largest \texttt{length} that a \texttt{string} primitive
can have, counted in UTF-16 code units.

This value may depend on the JS engine that is being used.

\subsection{\texorpdfstring{\texttt{Buffer.from()},
\texttt{Buffer.alloc()}, and
\texttt{Buffer.allocUnsafe()}}{Buffer.from(), Buffer.alloc(), and Buffer.allocUnsafe()}}\label{buffer.from-buffer.alloc-and-buffer.allocunsafe}

In versions of Node.js prior to 6.0.0, \texttt{Buffer} instances were
created using the \texttt{Buffer} constructor function, which allocates
the returned \texttt{Buffer} differently based on what arguments are
provided:

\begin{itemize}
\tightlist
\item
  Passing a number as the first argument to \texttt{Buffer()}
  (e.g.~\texttt{new\ Buffer(10)}) allocates a new \texttt{Buffer} object
  of the specified size. Prior to Node.js 8.0.0, the memory allocated
  for such \texttt{Buffer} instances is \emph{not} initialized and
  \emph{can contain sensitive data}. Such \texttt{Buffer} instances
  \emph{must} be subsequently initialized by using either
  \hyperref[buffillvalue-offset-end-encoding]{\texttt{buf.fill(0)}} or
  by writing to the entire \texttt{Buffer} before reading data from the
  \texttt{Buffer}. While this behavior is \emph{intentional} to improve
  performance, development experience has demonstrated that a more
  explicit distinction is required between creating a
  fast-but-uninitialized \texttt{Buffer} versus creating a
  slower-but-safer \texttt{Buffer}. Since Node.js 8.0.0,
  \texttt{Buffer(num)} and \texttt{new\ \ \ Buffer(num)} return a
  \texttt{Buffer} with initialized memory.
\item
  Passing a string, array, or \texttt{Buffer} as the first argument
  copies the passed object's data into the \texttt{Buffer}.
\item
  Passing an
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}{\texttt{ArrayBuffer}}
  or a
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer}{\texttt{SharedArrayBuffer}}
  returns a \texttt{Buffer} that shares allocated memory with the given
  array buffer.
\end{itemize}

Because the behavior of \texttt{new\ Buffer()} is different depending on
the type of the first argument, security and reliability issues can be
inadvertently introduced into applications when argument validation or
\texttt{Buffer} initialization is not performed.

For example, if an attacker can cause an application to receive a number
where a string is expected, the application may call
\texttt{new\ Buffer(100)} instead of \texttt{new\ Buffer("100")},
leading it to allocate a 100 byte buffer instead of allocating a 3 byte
buffer with content \texttt{"100"}. This is commonly possible using JSON
API calls. Since JSON distinguishes between numeric and string types, it
allows injection of numbers where a naively written application that
does not validate its input sufficiently might expect to always receive
a string. Before Node.js 8.0.0, the 100 byte buffer might contain
arbitrary pre-existing in-memory data, so may be used to expose
in-memory secrets to a remote attacker. Since Node.js 8.0.0, exposure of
memory cannot occur because the data is zero-filled. However, other
attacks are still possible, such as causing very large buffers to be
allocated by the server, leading to performance degradation or crashing
on memory exhaustion.

To make the creation of \texttt{Buffer} instances more reliable and less
error-prone, the various forms of the \texttt{new\ Buffer()} constructor
have been \textbf{deprecated} and replaced by separate
\texttt{Buffer.from()},
\hyperref[static-method-bufferallocsize-fill-encoding]{\texttt{Buffer.alloc()}},
and
\hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe()}}
methods.

\emph{Developers should migrate all existing uses of the
\texttt{new\ Buffer()} constructors to one of these new APIs.}

\begin{itemize}
\tightlist
\item
  \hyperref[static-method-bufferfromarray]{\texttt{Buffer.from(array)}}
  returns a new \texttt{Buffer} that \emph{contains a copy} of the
  provided octets.
\item
  \hyperref[static-method-bufferfromarraybuffer-byteoffset-length]{\texttt{Buffer.from(arrayBuffer{[},\ byteOffset{[},\ length{]}{]})}}
  returns a new \texttt{Buffer} that \emph{shares the same allocated
  memory} as the given
  \href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}{\texttt{ArrayBuffer}}.
\item
  \hyperref[static-method-bufferfrombuffer]{\texttt{Buffer.from(buffer)}}
  returns a new \texttt{Buffer} that \emph{contains a copy} of the
  contents of the given \texttt{Buffer}.
\item
  \hyperref[static-method-bufferfromstring-encoding]{\texttt{Buffer.from(string{[},\ encoding{]})}}
  returns a new \texttt{Buffer} that \emph{contains a copy} of the
  provided string.
\item
  \hyperref[static-method-bufferallocsize-fill-encoding]{\texttt{Buffer.alloc(size{[},\ fill{[},\ encoding{]}{]})}}
  returns a new initialized \texttt{Buffer} of the specified size. This
  method is slower than
  \hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe(size)}}
  but guarantees that newly created \texttt{Buffer} instances never
  contain old data that is potentially sensitive. A \texttt{TypeError}
  will be thrown if \texttt{size} is not a number.
\item
  \hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe(size)}}
  and
  \hyperref[static-method-bufferallocunsafeslowsize]{\texttt{Buffer.allocUnsafeSlow(size)}}
  each return a new uninitialized \texttt{Buffer} of the specified
  \texttt{size}. Because the \texttt{Buffer} is uninitialized, the
  allocated segment of memory might contain old data that is potentially
  sensitive.
\end{itemize}

\texttt{Buffer} instances returned by
\hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe()}}
and
\hyperref[static-method-bufferfromarray]{\texttt{Buffer.from(array)}}
\emph{may} be allocated off a shared internal memory pool if
\texttt{size} is less than or equal to half
\hyperref[class-property-bufferpoolsize]{\texttt{Buffer.poolSize}}.
Instances returned by
\hyperref[static-method-bufferallocunsafeslowsize]{\texttt{Buffer.allocUnsafeSlow()}}
\emph{never} use the shared internal memory pool.

\subsubsection{\texorpdfstring{The \texttt{-\/-zero-fill-buffers}
command-line
option}{The -\/-zero-fill-buffers command-line option}}\label{the---zero-fill-buffers-command-line-option}

Node.js can be started using the \texttt{-\/-zero-fill-buffers}
command-line option to cause all newly-allocated \texttt{Buffer}
instances to be zero-filled upon creation by default. Without the
option, buffers created with
\hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe()}},
\hyperref[static-method-bufferallocunsafeslowsize]{\texttt{Buffer.allocUnsafeSlow()}},
and \texttt{new\ SlowBuffer(size)} are not zero-filled. Use of this flag
can have a measurable negative impact on performance. Use the
\texttt{-\/-zero-fill-buffers} option only when necessary to enforce
that newly allocated \texttt{Buffer} instances cannot contain old data
that is potentially sensitive.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ node {-}{-}zero{-}fill{-}buffers}
\NormalTok{\textgreater{} Buffer.allocUnsafe(5);}
\NormalTok{\textless{}Buffer 00 00 00 00 00\textgreater{}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{What makes \texttt{Buffer.allocUnsafe()}
and \texttt{Buffer.allocUnsafeSlow()}
``unsafe''?}{What makes Buffer.allocUnsafe() and Buffer.allocUnsafeSlow() ``unsafe''?}}\label{what-makes-buffer.allocunsafe-and-buffer.allocunsafeslow-unsafe}

When calling
\hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe()}}
and
\hyperref[static-method-bufferallocunsafeslowsize]{\texttt{Buffer.allocUnsafeSlow()}},
the segment of allocated memory is \emph{uninitialized} (it is not
zeroed-out). While this design makes the allocation of memory quite
fast, the allocated segment of memory might contain old data that is
potentially sensitive. Using a \texttt{Buffer} created by
\hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe()}}
without \emph{completely} overwriting the memory can allow this old data
to be leaked when the \texttt{Buffer} memory is read.

While there are clear performance advantages to using
\hyperref[static-method-bufferallocunsafesize]{\texttt{Buffer.allocUnsafe()}},
extra care \emph{must} be taken in order to avoid introducing security
vulnerabilities into an application.
