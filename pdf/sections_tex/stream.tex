\section{Stream}\label{stream}

\begin{quote}
Stability: 2 - Stable
\end{quote}

A stream is an abstract interface for working with streaming data in
Node.js. The \texttt{node:stream} module provides an API for
implementing the stream interface.

There are many stream objects provided by Node.js. For instance, a
\href{http.md\#class-httpincomingmessage}{request to an HTTP server} and
\href{process.md\#processstdout}{\texttt{process.stdout}} are both
stream instances.

Streams can be readable, writable, or both. All streams are instances of
\href{events.md\#class-eventemitter}{\texttt{EventEmitter}}.

To access the \texttt{node:stream} module:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ stream }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The \texttt{node:stream} module is useful for creating new types of
stream instances. It is usually not necessary to use the
\texttt{node:stream} module to consume streams.

\subsection{Organization of this
document}\label{organization-of-this-document}

This document contains two primary sections and a third section for
notes. The first section explains how to use existing streams within an
application. The second section explains how to create new types of
streams.

\subsection{Types of streams}\label{types-of-streams}

There are four fundamental stream types within Node.js:

\begin{itemize}
\tightlist
\item
  \hyperref[class-streamwritable]{\texttt{Writable}}: streams to which
  data can be written (for example,
  \href{fs.md\#fscreatewritestreampath-options}{\texttt{fs.createWriteStream()}}).
\item
  \hyperref[class-streamreadable]{\texttt{Readable}}: streams from which
  data can be read (for example,
  \href{fs.md\#fscreatereadstreampath-options}{\texttt{fs.createReadStream()}}).
\item
  \hyperref[class-streamduplex]{\texttt{Duplex}}: streams that are both
  \texttt{Readable} and \texttt{Writable} (for example,
  \href{net.md\#class-netsocket}{\texttt{net.Socket}}).
\item
  \hyperref[class-streamtransform]{\texttt{Transform}}: \texttt{Duplex}
  streams that can modify or transform the data as it is written and
  read (for example,
  \href{zlib.md\#zlibcreatedeflateoptions}{\texttt{zlib.createDeflate()}}).
\end{itemize}

Additionally, this module includes the utility functions
\hyperref[streampipelinesource-transforms-destination-callback]{\texttt{stream.pipeline()}},
\hyperref[streamfinishedstream-options-callback]{\texttt{stream.finished()}},
\hyperref[streamreadablefromiterable-options]{\texttt{stream.Readable.from()}}
and
\hyperref[streamaddabortsignalsignal-stream]{\texttt{stream.addAbortSignal()}}.

\subsubsection{Streams Promises API}\label{streams-promises-api}

The \texttt{stream/promises} API provides an alternative set of
asynchronous utility functions for streams that return \texttt{Promise}
objects rather than using callbacks. The API is accessible via
\texttt{require(\textquotesingle{}node:stream/promises\textquotesingle{})}
or
\texttt{require(\textquotesingle{}node:stream\textquotesingle{}).promises}.

\subsubsection{\texorpdfstring{\texttt{stream.pipeline(source{[},\ ...transforms{]},\ destination{[},\ options{]})}}{stream.pipeline(source{[}, ...transforms{]}, destination{[}, options{]})}}\label{stream.pipelinesource-...transforms-destination-options}

\subsubsection{\texorpdfstring{\texttt{stream.pipeline(streams{[},\ options{]})}}{stream.pipeline(streams{[}, options{]})}}\label{stream.pipelinestreams-options}

\begin{itemize}
\tightlist
\item
  \texttt{streams}
  \{Stream{[}{]}\textbar Iterable{[}{]}\textbar AsyncIterable{[}{]}\textbar Function{[}{]}\}
\item
  \texttt{source}
  \{Stream\textbar Iterable\textbar AsyncIterable\textbar Function\}

  \begin{itemize}
  \tightlist
  \item
    Returns: \{Promise\textbar AsyncIterable\}
  \end{itemize}
\item
  \texttt{...transforms} \{Stream\textbar Function\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{source} \{AsyncIterable\}
  \item
    Returns: \{Promise\textbar AsyncIterable\}
  \end{itemize}
\item
  \texttt{destination} \{Stream\textbar Function\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{source} \{AsyncIterable\}
  \item
    Returns: \{Promise\textbar AsyncIterable\}
  \end{itemize}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{signal} \{AbortSignal\}
  \item
    \texttt{end} \{boolean\}
  \end{itemize}
\item
  Returns: \{Promise\} Fulfills when the pipeline is complete.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ pipeline \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream/promises\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ zlib }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:zlib\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{async} \KeywordTok{function} \FunctionTok{run}\NormalTok{() \{}
  \ControlFlowTok{await} \FunctionTok{pipeline}\NormalTok{(}
\NormalTok{    fs}\OperatorTok{.}\FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}archive.tar\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
\NormalTok{    zlib}\OperatorTok{.}\FunctionTok{createGzip}\NormalTok{()}\OperatorTok{,}
\NormalTok{    fs}\OperatorTok{.}\FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}archive.tar.gz\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
\NormalTok{  )}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Pipeline succeeded.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}

\FunctionTok{run}\NormalTok{()}\OperatorTok{.}\FunctionTok{catch}\NormalTok{(}\BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ pipeline \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream/promises\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ createReadStream}\OperatorTok{,}\NormalTok{ createWriteStream \} }\ImportTok{from} \StringTok{\textquotesingle{}node:fs\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ createGzip \} }\ImportTok{from} \StringTok{\textquotesingle{}node:zlib\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{await} \FunctionTok{pipeline}\NormalTok{(}
  \FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}archive.tar\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
  \FunctionTok{createGzip}\NormalTok{()}\OperatorTok{,}
  \FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}archive.tar.gz\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
\NormalTok{)}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Pipeline succeeded.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

To use an \texttt{AbortSignal}, pass it inside an options object, as the
last argument. When the signal is aborted, \texttt{destroy} will be
called on the underlying pipeline, with an \texttt{AbortError}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ pipeline \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream/promises\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ zlib }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:zlib\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{async} \KeywordTok{function} \FunctionTok{run}\NormalTok{() \{}
  \KeywordTok{const}\NormalTok{ ac }\OperatorTok{=} \KeywordTok{new} \FunctionTok{AbortController}\NormalTok{()}\OperatorTok{;}
  \KeywordTok{const}\NormalTok{ signal }\OperatorTok{=}\NormalTok{ ac}\OperatorTok{.}\AttributeTok{signal}\OperatorTok{;}

  \FunctionTok{setImmediate}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ ac}\OperatorTok{.}\FunctionTok{abort}\NormalTok{())}\OperatorTok{;}
  \ControlFlowTok{await} \FunctionTok{pipeline}\NormalTok{(}
\NormalTok{    fs}\OperatorTok{.}\FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}archive.tar\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
\NormalTok{    zlib}\OperatorTok{.}\FunctionTok{createGzip}\NormalTok{()}\OperatorTok{,}
\NormalTok{    fs}\OperatorTok{.}\FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}archive.tar.gz\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
\NormalTok{    \{ signal \}}\OperatorTok{,}
\NormalTok{  )}\OperatorTok{;}
\NormalTok{\}}

\FunctionTok{run}\NormalTok{()}\OperatorTok{.}\FunctionTok{catch}\NormalTok{(}\BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{)}\OperatorTok{;} \CommentTok{// AbortError}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ pipeline \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream/promises\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ createReadStream}\OperatorTok{,}\NormalTok{ createWriteStream \} }\ImportTok{from} \StringTok{\textquotesingle{}node:fs\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ createGzip \} }\ImportTok{from} \StringTok{\textquotesingle{}node:zlib\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ ac }\OperatorTok{=} \KeywordTok{new} \FunctionTok{AbortController}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ \{ signal \} }\OperatorTok{=}\NormalTok{ ac}\OperatorTok{;}
\FunctionTok{setImmediate}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ ac}\OperatorTok{.}\FunctionTok{abort}\NormalTok{())}\OperatorTok{;}
\ControlFlowTok{try}\NormalTok{ \{}
  \ControlFlowTok{await} \FunctionTok{pipeline}\NormalTok{(}
    \FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}archive.tar\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
    \FunctionTok{createGzip}\NormalTok{()}\OperatorTok{,}
    \FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}archive.tar.gz\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
\NormalTok{    \{ signal \}}\OperatorTok{,}
\NormalTok{  )}\OperatorTok{;}
\NormalTok{\} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(err)}\OperatorTok{;} \CommentTok{// AbortError}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{pipeline} API also supports async generators:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ pipeline \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream/promises\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{async} \KeywordTok{function} \FunctionTok{run}\NormalTok{() \{}
  \ControlFlowTok{await} \FunctionTok{pipeline}\NormalTok{(}
\NormalTok{    fs}\OperatorTok{.}\FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}lowercase.txt\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
    \KeywordTok{async} \KeywordTok{function}\OperatorTok{*}\NormalTok{ (source}\OperatorTok{,}\NormalTok{ \{ signal \}) \{}
\NormalTok{      source}\OperatorTok{.}\FunctionTok{setEncoding}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}  \CommentTok{// Work with strings rather than \textasciigrave{}Buffer\textasciigrave{}s.}
      \ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ source) \{}
        \KeywordTok{yield} \ControlFlowTok{await} \FunctionTok{processChunk}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ \{ signal \})}\OperatorTok{;}
\NormalTok{      \}}
\NormalTok{    \}}\OperatorTok{,}
\NormalTok{    fs}\OperatorTok{.}\FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}uppercase.txt\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
\NormalTok{  )}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Pipeline succeeded.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}

\FunctionTok{run}\NormalTok{()}\OperatorTok{.}\FunctionTok{catch}\NormalTok{(}\BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ pipeline \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream/promises\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ createReadStream}\OperatorTok{,}\NormalTok{ createWriteStream \} }\ImportTok{from} \StringTok{\textquotesingle{}node:fs\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{await} \FunctionTok{pipeline}\NormalTok{(}
  \FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}lowercase.txt\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
  \KeywordTok{async} \KeywordTok{function}\OperatorTok{*}\NormalTok{ (source}\OperatorTok{,}\NormalTok{ \{ signal \}) \{}
\NormalTok{    source}\OperatorTok{.}\FunctionTok{setEncoding}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}  \CommentTok{// Work with strings rather than \textasciigrave{}Buffer\textasciigrave{}s.}
    \ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ source) \{}
      \KeywordTok{yield} \ControlFlowTok{await} \FunctionTok{processChunk}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ \{ signal \})}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \}}\OperatorTok{,}
  \FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}uppercase.txt\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
\NormalTok{)}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Pipeline succeeded.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Remember to handle the \texttt{signal} argument passed into the async
generator. Especially in the case where the async generator is the
source for the pipeline (i.e.~first argument) or the pipeline will never
complete.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ pipeline \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream/promises\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{async} \KeywordTok{function} \FunctionTok{run}\NormalTok{() \{}
  \ControlFlowTok{await} \FunctionTok{pipeline}\NormalTok{(}
    \KeywordTok{async} \KeywordTok{function}\OperatorTok{*}\NormalTok{ (\{ signal \}) \{}
      \ControlFlowTok{await} \FunctionTok{someLongRunningfn}\NormalTok{(\{ signal \})}\OperatorTok{;}
      \KeywordTok{yield} \StringTok{\textquotesingle{}asd\textquotesingle{}}\OperatorTok{;}
\NormalTok{    \}}\OperatorTok{,}
\NormalTok{    fs}\OperatorTok{.}\FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}uppercase.txt\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
\NormalTok{  )}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Pipeline succeeded.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}

\FunctionTok{run}\NormalTok{()}\OperatorTok{.}\FunctionTok{catch}\NormalTok{(}\BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ pipeline \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream/promises\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ fs }\ImportTok{from} \StringTok{\textquotesingle{}node:fs\textquotesingle{}}\OperatorTok{;}
\ControlFlowTok{await} \FunctionTok{pipeline}\NormalTok{(}
  \KeywordTok{async} \KeywordTok{function}\OperatorTok{*}\NormalTok{ (\{ signal \}) \{}
    \ControlFlowTok{await} \FunctionTok{someLongRunningfn}\NormalTok{(\{ signal \})}\OperatorTok{;}
    \KeywordTok{yield} \StringTok{\textquotesingle{}asd\textquotesingle{}}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{  fs}\OperatorTok{.}\FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}uppercase.txt\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
\NormalTok{)}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Pipeline succeeded.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The \texttt{pipeline} API provides
\hyperref[streampipelinesource-transforms-destination-callback]{callback
version}:

\subsubsection{\texorpdfstring{\texttt{stream.finished(stream{[},\ options{]})}}{stream.finished(stream{[}, options{]})}}\label{stream.finishedstream-options}

\begin{itemize}
\tightlist
\item
  \texttt{stream} \{Stream\}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{error} \{boolean\textbar undefined\}
  \item
    \texttt{readable} \{boolean\textbar undefined\}
  \item
    \texttt{writable} \{boolean\textbar undefined\}
  \item
    \texttt{signal}: \{AbortSignal\textbar undefined\}
  \end{itemize}
\item
  Returns: \{Promise\} Fulfills when the stream is no longer readable or
  writable.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ finished \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream/promises\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ rs }\OperatorTok{=}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}archive.tar\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{async} \KeywordTok{function} \FunctionTok{run}\NormalTok{() \{}
  \ControlFlowTok{await} \FunctionTok{finished}\NormalTok{(rs)}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Stream is done reading.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}

\FunctionTok{run}\NormalTok{()}\OperatorTok{.}\FunctionTok{catch}\NormalTok{(}\BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{)}\OperatorTok{;}
\NormalTok{rs}\OperatorTok{.}\FunctionTok{resume}\NormalTok{()}\OperatorTok{;} \CommentTok{// Drain the stream.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ finished \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream/promises\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ createReadStream \} }\ImportTok{from} \StringTok{\textquotesingle{}node:fs\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ rs }\OperatorTok{=} \FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}archive.tar\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{async} \KeywordTok{function} \FunctionTok{run}\NormalTok{() \{}
  \ControlFlowTok{await} \FunctionTok{finished}\NormalTok{(rs)}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Stream is done reading.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}

\FunctionTok{run}\NormalTok{()}\OperatorTok{.}\FunctionTok{catch}\NormalTok{(}\BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{)}\OperatorTok{;}
\NormalTok{rs}\OperatorTok{.}\FunctionTok{resume}\NormalTok{()}\OperatorTok{;} \CommentTok{// Drain the stream.}
\end{Highlighting}
\end{Shaded}

The \texttt{finished} API also provides a
\hyperref[streamfinishedstream-options-callback]{callback version}.

\subsubsection{Object mode}\label{object-mode}

All streams created by Node.js APIs operate exclusively on strings and
\texttt{Buffer} (or \texttt{Uint8Array}) objects. It is possible,
however, for stream implementations to work with other types of
JavaScript values (with the exception of \texttt{null}, which serves a
special purpose within streams). Such streams are considered to operate
in ``object mode''.

Stream instances are switched into object mode using the
\texttt{objectMode} option when the stream is created. Attempting to
switch an existing stream into object mode is not safe.

\subsubsection{Buffering}\label{buffering}

Both \hyperref[class-streamwritable]{\texttt{Writable}} and
\hyperref[class-streamreadable]{\texttt{Readable}} streams will store
data in an internal buffer.

The amount of data potentially buffered depends on the
\texttt{highWaterMark} option passed into the stream's constructor. For
normal streams, the \texttt{highWaterMark} option specifies a
\hyperref[highwatermark-discrepancy-after-calling-readablesetencoding]{total
number of bytes}. For streams operating in object mode, the
\texttt{highWaterMark} specifies a total number of objects.

Data is buffered in \texttt{Readable} streams when the implementation
calls
\hyperref[readablepushchunk-encoding]{\texttt{stream.push(chunk)}}. If
the consumer of the Stream does not call
\hyperref[readablereadsize]{\texttt{stream.read()}}, the data will sit
in the internal queue until it is consumed.

Once the total size of the internal read buffer reaches the threshold
specified by \texttt{highWaterMark}, the stream will temporarily stop
reading data from the underlying resource until the data currently
buffered can be consumed (that is, the stream will stop calling the
internal \hyperref[readable_readsize]{\texttt{readable.\_read()}} method
that is used to fill the read buffer).

Data is buffered in \texttt{Writable} streams when the
\hyperref[writablewritechunk-encoding-callback]{\texttt{writable.write(chunk)}}
method is called repeatedly. While the total size of the internal write
buffer is below the threshold set by \texttt{highWaterMark}, calls to
\texttt{writable.write()} will return \texttt{true}. Once the size of
the internal buffer reaches or exceeds the \texttt{highWaterMark},
\texttt{false} will be returned.

A key goal of the \texttt{stream} API, particularly the
\hyperref[readablepipedestination-options]{\texttt{stream.pipe()}}
method, is to limit the buffering of data to acceptable levels such that
sources and destinations of differing speeds will not overwhelm the
available memory.

The \texttt{highWaterMark} option is a threshold, not a limit: it
dictates the amount of data that a stream buffers before it stops asking
for more data. It does not enforce a strict memory limitation in
general. Specific stream implementations may choose to enforce stricter
limits but doing so is optional.

Because \hyperref[class-streamduplex]{\texttt{Duplex}} and
\hyperref[class-streamtransform]{\texttt{Transform}} streams are both
\texttt{Readable} and \texttt{Writable}, each maintains \emph{two}
separate internal buffers used for reading and writing, allowing each
side to operate independently of the other while maintaining an
appropriate and efficient flow of data. For example,
\href{net.md\#class-netsocket}{\texttt{net.Socket}} instances are
\hyperref[class-streamduplex]{\texttt{Duplex}} streams whose
\texttt{Readable} side allows consumption of data received \emph{from}
the socket and whose \texttt{Writable} side allows writing data
\emph{to} the socket. Because data may be written to the socket at a
faster or slower rate than data is received, each side should operate
(and buffer) independently of the other.

The mechanics of the internal buffering are an internal implementation
detail and may be changed at any time. However, for certain advanced
implementations, the internal buffers can be retrieved using
\texttt{writable.writableBuffer} or \texttt{readable.readableBuffer}.
Use of these undocumented properties is discouraged.

\subsection{API for stream consumers}\label{api-for-stream-consumers}

Almost all Node.js applications, no matter how simple, use streams in
some manner. The following is an example of using streams in a Node.js
application that implements an HTTP server:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ http }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:http\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ server }\OperatorTok{=}\NormalTok{ http}\OperatorTok{.}\FunctionTok{createServer}\NormalTok{((req}\OperatorTok{,}\NormalTok{ res) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \CommentTok{// \textasciigrave{}req\textasciigrave{} is an http.IncomingMessage, which is a readable stream.}
  \CommentTok{// \textasciigrave{}res\textasciigrave{} is an http.ServerResponse, which is a writable stream.}

  \KeywordTok{let}\NormalTok{ body }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\OperatorTok{;}
  \CommentTok{// Get the data as utf8 strings.}
  \CommentTok{// If an encoding is not set, Buffer objects will be received.}
\NormalTok{  req}\OperatorTok{.}\FunctionTok{setEncoding}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

  \CommentTok{// Readable streams emit \textquotesingle{}data\textquotesingle{} events once a listener is added.}
\NormalTok{  req}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}data\textquotesingle{}}\OperatorTok{,}\NormalTok{ (chunk) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{    body }\OperatorTok{+=}\NormalTok{ chunk}\OperatorTok{;}
\NormalTok{  \})}\OperatorTok{;}

  \CommentTok{// The \textquotesingle{}end\textquotesingle{} event indicates that the entire body has been received.}
\NormalTok{  req}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}end\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
    \ControlFlowTok{try}\NormalTok{ \{}
      \KeywordTok{const}\NormalTok{ data }\OperatorTok{=} \BuiltInTok{JSON}\OperatorTok{.}\FunctionTok{parse}\NormalTok{(body)}\OperatorTok{;}
      \CommentTok{// Write back something interesting to the user:}
\NormalTok{      res}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\KeywordTok{typeof}\NormalTok{ data)}\OperatorTok{;}
\NormalTok{      res}\OperatorTok{.}\FunctionTok{end}\NormalTok{()}\OperatorTok{;}
\NormalTok{    \} }\ControlFlowTok{catch}\NormalTok{ (er) \{}
      \CommentTok{// uh oh! bad json!}
\NormalTok{      res}\OperatorTok{.}\AttributeTok{statusCode} \OperatorTok{=} \DecValTok{400}\OperatorTok{;}
      \ControlFlowTok{return}\NormalTok{ res}\OperatorTok{.}\FunctionTok{end}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}error: }\SpecialCharTok{$\{}\NormalTok{er}\OperatorTok{.}\AttributeTok{message}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \})}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\NormalTok{server}\OperatorTok{.}\FunctionTok{listen}\NormalTok{(}\DecValTok{1337}\NormalTok{)}\OperatorTok{;}

\CommentTok{// $ curl localhost:1337 {-}d "\{\}"}
\CommentTok{// object}
\CommentTok{// $ curl localhost:1337 {-}d "\textbackslash{}"foo\textbackslash{}""}
\CommentTok{// string}
\CommentTok{// $ curl localhost:1337 {-}d "not json"}
\CommentTok{// error: Unexpected token \textquotesingle{}o\textquotesingle{}, "not json" is not valid JSON}
\end{Highlighting}
\end{Shaded}

\hyperref[class-streamwritable]{\texttt{Writable}} streams (such as
\texttt{res} in the example) expose methods such as \texttt{write()} and
\texttt{end()} that are used to write data onto the stream.

\hyperref[class-streamreadable]{\texttt{Readable}} streams use the
\href{events.md\#class-eventemitter}{\texttt{EventEmitter}} API for
notifying application code when data is available to be read off the
stream. That available data can be read from the stream in multiple
ways.

Both \hyperref[class-streamwritable]{\texttt{Writable}} and
\hyperref[class-streamreadable]{\texttt{Readable}} streams use the
\href{events.md\#class-eventemitter}{\texttt{EventEmitter}} API in
various ways to communicate the current state of the stream.

\hyperref[class-streamduplex]{\texttt{Duplex}} and
\hyperref[class-streamtransform]{\texttt{Transform}} streams are both
\hyperref[class-streamwritable]{\texttt{Writable}} and
\hyperref[class-streamreadable]{\texttt{Readable}}.

Applications that are either writing data to or consuming data from a
stream are not required to implement the stream interfaces directly and
will generally have no reason to call
\texttt{require(\textquotesingle{}node:stream\textquotesingle{})}.

Developers wishing to implement new types of streams should refer to the
section \hyperref[api-for-stream-implementers]{API for stream
implementers}.

\subsubsection{Writable streams}\label{writable-streams}

Writable streams are an abstraction for a \emph{destination} to which
data is written.

Examples of \hyperref[class-streamwritable]{\texttt{Writable}} streams
include:

\begin{itemize}
\tightlist
\item
  \href{http.md\#class-httpclientrequest}{HTTP requests, on the client}
\item
  \href{http.md\#class-httpserverresponse}{HTTP responses, on the
  server}
\item
  \href{fs.md\#class-fswritestream}{fs write streams}
\item
  \href{zlib.md}{zlib streams}
\item
  \href{crypto.md}{crypto streams}
\item
  \href{net.md\#class-netsocket}{TCP sockets}
\item
  \href{child_process.md\#subprocessstdin}{child process stdin}
\item
  \href{process.md\#processstdout}{\texttt{process.stdout}},
  \href{process.md\#processstderr}{\texttt{process.stderr}}
\end{itemize}

Some of these examples are actually
\hyperref[class-streamduplex]{\texttt{Duplex}} streams that implement
the \hyperref[class-streamwritable]{\texttt{Writable}} interface.

All \hyperref[class-streamwritable]{\texttt{Writable}} streams implement
the interface defined by the \texttt{stream.Writable} class.

While specific instances of
\hyperref[class-streamwritable]{\texttt{Writable}} streams may differ in
various ways, all \texttt{Writable} streams follow the same fundamental
usage pattern as illustrated in the example below:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ myStream }\OperatorTok{=} \FunctionTok{getWritableStreamSomehow}\NormalTok{()}\OperatorTok{;}
\NormalTok{myStream}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}some data\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{myStream}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}some more data\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{myStream}\OperatorTok{.}\FunctionTok{end}\NormalTok{(}\StringTok{\textquotesingle{}done writing data\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\paragraph{\texorpdfstring{Class:
\texttt{stream.Writable}}{Class: stream.Writable}}\label{class-stream.writable}

\subparagraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}close\textquotesingle{}}}{Event: \textquotesingle close\textquotesingle{}}}\label{event-close}

The \texttt{\textquotesingle{}close\textquotesingle{}} event is emitted
when the stream and any of its underlying resources (a file descriptor,
for example) have been closed. The event indicates that no more events
will be emitted, and no further computation will occur.

A \hyperref[class-streamwritable]{\texttt{Writable}} stream will always
emit the \texttt{\textquotesingle{}close\textquotesingle{}} event if it
is created with the \texttt{emitClose} option.

\subparagraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}drain\textquotesingle{}}}{Event: \textquotesingle drain\textquotesingle{}}}\label{event-drain}

If a call to
\hyperref[writablewritechunk-encoding-callback]{\texttt{stream.write(chunk)}}
returns \texttt{false}, the
\texttt{\textquotesingle{}drain\textquotesingle{}} event will be emitted
when it is appropriate to resume writing data to the stream.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Write the data to the supplied writable stream one million times.}
\CommentTok{// Be attentive to back{-}pressure.}
\KeywordTok{function} \FunctionTok{writeOneMillionTimes}\NormalTok{(writer}\OperatorTok{,}\NormalTok{ data}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
  \KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{1000000}\OperatorTok{;}
  \FunctionTok{write}\NormalTok{()}\OperatorTok{;}
  \KeywordTok{function} \FunctionTok{write}\NormalTok{() \{}
    \KeywordTok{let}\NormalTok{ ok }\OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
    \ControlFlowTok{do}\NormalTok{ \{}
\NormalTok{      i}\OperatorTok{{-}{-};}
      \ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{===} \DecValTok{0}\NormalTok{) \{}
        \CommentTok{// Last time!}
\NormalTok{        writer}\OperatorTok{.}\FunctionTok{write}\NormalTok{(data}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback)}\OperatorTok{;}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
        \CommentTok{// See if we should continue, or wait.}
        \CommentTok{// Don\textquotesingle{}t pass the callback, because we\textquotesingle{}re not done yet.}
\NormalTok{        ok }\OperatorTok{=}\NormalTok{ writer}\OperatorTok{.}\FunctionTok{write}\NormalTok{(data}\OperatorTok{,}\NormalTok{ encoding)}\OperatorTok{;}
\NormalTok{      \}}
\NormalTok{    \} }\ControlFlowTok{while}\NormalTok{ (i }\OperatorTok{\textgreater{}} \DecValTok{0} \OperatorTok{\&\&}\NormalTok{ ok)}\OperatorTok{;}
    \ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{) \{}
      \CommentTok{// Had to stop early!}
      \CommentTok{// Write some more once it drains.}
\NormalTok{      writer}\OperatorTok{.}\FunctionTok{once}\NormalTok{(}\StringTok{\textquotesingle{}drain\textquotesingle{}}\OperatorTok{,}\NormalTok{ write)}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}error\textquotesingle{}}}{Event: \textquotesingle error\textquotesingle{}}}\label{event-error}

\begin{itemize}
\tightlist
\item
  \{Error\}
\end{itemize}

The \texttt{\textquotesingle{}error\textquotesingle{}} event is emitted
if an error occurred while writing or piping data. The listener callback
is passed a single \texttt{Error} argument when called.

The stream is closed when the
\texttt{\textquotesingle{}error\textquotesingle{}} event is emitted
unless the \hyperref[new-streamwritableoptions]{\texttt{autoDestroy}}
option was set to \texttt{false} when creating the stream.

After \texttt{\textquotesingle{}error\textquotesingle{}}, no further
events other than \texttt{\textquotesingle{}close\textquotesingle{}}
\emph{should} be emitted (including
\texttt{\textquotesingle{}error\textquotesingle{}} events).

\subparagraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}finish\textquotesingle{}}}{Event: \textquotesingle finish\textquotesingle{}}}\label{event-finish}

The \texttt{\textquotesingle{}finish\textquotesingle{}} event is emitted
after the
\hyperref[writableendchunk-encoding-callback]{\texttt{stream.end()}}
method has been called, and all data has been flushed to the underlying
system.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ writer }\OperatorTok{=} \FunctionTok{getWritableStreamSomehow}\NormalTok{()}\OperatorTok{;}
\ControlFlowTok{for}\NormalTok{ (}\KeywordTok{let}\NormalTok{ i }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}\NormalTok{ i }\OperatorTok{\textless{}} \DecValTok{100}\OperatorTok{;}\NormalTok{ i}\OperatorTok{++}\NormalTok{) \{}
\NormalTok{  writer}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}hello, \#}\SpecialCharTok{$\{}\NormalTok{i}\SpecialCharTok{\}}\VerbatimStringTok{!}\SpecialCharTok{\textbackslash{}n}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\NormalTok{writer}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}finish\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}All writes are now complete.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\NormalTok{writer}\OperatorTok{.}\FunctionTok{end}\NormalTok{(}\StringTok{\textquotesingle{}This is the end}\SpecialCharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}pipe\textquotesingle{}}}{Event: \textquotesingle pipe\textquotesingle{}}}\label{event-pipe}

\begin{itemize}
\tightlist
\item
  \texttt{src} \{stream.Readable\} source stream that is piping to this
  writable
\end{itemize}

The \texttt{\textquotesingle{}pipe\textquotesingle{}} event is emitted
when the
\hyperref[readablepipedestination-options]{\texttt{stream.pipe()}}
method is called on a readable stream, adding this writable to its set
of destinations.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ writer }\OperatorTok{=} \FunctionTok{getWritableStreamSomehow}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ reader }\OperatorTok{=} \FunctionTok{getReadableStreamSomehow}\NormalTok{()}\OperatorTok{;}
\NormalTok{writer}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}pipe\textquotesingle{}}\OperatorTok{,}\NormalTok{ (src) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Something is piping into the writer.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  assert}\OperatorTok{.}\FunctionTok{equal}\NormalTok{(src}\OperatorTok{,}\NormalTok{ reader)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\NormalTok{reader}\OperatorTok{.}\FunctionTok{pipe}\NormalTok{(writer)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}unpipe\textquotesingle{}}}{Event: \textquotesingle unpipe\textquotesingle{}}}\label{event-unpipe}

\begin{itemize}
\tightlist
\item
  \texttt{src} \{stream.Readable\} The source stream that
  \hyperref[readableunpipedestination]{unpiped} this writable
\end{itemize}

The \texttt{\textquotesingle{}unpipe\textquotesingle{}} event is emitted
when the \hyperref[readableunpipedestination]{\texttt{stream.unpipe()}}
method is called on a \hyperref[class-streamreadable]{\texttt{Readable}}
stream, removing this \hyperref[class-streamwritable]{\texttt{Writable}}
from its set of destinations.

This is also emitted in case this
\hyperref[class-streamwritable]{\texttt{Writable}} stream emits an error
when a \hyperref[class-streamreadable]{\texttt{Readable}} stream pipes
into it.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ writer }\OperatorTok{=} \FunctionTok{getWritableStreamSomehow}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ reader }\OperatorTok{=} \FunctionTok{getReadableStreamSomehow}\NormalTok{()}\OperatorTok{;}
\NormalTok{writer}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}unpipe\textquotesingle{}}\OperatorTok{,}\NormalTok{ (src) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Something has stopped piping into the writer.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  assert}\OperatorTok{.}\FunctionTok{equal}\NormalTok{(src}\OperatorTok{,}\NormalTok{ reader)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\NormalTok{reader}\OperatorTok{.}\FunctionTok{pipe}\NormalTok{(writer)}\OperatorTok{;}
\NormalTok{reader}\OperatorTok{.}\FunctionTok{unpipe}\NormalTok{(writer)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{writable.cork()}}{writable.cork()}}\label{writable.cork}

The \texttt{writable.cork()} method forces all written data to be
buffered in memory. The buffered data will be flushed when either the
\hyperref[writableuncork]{\texttt{stream.uncork()}} or
\hyperref[writableendchunk-encoding-callback]{\texttt{stream.end()}}
methods are called.

The primary intent of \texttt{writable.cork()} is to accommodate a
situation in which several small chunks are written to the stream in
rapid succession. Instead of immediately forwarding them to the
underlying destination, \texttt{writable.cork()} buffers all the chunks
until \texttt{writable.uncork()} is called, which will pass them all to
\texttt{writable.\_writev()}, if present. This prevents a head-of-line
blocking situation where data is being buffered while waiting for the
first small chunk to be processed. However, use of
\texttt{writable.cork()} without implementing
\texttt{writable.\_writev()} may have an adverse effect on throughput.

See also: \hyperref[writableuncork]{\texttt{writable.uncork()}},
\hyperref[writable_writevchunks-callback]{\texttt{writable.\_writev()}}.

\subparagraph{\texorpdfstring{\texttt{writable.destroy({[}error{]})}}{writable.destroy({[}error{]})}}\label{writable.destroyerror}

\begin{itemize}
\tightlist
\item
  \texttt{error} \{Error\} Optional, an error to emit with
  \texttt{\textquotesingle{}error\textquotesingle{}} event.
\item
  Returns: \{this\}
\end{itemize}

Destroy the stream. Optionally emit an
\texttt{\textquotesingle{}error\textquotesingle{}} event, and emit a
\texttt{\textquotesingle{}close\textquotesingle{}} event (unless
\texttt{emitClose} is set to \texttt{false}). After this call, the
writable stream has ended and subsequent calls to \texttt{write()} or
\texttt{end()} will result in an \texttt{ERR\_STREAM\_DESTROYED} error.
This is a destructive and immediate way to destroy a stream. Previous
calls to \texttt{write()} may not have drained, and may trigger an
\texttt{ERR\_STREAM\_DESTROYED} error. Use \texttt{end()} instead of
destroy if data should flush before close, or wait for the
\texttt{\textquotesingle{}drain\textquotesingle{}} event before
destroying the stream.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ myStream }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Writable}\NormalTok{()}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ fooErr }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Error}\NormalTok{(}\StringTok{\textquotesingle{}foo error\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{myStream}\OperatorTok{.}\FunctionTok{destroy}\NormalTok{(fooErr)}\OperatorTok{;}
\NormalTok{myStream}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}error\textquotesingle{}}\OperatorTok{,}\NormalTok{ (fooErr) }\KeywordTok{=\textgreater{}} \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(fooErr}\OperatorTok{.}\AttributeTok{message}\NormalTok{))}\OperatorTok{;} \CommentTok{// foo error}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ myStream }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Writable}\NormalTok{()}\OperatorTok{;}

\NormalTok{myStream}\OperatorTok{.}\FunctionTok{destroy}\NormalTok{()}\OperatorTok{;}
\NormalTok{myStream}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}error\textquotesingle{}}\OperatorTok{,} \KeywordTok{function} \FunctionTok{wontHappen}\NormalTok{() \{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ myStream }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Writable}\NormalTok{()}\OperatorTok{;}
\NormalTok{myStream}\OperatorTok{.}\FunctionTok{destroy}\NormalTok{()}\OperatorTok{;}

\NormalTok{myStream}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}foo\textquotesingle{}}\OperatorTok{,}\NormalTok{ (error) }\KeywordTok{=\textgreater{}} \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(error}\OperatorTok{.}\AttributeTok{code}\NormalTok{))}\OperatorTok{;}
\CommentTok{// ERR\_STREAM\_DESTROYED}
\end{Highlighting}
\end{Shaded}

Once \texttt{destroy()} has been called any further calls will be a
no-op and no further errors except from \texttt{\_destroy()} may be
emitted as \texttt{\textquotesingle{}error\textquotesingle{}}.

Implementors should not override this method, but instead implement
\hyperref[writable_destroyerr-callback]{\texttt{writable.\_destroy()}}.

\subparagraph{\texorpdfstring{\texttt{writable.closed}}{writable.closed}}\label{writable.closed}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Is \texttt{true} after
\texttt{\textquotesingle{}close\textquotesingle{}} has been emitted.

\subparagraph{\texorpdfstring{\texttt{writable.destroyed}}{writable.destroyed}}\label{writable.destroyed}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Is \texttt{true} after
\hyperref[writabledestroyerror]{\texttt{writable.destroy()}} has been
called.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ myStream }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Writable}\NormalTok{()}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(myStream}\OperatorTok{.}\AttributeTok{destroyed}\NormalTok{)}\OperatorTok{;} \CommentTok{// false}
\NormalTok{myStream}\OperatorTok{.}\FunctionTok{destroy}\NormalTok{()}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(myStream}\OperatorTok{.}\AttributeTok{destroyed}\NormalTok{)}\OperatorTok{;} \CommentTok{// true}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{writable.end({[}chunk{[},\ encoding{]}{]}{[},\ callback{]})}}{writable.end({[}chunk{[}, encoding{]}{]}{[}, callback{]})}}\label{writable.endchunk-encoding-callback}

\begin{itemize}
\tightlist
\item
  \texttt{chunk}
  \{string\textbar Buffer\textbar Uint8Array\textbar any\} Optional data
  to write. For streams not operating in object mode, \texttt{chunk}
  must be a string, \texttt{Buffer} or \texttt{Uint8Array}. For object
  mode streams, \texttt{chunk} may be any JavaScript value other than
  \texttt{null}.
\item
  \texttt{encoding} \{string\} The encoding if \texttt{chunk} is a
  string
\item
  \texttt{callback} \{Function\} Callback for when the stream is
  finished.
\item
  Returns: \{this\}
\end{itemize}

Calling the \texttt{writable.end()} method signals that no more data
will be written to the
\hyperref[class-streamwritable]{\texttt{Writable}}. The optional
\texttt{chunk} and \texttt{encoding} arguments allow one final
additional chunk of data to be written immediately before closing the
stream.

Calling the
\hyperref[writablewritechunk-encoding-callback]{\texttt{stream.write()}}
method after calling
\hyperref[writableendchunk-encoding-callback]{\texttt{stream.end()}}
will raise an error.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Write \textquotesingle{}hello, \textquotesingle{} and then end with \textquotesingle{}world!\textquotesingle{}.}
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ file }\OperatorTok{=}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}example.txt\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{file}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}hello, \textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{file}\OperatorTok{.}\FunctionTok{end}\NormalTok{(}\StringTok{\textquotesingle{}world!\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Writing more now is not allowed!}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{writable.setDefaultEncoding(encoding)}}{writable.setDefaultEncoding(encoding)}}\label{writable.setdefaultencodingencoding}

\begin{itemize}
\tightlist
\item
  \texttt{encoding} \{string\} The new default encoding
\item
  Returns: \{this\}
\end{itemize}

The \texttt{writable.setDefaultEncoding()} method sets the default
\texttt{encoding} for a
\hyperref[class-streamwritable]{\texttt{Writable}} stream.

\subparagraph{\texorpdfstring{\texttt{writable.uncork()}}{writable.uncork()}}\label{writable.uncork}

The \texttt{writable.uncork()} method flushes all data buffered since
\hyperref[writablecork]{\texttt{stream.cork()}} was called.

When using \hyperref[writablecork]{\texttt{writable.cork()}} and
\texttt{writable.uncork()} to manage the buffering of writes to a
stream, defer calls to \texttt{writable.uncork()} using
\texttt{process.nextTick()}. Doing so allows batching of all
\texttt{writable.write()} calls that occur within a given Node.js event
loop phase.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stream}\OperatorTok{.}\FunctionTok{cork}\NormalTok{()}\OperatorTok{;}
\NormalTok{stream}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}some \textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{stream}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}data \textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\BuiltInTok{process}\OperatorTok{.}\FunctionTok{nextTick}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ stream}\OperatorTok{.}\FunctionTok{uncork}\NormalTok{())}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

If the \hyperref[writablecork]{\texttt{writable.cork()}} method is
called multiple times on a stream, the same number of calls to
\texttt{writable.uncork()} must be called to flush the buffered data.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{stream}\OperatorTok{.}\FunctionTok{cork}\NormalTok{()}\OperatorTok{;}
\NormalTok{stream}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}some \textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{stream}\OperatorTok{.}\FunctionTok{cork}\NormalTok{()}\OperatorTok{;}
\NormalTok{stream}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}data \textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\BuiltInTok{process}\OperatorTok{.}\FunctionTok{nextTick}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  stream}\OperatorTok{.}\FunctionTok{uncork}\NormalTok{()}\OperatorTok{;}
  \CommentTok{// The data will not be flushed until uncork() is called a second time.}
\NormalTok{  stream}\OperatorTok{.}\FunctionTok{uncork}\NormalTok{()}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

See also: \hyperref[writablecork]{\texttt{writable.cork()}}.

\subparagraph{\texorpdfstring{\texttt{writable.writable}}{writable.writable}}\label{writable.writable}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Is \texttt{true} if it is safe to call
\hyperref[writablewritechunk-encoding-callback]{\texttt{writable.write()}},
which means the stream has not been destroyed, errored, or ended.

\subparagraph{\texorpdfstring{\texttt{writable.writableAborted}}{writable.writableAborted}}\label{writable.writableaborted}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Returns whether the stream was destroyed or errored before emitting
\texttt{\textquotesingle{}finish\textquotesingle{}}.

\subparagraph{\texorpdfstring{\texttt{writable.writableEnded}}{writable.writableEnded}}\label{writable.writableended}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Is \texttt{true} after
\hyperref[writableendchunk-encoding-callback]{\texttt{writable.end()}}
has been called. This property does not indicate whether the data has
been flushed, for this use
\hyperref[writablewritablefinished]{\texttt{writable.writableFinished}}
instead.

\subparagraph{\texorpdfstring{\texttt{writable.writableCorked}}{writable.writableCorked}}\label{writable.writablecorked}

\begin{itemize}
\tightlist
\item
  \{integer\}
\end{itemize}

Number of times \hyperref[writableuncork]{\texttt{writable.uncork()}}
needs to be called in order to fully uncork the stream.

\subparagraph{\texorpdfstring{\texttt{writable.errored}}{writable.errored}}\label{writable.errored}

\begin{itemize}
\tightlist
\item
  \{Error\}
\end{itemize}

Returns error if the stream has been destroyed with an error.

\subparagraph{\texorpdfstring{\texttt{writable.writableFinished}}{writable.writableFinished}}\label{writable.writablefinished}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Is set to \texttt{true} immediately before the
\hyperref[event-finish]{\texttt{\textquotesingle{}finish\textquotesingle{}}}
event is emitted.

\subparagraph{\texorpdfstring{\texttt{writable.writableHighWaterMark}}{writable.writableHighWaterMark}}\label{writable.writablehighwatermark}

\begin{itemize}
\tightlist
\item
  \{number\}
\end{itemize}

Return the value of \texttt{highWaterMark} passed when creating this
\texttt{Writable}.

\subparagraph{\texorpdfstring{\texttt{writable.writableLength}}{writable.writableLength}}\label{writable.writablelength}

\begin{itemize}
\tightlist
\item
  \{number\}
\end{itemize}

This property contains the number of bytes (or objects) in the queue
ready to be written. The value provides introspection data regarding the
status of the \texttt{highWaterMark}.

\subparagraph{\texorpdfstring{\texttt{writable.writableNeedDrain}}{writable.writableNeedDrain}}\label{writable.writableneeddrain}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Is \texttt{true} if the stream's buffer has been full and stream will
emit \texttt{\textquotesingle{}drain\textquotesingle{}}.

\subparagraph{\texorpdfstring{\texttt{writable.writableObjectMode}}{writable.writableObjectMode}}\label{writable.writableobjectmode}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Getter for the property \texttt{objectMode} of a given \texttt{Writable}
stream.

\subparagraph{\texorpdfstring{\texttt{writable.write(chunk{[},\ encoding{]}{[},\ callback{]})}}{writable.write(chunk{[}, encoding{]}{[}, callback{]})}}\label{writable.writechunk-encoding-callback}

\begin{itemize}
\tightlist
\item
  \texttt{chunk}
  \{string\textbar Buffer\textbar Uint8Array\textbar any\} Optional data
  to write. For streams not operating in object mode, \texttt{chunk}
  must be a string, \texttt{Buffer} or \texttt{Uint8Array}. For object
  mode streams, \texttt{chunk} may be any JavaScript value other than
  \texttt{null}.
\item
  \texttt{encoding} \{string\textbar null\} The encoding, if
  \texttt{chunk} is a string. \textbf{Default:}
  \texttt{\textquotesingle{}utf8\textquotesingle{}}
\item
  \texttt{callback} \{Function\} Callback for when this chunk of data is
  flushed.
\item
  Returns: \{boolean\} \texttt{false} if the stream wishes for the
  calling code to wait for the
  \texttt{\textquotesingle{}drain\textquotesingle{}} event to be emitted
  before continuing to write additional data; otherwise \texttt{true}.
\end{itemize}

The \texttt{writable.write()} method writes some data to the stream, and
calls the supplied \texttt{callback} once the data has been fully
handled. If an error occurs, the \texttt{callback} will be called with
the error as its first argument. The \texttt{callback} is called
asynchronously and before
\texttt{\textquotesingle{}error\textquotesingle{}} is emitted.

The return value is \texttt{true} if the internal buffer is less than
the \texttt{highWaterMark} configured when the stream was created after
admitting \texttt{chunk}. If \texttt{false} is returned, further
attempts to write data to the stream should stop until the
\hyperref[event-drain]{\texttt{\textquotesingle{}drain\textquotesingle{}}}
event is emitted.

While a stream is not draining, calls to \texttt{write()} will buffer
\texttt{chunk}, and return false. Once all currently buffered chunks are
drained (accepted for delivery by the operating system), the
\texttt{\textquotesingle{}drain\textquotesingle{}} event will be
emitted. Once \texttt{write()} returns false, do not write more chunks
until the \texttt{\textquotesingle{}drain\textquotesingle{}} event is
emitted. While calling \texttt{write()} on a stream that is not draining
is allowed, Node.js will buffer all written chunks until maximum memory
usage occurs, at which point it will abort unconditionally. Even before
it aborts, high memory usage will cause poor garbage collector
performance and high RSS (which is not typically released back to the
system, even after the memory is no longer required). Since TCP sockets
may never drain if the remote peer does not read the data, writing a
socket that is not draining may lead to a remotely exploitable
vulnerability.

Writing data while the stream is not draining is particularly
problematic for a \hyperref[class-streamtransform]{\texttt{Transform}},
because the \texttt{Transform} streams are paused by default until they
are piped or a \texttt{\textquotesingle{}data\textquotesingle{}} or
\texttt{\textquotesingle{}readable\textquotesingle{}} event handler is
added.

If the data to be written can be generated or fetched on demand, it is
recommended to encapsulate the logic into a
\hyperref[class-streamreadable]{\texttt{Readable}} and use
\hyperref[readablepipedestination-options]{\texttt{stream.pipe()}}.
However, if calling \texttt{write()} is preferred, it is possible to
respect backpressure and avoid memory issues using the
\hyperref[event-drain]{\texttt{\textquotesingle{}drain\textquotesingle{}}}
event:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{write}\NormalTok{(data}\OperatorTok{,}\NormalTok{ cb) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\NormalTok{stream}\OperatorTok{.}\FunctionTok{write}\NormalTok{(data)) \{}
\NormalTok{    stream}\OperatorTok{.}\FunctionTok{once}\NormalTok{(}\StringTok{\textquotesingle{}drain\textquotesingle{}}\OperatorTok{,}\NormalTok{ cb)}\OperatorTok{;}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \BuiltInTok{process}\OperatorTok{.}\FunctionTok{nextTick}\NormalTok{(cb)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}

\CommentTok{// Wait for cb to be called before doing any other write.}
\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}hello\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Write completed, do more writes now.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

A \texttt{Writable} stream in object mode will always ignore the
\texttt{encoding} argument.

\subsubsection{Readable streams}\label{readable-streams}

Readable streams are an abstraction for a \emph{source} from which data
is consumed.

Examples of \texttt{Readable} streams include:

\begin{itemize}
\tightlist
\item
  \href{http.md\#class-httpincomingmessage}{HTTP responses, on the
  client}
\item
  \href{http.md\#class-httpincomingmessage}{HTTP requests, on the
  server}
\item
  \href{fs.md\#class-fsreadstream}{fs read streams}
\item
  \href{zlib.md}{zlib streams}
\item
  \href{crypto.md}{crypto streams}
\item
  \href{net.md\#class-netsocket}{TCP sockets}
\item
  \href{child_process.md\#subprocessstdout}{child process stdout and
  stderr}
\item
  \href{process.md\#processstdin}{\texttt{process.stdin}}
\end{itemize}

All \hyperref[class-streamreadable]{\texttt{Readable}} streams implement
the interface defined by the \texttt{stream.Readable} class.

\paragraph{Two reading modes}\label{two-reading-modes}

\texttt{Readable} streams effectively operate in one of two modes:
flowing and paused. These modes are separate from
\hyperref[object-mode]{object mode}. A
\hyperref[class-streamreadable]{\texttt{Readable}} stream can be in
object mode or not, regardless of whether it is in flowing mode or
paused mode.

\begin{itemize}
\item
  In flowing mode, data is read from the underlying system automatically
  and provided to an application as quickly as possible using events via
  the \href{events.md\#class-eventemitter}{\texttt{EventEmitter}}
  interface.
\item
  In paused mode, the
  \hyperref[readablereadsize]{\texttt{stream.read()}} method must be
  called explicitly to read chunks of data from the stream.
\end{itemize}

All \hyperref[class-streamreadable]{\texttt{Readable}} streams begin in
paused mode but can be switched to flowing mode in one of the following
ways:

\begin{itemize}
\tightlist
\item
  Adding a
  \hyperref[event-data]{\texttt{\textquotesingle{}data\textquotesingle{}}}
  event handler.
\item
  Calling the \hyperref[readableresume]{\texttt{stream.resume()}}
  method.
\item
  Calling the
  \hyperref[readablepipedestination-options]{\texttt{stream.pipe()}}
  method to send the data to a
  \hyperref[class-streamwritable]{\texttt{Writable}}.
\end{itemize}

The \texttt{Readable} can switch back to paused mode using one of the
following:

\begin{itemize}
\tightlist
\item
  If there are no pipe destinations, by calling the
  \hyperref[readablepause]{\texttt{stream.pause()}} method.
\item
  If there are pipe destinations, by removing all pipe destinations.
  Multiple pipe destinations may be removed by calling the
  \hyperref[readableunpipedestination]{\texttt{stream.unpipe()}} method.
\end{itemize}

The important concept to remember is that a \texttt{Readable} will not
generate data until a mechanism for either consuming or ignoring that
data is provided. If the consuming mechanism is disabled or taken away,
the \texttt{Readable} will \emph{attempt} to stop generating the data.

For backward compatibility reasons, removing
\hyperref[event-data]{\texttt{\textquotesingle{}data\textquotesingle{}}}
event handlers will \textbf{not} automatically pause the stream. Also,
if there are piped destinations, then calling
\hyperref[readablepause]{\texttt{stream.pause()}} will not guarantee
that the stream will \emph{remain} paused once those destinations drain
and ask for more data.

If a \hyperref[class-streamreadable]{\texttt{Readable}} is switched into
flowing mode and there are no consumers available to handle the data,
that data will be lost. This can occur, for instance, when the
\texttt{readable.resume()} method is called without a listener attached
to the \texttt{\textquotesingle{}data\textquotesingle{}} event, or when
a \texttt{\textquotesingle{}data\textquotesingle{}} event handler is
removed from the stream.

Adding a
\hyperref[event-readable]{\texttt{\textquotesingle{}readable\textquotesingle{}}}
event handler automatically makes the stream stop flowing, and the data
has to be consumed via
\hyperref[readablereadsize]{\texttt{readable.read()}}. If the
\hyperref[event-readable]{\texttt{\textquotesingle{}readable\textquotesingle{}}}
event handler is removed, then the stream will start flowing again if
there is a
\hyperref[event-data]{\texttt{\textquotesingle{}data\textquotesingle{}}}
event handler.

\paragraph{Three states}\label{three-states}

The ``two modes'' of operation for a \texttt{Readable} stream are a
simplified abstraction for the more complicated internal state
management that is happening within the \texttt{Readable} stream
implementation.

Specifically, at any given point in time, every \texttt{Readable} is in
one of three possible states:

\begin{itemize}
\tightlist
\item
  \texttt{readable.readableFlowing\ ===\ null}
\item
  \texttt{readable.readableFlowing\ ===\ false}
\item
  \texttt{readable.readableFlowing\ ===\ true}
\end{itemize}

When \texttt{readable.readableFlowing} is \texttt{null}, no mechanism
for consuming the stream's data is provided. Therefore, the stream will
not generate data. While in this state, attaching a listener for the
\texttt{\textquotesingle{}data\textquotesingle{}} event, calling the
\texttt{readable.pipe()} method, or calling the
\texttt{readable.resume()} method will switch
\texttt{readable.readableFlowing} to \texttt{true}, causing the
\texttt{Readable} to begin actively emitting events as data is
generated.

Calling \texttt{readable.pause()}, \texttt{readable.unpipe()}, or
receiving backpressure will cause the \texttt{readable.readableFlowing}
to be set as \texttt{false}, temporarily halting the flowing of events
but \emph{not} halting the generation of data. While in this state,
attaching a listener for the
\texttt{\textquotesingle{}data\textquotesingle{}} event will not switch
\texttt{readable.readableFlowing} to \texttt{true}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ PassThrough}\OperatorTok{,}\NormalTok{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ pass }\OperatorTok{=} \KeywordTok{new} \FunctionTok{PassThrough}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ writable }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Writable}\NormalTok{()}\OperatorTok{;}

\NormalTok{pass}\OperatorTok{.}\FunctionTok{pipe}\NormalTok{(writable)}\OperatorTok{;}
\NormalTok{pass}\OperatorTok{.}\FunctionTok{unpipe}\NormalTok{(writable)}\OperatorTok{;}
\CommentTok{// readableFlowing is now false.}

\NormalTok{pass}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}data\textquotesingle{}}\OperatorTok{,}\NormalTok{ (chunk) }\KeywordTok{=\textgreater{}}\NormalTok{ \{ }\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(chunk}\OperatorTok{.}\FunctionTok{toString}\NormalTok{())}\OperatorTok{;}\NormalTok{ \})}\OperatorTok{;}
\CommentTok{// readableFlowing is still false.}
\NormalTok{pass}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}ok\textquotesingle{}}\NormalTok{)}\OperatorTok{;}  \CommentTok{// Will not emit \textquotesingle{}data\textquotesingle{}.}
\NormalTok{pass}\OperatorTok{.}\FunctionTok{resume}\NormalTok{()}\OperatorTok{;}     \CommentTok{// Must be called to make stream emit \textquotesingle{}data\textquotesingle{}.}
\CommentTok{// readableFlowing is now true.}
\end{Highlighting}
\end{Shaded}

While \texttt{readable.readableFlowing} is \texttt{false}, data may be
accumulating within the stream's internal buffer.

\paragraph{Choose one API style}\label{choose-one-api-style}

The \texttt{Readable} stream API evolved across multiple Node.js
versions and provides multiple methods of consuming stream data. In
general, developers should choose \emph{one} of the methods of consuming
data and \emph{should never} use multiple methods to consume data from a
single stream. Specifically, using a combination of
\texttt{on(\textquotesingle{}data\textquotesingle{})},
\texttt{on(\textquotesingle{}readable\textquotesingle{})},
\texttt{pipe()}, or async iterators could lead to unintuitive behavior.

\paragraph{\texorpdfstring{Class:
\texttt{stream.Readable}}{Class: stream.Readable}}\label{class-stream.readable}

\subparagraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}close\textquotesingle{}}}{Event: \textquotesingle close\textquotesingle{}}}\label{event-close-1}

The \texttt{\textquotesingle{}close\textquotesingle{}} event is emitted
when the stream and any of its underlying resources (a file descriptor,
for example) have been closed. The event indicates that no more events
will be emitted, and no further computation will occur.

A \hyperref[class-streamreadable]{\texttt{Readable}} stream will always
emit the \texttt{\textquotesingle{}close\textquotesingle{}} event if it
is created with the \texttt{emitClose} option.

\subparagraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}data\textquotesingle{}}}{Event: \textquotesingle data\textquotesingle{}}}\label{event-data}

\begin{itemize}
\tightlist
\item
  \texttt{chunk} \{Buffer\textbar string\textbar any\} The chunk of
  data. For streams that are not operating in object mode, the chunk
  will be either a string or \texttt{Buffer}. For streams that are in
  object mode, the chunk can be any JavaScript value other than
  \texttt{null}.
\end{itemize}

The \texttt{\textquotesingle{}data\textquotesingle{}} event is emitted
whenever the stream is relinquishing ownership of a chunk of data to a
consumer. This may occur whenever the stream is switched in flowing mode
by calling \texttt{readable.pipe()}, \texttt{readable.resume()}, or by
attaching a listener callback to the
\texttt{\textquotesingle{}data\textquotesingle{}} event. The
\texttt{\textquotesingle{}data\textquotesingle{}} event will also be
emitted whenever the \texttt{readable.read()} method is called and a
chunk of data is available to be returned.

Attaching a \texttt{\textquotesingle{}data\textquotesingle{}} event
listener to a stream that has not been explicitly paused will switch the
stream into flowing mode. Data will then be passed as soon as it is
available.

The listener callback will be passed the chunk of data as a string if a
default encoding has been specified for the stream using the
\texttt{readable.setEncoding()} method; otherwise the data will be
passed as a \texttt{Buffer}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ readable }\OperatorTok{=} \FunctionTok{getReadableStreamSomehow}\NormalTok{()}\OperatorTok{;}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}data\textquotesingle{}}\OperatorTok{,}\NormalTok{ (chunk) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Received }\SpecialCharTok{$\{}\NormalTok{chunk}\OperatorTok{.}\AttributeTok{length}\SpecialCharTok{\}}\VerbatimStringTok{ bytes of data.\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}end\textquotesingle{}}}{Event: \textquotesingle end\textquotesingle{}}}\label{event-end}

The \texttt{\textquotesingle{}end\textquotesingle{}} event is emitted
when there is no more data to be consumed from the stream.

The \texttt{\textquotesingle{}end\textquotesingle{}} event \textbf{will
not be emitted} unless the data is completely consumed. This can be
accomplished by switching the stream into flowing mode, or by calling
\hyperref[readablereadsize]{\texttt{stream.read()}} repeatedly until all
data has been consumed.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ readable }\OperatorTok{=} \FunctionTok{getReadableStreamSomehow}\NormalTok{()}\OperatorTok{;}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}data\textquotesingle{}}\OperatorTok{,}\NormalTok{ (chunk) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Received }\SpecialCharTok{$\{}\NormalTok{chunk}\OperatorTok{.}\AttributeTok{length}\SpecialCharTok{\}}\VerbatimStringTok{ bytes of data.\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}end\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}There will be no more data.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}error\textquotesingle{}}}{Event: \textquotesingle error\textquotesingle{}}}\label{event-error-1}

\begin{itemize}
\tightlist
\item
  \{Error\}
\end{itemize}

The \texttt{\textquotesingle{}error\textquotesingle{}} event may be
emitted by a \texttt{Readable} implementation at any time. Typically,
this may occur if the underlying stream is unable to generate data due
to an underlying internal failure, or when a stream implementation
attempts to push an invalid chunk of data.

The listener callback will be passed a single \texttt{Error} object.

\subparagraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}pause\textquotesingle{}}}{Event: \textquotesingle pause\textquotesingle{}}}\label{event-pause}

The \texttt{\textquotesingle{}pause\textquotesingle{}} event is emitted
when \hyperref[readablepause]{\texttt{stream.pause()}} is called and
\texttt{readableFlowing} is not \texttt{false}.

\subparagraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}readable\textquotesingle{}}}{Event: \textquotesingle readable\textquotesingle{}}}\label{event-readable}

The \texttt{\textquotesingle{}readable\textquotesingle{}} event is
emitted when there is data available to be read from the stream or when
the end of the stream has been reached. Effectively, the
\texttt{\textquotesingle{}readable\textquotesingle{}} event indicates
that the stream has new information. If data is available,
\hyperref[readablereadsize]{\texttt{stream.read()}} will return that
data.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ readable }\OperatorTok{=} \FunctionTok{getReadableStreamSomehow}\NormalTok{()}\OperatorTok{;}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}readable\textquotesingle{}}\OperatorTok{,} \KeywordTok{function}\NormalTok{() \{}
  \CommentTok{// There is some data to read now.}
  \KeywordTok{let}\NormalTok{ data}\OperatorTok{;}

  \ControlFlowTok{while}\NormalTok{ ((data }\OperatorTok{=} \KeywordTok{this}\OperatorTok{.}\FunctionTok{read}\NormalTok{()) }\OperatorTok{!==} \KeywordTok{null}\NormalTok{) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(data)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

If the end of the stream has been reached, calling
\hyperref[readablereadsize]{\texttt{stream.read()}} will return
\texttt{null} and trigger the
\texttt{\textquotesingle{}end\textquotesingle{}} event. This is also
true if there never was any data to be read. For instance, in the
following example, \texttt{foo.txt} is an empty file:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ rr }\OperatorTok{=}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}foo.txt\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{rr}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}readable\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}readable: }\SpecialCharTok{$\{}\NormalTok{rr}\OperatorTok{.}\FunctionTok{read}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\NormalTok{rr}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}end\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}end\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The output of running this script is:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ node test.js}
\NormalTok{readable: null}
\NormalTok{end}
\end{Highlighting}
\end{Shaded}

In some cases, attaching a listener for the
\texttt{\textquotesingle{}readable\textquotesingle{}} event will cause
some amount of data to be read into an internal buffer.

In general, the \texttt{readable.pipe()} and
\texttt{\textquotesingle{}data\textquotesingle{}} event mechanisms are
easier to understand than the
\texttt{\textquotesingle{}readable\textquotesingle{}} event. However,
handling \texttt{\textquotesingle{}readable\textquotesingle{}} might
result in increased throughput.

If both \texttt{\textquotesingle{}readable\textquotesingle{}} and
\hyperref[event-data]{\texttt{\textquotesingle{}data\textquotesingle{}}}
are used at the same time,
\texttt{\textquotesingle{}readable\textquotesingle{}} takes precedence
in controlling the flow,
i.e.~\texttt{\textquotesingle{}data\textquotesingle{}} will be emitted
only when \hyperref[readablereadsize]{\texttt{stream.read()}} is called.
The \texttt{readableFlowing} property would become \texttt{false}. If
there are \texttt{\textquotesingle{}data\textquotesingle{}} listeners
when \texttt{\textquotesingle{}readable\textquotesingle{}} is removed,
the stream will start flowing,
i.e.~\texttt{\textquotesingle{}data\textquotesingle{}}~events will be
emitted without calling \texttt{.resume()}.

\subparagraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}resume\textquotesingle{}}}{Event: \textquotesingle resume\textquotesingle{}}}\label{event-resume}

The \texttt{\textquotesingle{}resume\textquotesingle{}} event is emitted
when \hyperref[readableresume]{\texttt{stream.resume()}} is called and
\texttt{readableFlowing} is not \texttt{true}.

\subparagraph{\texorpdfstring{\texttt{readable.destroy({[}error{]})}}{readable.destroy({[}error{]})}}\label{readable.destroyerror}

\begin{itemize}
\tightlist
\item
  \texttt{error} \{Error\} Error which will be passed as payload in
  \texttt{\textquotesingle{}error\textquotesingle{}} event
\item
  Returns: \{this\}
\end{itemize}

Destroy the stream. Optionally emit an
\texttt{\textquotesingle{}error\textquotesingle{}} event, and emit a
\texttt{\textquotesingle{}close\textquotesingle{}} event (unless
\texttt{emitClose} is set to \texttt{false}). After this call, the
readable stream will release any internal resources and subsequent calls
to \texttt{push()} will be ignored.

Once \texttt{destroy()} has been called any further calls will be a
no-op and no further errors except from \texttt{\_destroy()} may be
emitted as \texttt{\textquotesingle{}error\textquotesingle{}}.

Implementors should not override this method, but instead implement
\hyperref[readable_destroyerr-callback]{\texttt{readable.\_destroy()}}.

\subparagraph{\texorpdfstring{\texttt{readable.closed}}{readable.closed}}\label{readable.closed}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Is \texttt{true} after
\texttt{\textquotesingle{}close\textquotesingle{}} has been emitted.

\subparagraph{\texorpdfstring{\texttt{readable.destroyed}}{readable.destroyed}}\label{readable.destroyed}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Is \texttt{true} after
\hyperref[readabledestroyerror]{\texttt{readable.destroy()}} has been
called.

\subparagraph{\texorpdfstring{\texttt{readable.isPaused()}}{readable.isPaused()}}\label{readable.ispaused}

\begin{itemize}
\tightlist
\item
  Returns: \{boolean\}
\end{itemize}

The \texttt{readable.isPaused()} method returns the current operating
state of the \texttt{Readable}. This is used primarily by the mechanism
that underlies the \texttt{readable.pipe()} method. In most typical
cases, there will be no reason to use this method directly.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ readable }\OperatorTok{=} \KeywordTok{new}\NormalTok{ stream}\OperatorTok{.}\FunctionTok{Readable}\NormalTok{()}\OperatorTok{;}

\NormalTok{readable}\OperatorTok{.}\FunctionTok{isPaused}\NormalTok{()}\OperatorTok{;} \CommentTok{// === false}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{pause}\NormalTok{()}\OperatorTok{;}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{isPaused}\NormalTok{()}\OperatorTok{;} \CommentTok{// === true}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{resume}\NormalTok{()}\OperatorTok{;}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{isPaused}\NormalTok{()}\OperatorTok{;} \CommentTok{// === false}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable.pause()}}{readable.pause()}}\label{readable.pause}

\begin{itemize}
\tightlist
\item
  Returns: \{this\}
\end{itemize}

The \texttt{readable.pause()} method will cause a stream in flowing mode
to stop emitting
\hyperref[event-data]{\texttt{\textquotesingle{}data\textquotesingle{}}}
events, switching out of flowing mode. Any data that becomes available
will remain in the internal buffer.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ readable }\OperatorTok{=} \FunctionTok{getReadableStreamSomehow}\NormalTok{()}\OperatorTok{;}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}data\textquotesingle{}}\OperatorTok{,}\NormalTok{ (chunk) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Received }\SpecialCharTok{$\{}\NormalTok{chunk}\OperatorTok{.}\AttributeTok{length}\SpecialCharTok{\}}\VerbatimStringTok{ bytes of data.\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  readable}\OperatorTok{.}\FunctionTok{pause}\NormalTok{()}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}There will be no additional data for 1 second.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
  \PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Now data will start flowing again.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{    readable}\OperatorTok{.}\FunctionTok{resume}\NormalTok{()}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,} \DecValTok{1000}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The \texttt{readable.pause()} method has no effect if there is a
\texttt{\textquotesingle{}readable\textquotesingle{}} event listener.

\subparagraph{\texorpdfstring{\texttt{readable.pipe(destination{[},\ options{]})}}{readable.pipe(destination{[}, options{]})}}\label{readable.pipedestination-options}

\begin{itemize}
\tightlist
\item
  \texttt{destination} \{stream.Writable\} The destination for writing
  data
\item
  \texttt{options} \{Object\} Pipe options

  \begin{itemize}
  \tightlist
  \item
    \texttt{end} \{boolean\} End the writer when the reader ends.
    \textbf{Default:} \texttt{true}.
  \end{itemize}
\item
  Returns: \{stream.Writable\} The \emph{destination}, allowing for a
  chain of pipes if it is a
  \hyperref[class-streamduplex]{\texttt{Duplex}} or a
  \hyperref[class-streamtransform]{\texttt{Transform}} stream
\end{itemize}

The \texttt{readable.pipe()} method attaches a
\hyperref[class-streamwritable]{\texttt{Writable}} stream to the
\texttt{readable}, causing it to switch automatically into flowing mode
and push all of its data to the attached
\hyperref[class-streamwritable]{\texttt{Writable}}. The flow of data
will be automatically managed so that the destination \texttt{Writable}
stream is not overwhelmed by a faster \texttt{Readable} stream.

The following example pipes all of the data from the \texttt{readable}
into a file named \texttt{file.txt}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ readable }\OperatorTok{=} \FunctionTok{getReadableStreamSomehow}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ writable }\OperatorTok{=}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}file.txt\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// All the data from readable goes into \textquotesingle{}file.txt\textquotesingle{}.}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{pipe}\NormalTok{(writable)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

It is possible to attach multiple \texttt{Writable} streams to a single
\texttt{Readable} stream.

The \texttt{readable.pipe()} method returns a reference to the
\emph{destination} stream making it possible to set up chains of piped
streams:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ zlib }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:zlib\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ r }\OperatorTok{=}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}file.txt\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ z }\OperatorTok{=}\NormalTok{ zlib}\OperatorTok{.}\FunctionTok{createGzip}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ w }\OperatorTok{=}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}file.txt.gz\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{r}\OperatorTok{.}\FunctionTok{pipe}\NormalTok{(z)}\OperatorTok{.}\FunctionTok{pipe}\NormalTok{(w)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

By default,
\hyperref[writableendchunk-encoding-callback]{\texttt{stream.end()}} is
called on the destination \texttt{Writable} stream when the source
\texttt{Readable} stream emits
\hyperref[event-end]{\texttt{\textquotesingle{}end\textquotesingle{}}},
so that the destination is no longer writable. To disable this default
behavior, the \texttt{end} option can be passed as \texttt{false},
causing the destination stream to remain open:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{reader}\OperatorTok{.}\FunctionTok{pipe}\NormalTok{(writer}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{end}\OperatorTok{:} \KeywordTok{false}\NormalTok{ \})}\OperatorTok{;}
\NormalTok{reader}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}end\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  writer}\OperatorTok{.}\FunctionTok{end}\NormalTok{(}\StringTok{\textquotesingle{}Goodbye}\SpecialCharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

One important caveat is that if the \texttt{Readable} stream emits an
error during processing, the \texttt{Writable} destination \emph{is not
closed} automatically. If an error occurs, it will be necessary to
\emph{manually} close each stream in order to prevent memory leaks.

The \href{process.md\#processstderr}{\texttt{process.stderr}} and
\href{process.md\#processstdout}{\texttt{process.stdout}}
\texttt{Writable} streams are never closed until the Node.js process
exits, regardless of the specified options.

\subparagraph{\texorpdfstring{\texttt{readable.read({[}size{]})}}{readable.read({[}size{]})}}\label{readable.readsize}

\begin{itemize}
\tightlist
\item
  \texttt{size} \{number\} Optional argument to specify how much data to
  read.
\item
  Returns: \{string\textbar Buffer\textbar null\textbar any\}
\end{itemize}

The \texttt{readable.read()} method reads data out of the internal
buffer and returns it. If no data is available to be read, \texttt{null}
is returned. By default, the data is returned as a \texttt{Buffer}
object unless an encoding has been specified using the
\texttt{readable.setEncoding()} method or the stream is operating in
object mode.

The optional \texttt{size} argument specifies a specific number of bytes
to read. If \texttt{size} bytes are not available to be read,
\texttt{null} will be returned \emph{unless} the stream has ended, in
which case all of the data remaining in the internal buffer will be
returned.

If the \texttt{size} argument is not specified, all of the data
contained in the internal buffer will be returned.

The \texttt{size} argument must be less than or equal to 1 GiB.

The \texttt{readable.read()} method should only be called on
\texttt{Readable} streams operating in paused mode. In flowing mode,
\texttt{readable.read()} is called automatically until the internal
buffer is fully drained.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ readable }\OperatorTok{=} \FunctionTok{getReadableStreamSomehow}\NormalTok{()}\OperatorTok{;}

\CommentTok{// \textquotesingle{}readable\textquotesingle{} may be triggered multiple times as data is buffered in}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}readable\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{let}\NormalTok{ chunk}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Stream is readable (new data received in buffer)\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
  \CommentTok{// Use a loop to make sure we read all currently available data}
  \ControlFlowTok{while}\NormalTok{ (}\KeywordTok{null} \OperatorTok{!==}\NormalTok{ (chunk }\OperatorTok{=}\NormalTok{ readable}\OperatorTok{.}\FunctionTok{read}\NormalTok{())) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Read }\SpecialCharTok{$\{}\NormalTok{chunk}\OperatorTok{.}\AttributeTok{length}\SpecialCharTok{\}}\VerbatimStringTok{ bytes of data...\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\})}\OperatorTok{;}

\CommentTok{// \textquotesingle{}end\textquotesingle{} will be triggered once when there is no more data available}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}end\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Reached end of stream.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Each call to \texttt{readable.read()} returns a chunk of data, or
\texttt{null}. The chunks are not concatenated. A \texttt{while} loop is
necessary to consume all data currently in the buffer. When reading a
large file \texttt{.read()} may return \texttt{null}, having consumed
all buffered content so far, but there is still more data to come not
yet buffered. In this case a new
\texttt{\textquotesingle{}readable\textquotesingle{}} event will be
emitted when there is more data in the buffer. Finally the
\texttt{\textquotesingle{}end\textquotesingle{}} event will be emitted
when there is no more data to come.

Therefore to read a file's whole contents from a \texttt{readable}, it
is necessary to collect chunks across multiple
\texttt{\textquotesingle{}readable\textquotesingle{}} events:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ chunks }\OperatorTok{=}\NormalTok{ []}\OperatorTok{;}

\NormalTok{readable}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}readable\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{let}\NormalTok{ chunk}\OperatorTok{;}
  \ControlFlowTok{while}\NormalTok{ (}\KeywordTok{null} \OperatorTok{!==}\NormalTok{ (chunk }\OperatorTok{=}\NormalTok{ readable}\OperatorTok{.}\FunctionTok{read}\NormalTok{())) \{}
\NormalTok{    chunks}\OperatorTok{.}\FunctionTok{push}\NormalTok{(chunk)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\})}\OperatorTok{;}

\NormalTok{readable}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}end\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{const}\NormalTok{ content }\OperatorTok{=}\NormalTok{ chunks}\OperatorTok{.}\FunctionTok{join}\NormalTok{(}\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

A \texttt{Readable} stream in object mode will always return a single
item from a call to
\hyperref[readablereadsize]{\texttt{readable.read(size)}}, regardless of
the value of the \texttt{size} argument.

If the \texttt{readable.read()} method returns a chunk of data, a
\texttt{\textquotesingle{}data\textquotesingle{}} event will also be
emitted.

Calling \hyperref[readablereadsize]{\texttt{stream.read({[}size{]})}}
after the
\hyperref[event-end]{\texttt{\textquotesingle{}end\textquotesingle{}}}
event has been emitted will return \texttt{null}. No runtime error will
be raised.

\subparagraph{\texorpdfstring{\texttt{readable.readable}}{readable.readable}}\label{readable.readable}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Is \texttt{true} if it is safe to call
\hyperref[readablereadsize]{\texttt{readable.read()}}, which means the
stream has not been destroyed or emitted
\texttt{\textquotesingle{}error\textquotesingle{}} or
\texttt{\textquotesingle{}end\textquotesingle{}}.

\subparagraph{\texorpdfstring{\texttt{readable.readableAborted}}{readable.readableAborted}}\label{readable.readableaborted}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Returns whether the stream was destroyed or errored before emitting
\texttt{\textquotesingle{}end\textquotesingle{}}.

\subparagraph{\texorpdfstring{\texttt{readable.readableDidRead}}{readable.readableDidRead}}\label{readable.readabledidread}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Returns whether \texttt{\textquotesingle{}data\textquotesingle{}} has
been emitted.

\subparagraph{\texorpdfstring{\texttt{readable.readableEncoding}}{readable.readableEncoding}}\label{readable.readableencoding}

\begin{itemize}
\tightlist
\item
  \{null\textbar string\}
\end{itemize}

Getter for the property \texttt{encoding} of a given \texttt{Readable}
stream. The \texttt{encoding} property can be set using the
\hyperref[readablesetencodingencoding]{\texttt{readable.setEncoding()}}
method.

\subparagraph{\texorpdfstring{\texttt{readable.readableEnded}}{readable.readableEnded}}\label{readable.readableended}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Becomes \texttt{true} when
\hyperref[event-end]{\texttt{\textquotesingle{}end\textquotesingle{}}}
event is emitted.

\subparagraph{\texorpdfstring{\texttt{readable.errored}}{readable.errored}}\label{readable.errored}

\begin{itemize}
\tightlist
\item
  \{Error\}
\end{itemize}

Returns error if the stream has been destroyed with an error.

\subparagraph{\texorpdfstring{\texttt{readable.readableFlowing}}{readable.readableFlowing}}\label{readable.readableflowing}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

This property reflects the current state of a \texttt{Readable} stream
as described in the \hyperref[three-states]{Three states} section.

\subparagraph{\texorpdfstring{\texttt{readable.readableHighWaterMark}}{readable.readableHighWaterMark}}\label{readable.readablehighwatermark}

\begin{itemize}
\tightlist
\item
  \{number\}
\end{itemize}

Returns the value of \texttt{highWaterMark} passed when creating this
\texttt{Readable}.

\subparagraph{\texorpdfstring{\texttt{readable.readableLength}}{readable.readableLength}}\label{readable.readablelength}

\begin{itemize}
\tightlist
\item
  \{number\}
\end{itemize}

This property contains the number of bytes (or objects) in the queue
ready to be read. The value provides introspection data regarding the
status of the \texttt{highWaterMark}.

\subparagraph{\texorpdfstring{\texttt{readable.readableObjectMode}}{readable.readableObjectMode}}\label{readable.readableobjectmode}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Getter for the property \texttt{objectMode} of a given \texttt{Readable}
stream.

\subparagraph{\texorpdfstring{\texttt{readable.resume()}}{readable.resume()}}\label{readable.resume}

\begin{itemize}
\tightlist
\item
  Returns: \{this\}
\end{itemize}

The \texttt{readable.resume()} method causes an explicitly paused
\texttt{Readable} stream to resume emitting
\hyperref[event-data]{\texttt{\textquotesingle{}data\textquotesingle{}}}
events, switching the stream into flowing mode.

The \texttt{readable.resume()} method can be used to fully consume the
data from a stream without actually processing any of that data:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{getReadableStreamSomehow}\NormalTok{()}
  \OperatorTok{.}\FunctionTok{resume}\NormalTok{()}
  \OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}end\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Reached the end, but did not read anything.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The \texttt{readable.resume()} method has no effect if there is a
\texttt{\textquotesingle{}readable\textquotesingle{}} event listener.

\subparagraph{\texorpdfstring{\texttt{readable.setEncoding(encoding)}}{readable.setEncoding(encoding)}}\label{readable.setencodingencoding}

\begin{itemize}
\tightlist
\item
  \texttt{encoding} \{string\} The encoding to use.
\item
  Returns: \{this\}
\end{itemize}

The \texttt{readable.setEncoding()} method sets the character encoding
for data read from the \texttt{Readable} stream.

By default, no encoding is assigned and stream data will be returned as
\texttt{Buffer} objects. Setting an encoding causes the stream data to
be returned as strings of the specified encoding rather than as
\texttt{Buffer} objects. For instance, calling
\texttt{readable.setEncoding(\textquotesingle{}utf8\textquotesingle{})}
will cause the output data to be interpreted as UTF-8 data, and passed
as strings. Calling
\texttt{readable.setEncoding(\textquotesingle{}hex\textquotesingle{})}
will cause the data to be encoded in hexadecimal string format.

The \texttt{Readable} stream will properly handle multi-byte characters
delivered through the stream that would otherwise become improperly
decoded if simply pulled from the stream as \texttt{Buffer} objects.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ readable }\OperatorTok{=} \FunctionTok{getReadableStreamSomehow}\NormalTok{()}\OperatorTok{;}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{setEncoding}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}data\textquotesingle{}}\OperatorTok{,}\NormalTok{ (chunk) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  assert}\OperatorTok{.}\FunctionTok{equal}\NormalTok{(}\KeywordTok{typeof}\NormalTok{ chunk}\OperatorTok{,} \StringTok{\textquotesingle{}string\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Got \%d characters of string data:\textquotesingle{}}\OperatorTok{,}\NormalTok{ chunk}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable.unpipe({[}destination{]})}}{readable.unpipe({[}destination{]})}}\label{readable.unpipedestination}

\begin{itemize}
\tightlist
\item
  \texttt{destination} \{stream.Writable\} Optional specific stream to
  unpipe
\item
  Returns: \{this\}
\end{itemize}

The \texttt{readable.unpipe()} method detaches a \texttt{Writable}
stream previously attached using the
\hyperref[readablepipedestination-options]{\texttt{stream.pipe()}}
method.

If the \texttt{destination} is not specified, then \emph{all} pipes are
detached.

If the \texttt{destination} is specified, but no pipe is set up for it,
then the method does nothing.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ readable }\OperatorTok{=} \FunctionTok{getReadableStreamSomehow}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ writable }\OperatorTok{=}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}file.txt\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// All the data from readable goes into \textquotesingle{}file.txt\textquotesingle{},}
\CommentTok{// but only for the first second.}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{pipe}\NormalTok{(writable)}\OperatorTok{;}
\PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Stop writing to file.txt.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  readable}\OperatorTok{.}\FunctionTok{unpipe}\NormalTok{(writable)}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Manually close the file stream.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  writable}\OperatorTok{.}\FunctionTok{end}\NormalTok{()}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{,} \DecValTok{1000}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable.unshift(chunk{[},\ encoding{]})}}{readable.unshift(chunk{[}, encoding{]})}}\label{readable.unshiftchunk-encoding}

\begin{itemize}
\tightlist
\item
  \texttt{chunk}
  \{Buffer\textbar Uint8Array\textbar string\textbar null\textbar any\}
  Chunk of data to unshift onto the read queue. For streams not
  operating in object mode, \texttt{chunk} must be a string,
  \texttt{Buffer}, \texttt{Uint8Array}, or \texttt{null}. For object
  mode streams, \texttt{chunk} may be any JavaScript value.
\item
  \texttt{encoding} \{string\} Encoding of string chunks. Must be a
  valid \texttt{Buffer} encoding, such as
  \texttt{\textquotesingle{}utf8\textquotesingle{}} or
  \texttt{\textquotesingle{}ascii\textquotesingle{}}.
\end{itemize}

Passing \texttt{chunk} as \texttt{null} signals the end of the stream
(EOF) and behaves the same as \texttt{readable.push(null)}, after which
no more data can be written. The EOF signal is put at the end of the
buffer and any buffered data will still be flushed.

The \texttt{readable.unshift()} method pushes a chunk of data back into
the internal buffer. This is useful in certain situations where a stream
is being consumed by code that needs to ``un-consume'' some amount of
data that it has optimistically pulled out of the source, so that the
data can be passed on to some other party.

The \texttt{stream.unshift(chunk)} method cannot be called after the
\hyperref[event-end]{\texttt{\textquotesingle{}end\textquotesingle{}}}
event has been emitted or a runtime error will be thrown.

Developers using \texttt{stream.unshift()} often should consider
switching to use of a
\hyperref[class-streamtransform]{\texttt{Transform}} stream instead. See
the \hyperref[api-for-stream-implementers]{API for stream implementers}
section for more information.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Pull off a header delimited by \textbackslash{}n\textbackslash{}n.}
\CommentTok{// Use unshift() if we get too much.}
\CommentTok{// Call the callback with (error, header, stream).}
\KeywordTok{const}\NormalTok{ \{ StringDecoder \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:string\_decoder\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{function} \FunctionTok{parseHeader}\NormalTok{(stream}\OperatorTok{,}\NormalTok{ callback) \{}
\NormalTok{  stream}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}error\textquotesingle{}}\OperatorTok{,}\NormalTok{ callback)}\OperatorTok{;}
\NormalTok{  stream}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}readable\textquotesingle{}}\OperatorTok{,}\NormalTok{ onReadable)}\OperatorTok{;}
  \KeywordTok{const}\NormalTok{ decoder }\OperatorTok{=} \KeywordTok{new} \FunctionTok{StringDecoder}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
  \KeywordTok{let}\NormalTok{ header }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\OperatorTok{;}
  \KeywordTok{function} \FunctionTok{onReadable}\NormalTok{() \{}
    \KeywordTok{let}\NormalTok{ chunk}\OperatorTok{;}
    \ControlFlowTok{while}\NormalTok{ (}\KeywordTok{null} \OperatorTok{!==}\NormalTok{ (chunk }\OperatorTok{=}\NormalTok{ stream}\OperatorTok{.}\FunctionTok{read}\NormalTok{())) \{}
      \KeywordTok{const}\NormalTok{ str }\OperatorTok{=}\NormalTok{ decoder}\OperatorTok{.}\FunctionTok{write}\NormalTok{(chunk)}\OperatorTok{;}
      \ControlFlowTok{if}\NormalTok{ (str}\OperatorTok{.}\FunctionTok{includes}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)) \{}
        \CommentTok{// Found the header boundary.}
        \KeywordTok{const}\NormalTok{ split }\OperatorTok{=}\NormalTok{ str}\OperatorTok{.}\FunctionTok{split}\NormalTok{(}\SpecialStringTok{/}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\SpecialStringTok{/}\NormalTok{)}\OperatorTok{;}
\NormalTok{        header }\OperatorTok{+=}\NormalTok{ split}\OperatorTok{.}\FunctionTok{shift}\NormalTok{()}\OperatorTok{;}
        \KeywordTok{const}\NormalTok{ remaining }\OperatorTok{=}\NormalTok{ split}\OperatorTok{.}\FunctionTok{join}\NormalTok{(}\StringTok{\textquotesingle{}}\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
        \KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(remaining}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{        stream}\OperatorTok{.}\FunctionTok{removeListener}\NormalTok{(}\StringTok{\textquotesingle{}error\textquotesingle{}}\OperatorTok{,}\NormalTok{ callback)}\OperatorTok{;}
        \CommentTok{// Remove the \textquotesingle{}readable\textquotesingle{} listener before unshifting.}
\NormalTok{        stream}\OperatorTok{.}\FunctionTok{removeListener}\NormalTok{(}\StringTok{\textquotesingle{}readable\textquotesingle{}}\OperatorTok{,}\NormalTok{ onReadable)}\OperatorTok{;}
        \ControlFlowTok{if}\NormalTok{ (buf}\OperatorTok{.}\AttributeTok{length}\NormalTok{)}
\NormalTok{          stream}\OperatorTok{.}\FunctionTok{unshift}\NormalTok{(buf)}\OperatorTok{;}
        \CommentTok{// Now the body of the message can be read from the stream.}
        \FunctionTok{callback}\NormalTok{(}\KeywordTok{null}\OperatorTok{,}\NormalTok{ header}\OperatorTok{,}\NormalTok{ stream)}\OperatorTok{;}
        \ControlFlowTok{return}\OperatorTok{;}
\NormalTok{      \}}
      \CommentTok{// Still reading the header.}
\NormalTok{      header }\OperatorTok{+=}\NormalTok{ str}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Unlike
\hyperref[readablepushchunk-encoding]{\texttt{stream.push(chunk)}},
\texttt{stream.unshift(chunk)} will not end the reading process by
resetting the internal reading state of the stream. This can cause
unexpected results if \texttt{readable.unshift()} is called during a
read (i.e.~from within a
\hyperref[readable_readsize]{\texttt{stream.\_read()}} implementation on
a custom stream). Following the call to \texttt{readable.unshift()} with
an immediate
\hyperref[readablepushchunk-encoding]{\texttt{stream.push(\textquotesingle{}\textquotesingle{})}}
will reset the reading state appropriately, however it is best to simply
avoid calling \texttt{readable.unshift()} while in the process of
performing a read.

\subparagraph{\texorpdfstring{\texttt{readable.wrap(stream)}}{readable.wrap(stream)}}\label{readable.wrapstream}

\begin{itemize}
\tightlist
\item
  \texttt{stream} \{Stream\} An ``old style'' readable stream
\item
  Returns: \{this\}
\end{itemize}

Prior to Node.js 0.10, streams did not implement the entire
\texttt{node:stream} module API as it is currently defined. (See
\hyperref[compatibility-with-older-nodejs-versions]{Compatibility} for
more information.)

When using an older Node.js library that emits
\hyperref[event-data]{\texttt{\textquotesingle{}data\textquotesingle{}}}
events and has a \hyperref[readablepause]{\texttt{stream.pause()}}
method that is advisory only, the \texttt{readable.wrap()} method can be
used to create a \hyperref[class-streamreadable]{\texttt{Readable}}
stream that uses the old stream as its data source.

It will rarely be necessary to use \texttt{readable.wrap()} but the
method has been provided as a convenience for interacting with older
Node.js applications and libraries.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ OldReader \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}./old{-}api{-}module.js\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ \{ Readable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ oreader }\OperatorTok{=} \KeywordTok{new} \FunctionTok{OldReader}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ myReader }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Readable}\NormalTok{()}\OperatorTok{.}\FunctionTok{wrap}\NormalTok{(oreader)}\OperatorTok{;}

\NormalTok{myReader}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}readable\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  myReader}\OperatorTok{.}\FunctionTok{read}\NormalTok{()}\OperatorTok{;} \CommentTok{// etc.}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable{[}Symbol.asyncIterator{]}()}}{readable{[}Symbol.asyncIterator{]}()}}\label{readablesymbol.asynciterator}

\begin{itemize}
\tightlist
\item
  Returns: \{AsyncIterator\} to fully consume the stream.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{async} \KeywordTok{function} \FunctionTok{print}\NormalTok{(readable) \{}
\NormalTok{  readable}\OperatorTok{.}\FunctionTok{setEncoding}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
  \KeywordTok{let}\NormalTok{ data }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\OperatorTok{;}
  \ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ readable) \{}
\NormalTok{    data }\OperatorTok{+=}\NormalTok{ chunk}\OperatorTok{;}
\NormalTok{  \}}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(data)}\OperatorTok{;}
\NormalTok{\}}

\FunctionTok{print}\NormalTok{(fs}\OperatorTok{.}\FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}file\textquotesingle{}}\NormalTok{))}\OperatorTok{.}\FunctionTok{catch}\NormalTok{(}\BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

If the loop terminates with a \texttt{break}, \texttt{return}, or a
\texttt{throw}, the stream will be destroyed. In other terms, iterating
over a stream will consume the stream fully. The stream will be read in
chunks of size equal to the \texttt{highWaterMark} option. In the code
example above, data will be in a single chunk if the file has less then
64 KiB of data because no \texttt{highWaterMark} option is provided to
\href{fs.md\#fscreatereadstreampath-options}{\texttt{fs.createReadStream()}}.

\subparagraph{\texorpdfstring{\texttt{readable{[}Symbol.asyncDispose{]}()}}{readable{[}Symbol.asyncDispose{]}()}}\label{readablesymbol.asyncdispose}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

Calls \hyperref[readabledestroyerror]{\texttt{readable.destroy()}} with
an \texttt{AbortError} and returns a promise that fulfills when the
stream is finished.

\subparagraph{\texorpdfstring{\texttt{readable.compose(stream{[},\ options{]})}}{readable.compose(stream{[}, options{]})}}\label{readable.composestream-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{stream}
  \{Stream\textbar Iterable\textbar AsyncIterable\textbar Function\}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{signal} \{AbortSignal\} allows destroying the stream if the
    signal is aborted.
  \end{itemize}
\item
  Returns: \{Duplex\} a stream composed with the stream \texttt{stream}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Readable \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}

\KeywordTok{async} \KeywordTok{function}\OperatorTok{*} \FunctionTok{splitToWords}\NormalTok{(source) \{}
  \ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ source) \{}
    \KeywordTok{const}\NormalTok{ words }\OperatorTok{=} \BuiltInTok{String}\NormalTok{(chunk)}\OperatorTok{.}\FunctionTok{split}\NormalTok{(}\StringTok{\textquotesingle{} \textquotesingle{}}\NormalTok{)}\OperatorTok{;}

    \ControlFlowTok{for}\NormalTok{ (}\KeywordTok{const}\NormalTok{ word }\KeywordTok{of}\NormalTok{ words) \{}
      \KeywordTok{yield}\NormalTok{ word}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}

\KeywordTok{const}\NormalTok{ wordsStream }\OperatorTok{=}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\StringTok{\textquotesingle{}this is\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}compose as operator\textquotesingle{}}\NormalTok{])}\OperatorTok{.}\FunctionTok{compose}\NormalTok{(splitToWords)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ words }\OperatorTok{=} \ControlFlowTok{await}\NormalTok{ wordsStream}\OperatorTok{.}\FunctionTok{toArray}\NormalTok{()}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(words)}\OperatorTok{;} \CommentTok{// prints [\textquotesingle{}this\textquotesingle{}, \textquotesingle{}is\textquotesingle{}, \textquotesingle{}compose\textquotesingle{}, \textquotesingle{}as\textquotesingle{}, \textquotesingle{}operator\textquotesingle{}]}
\end{Highlighting}
\end{Shaded}

See \hyperref[streamcomposestreams]{\texttt{stream.compose}} for more
information.

\subparagraph{\texorpdfstring{\texttt{readable.iterator({[}options{]})}}{readable.iterator({[}options{]})}}\label{readable.iteratoroptions}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{destroyOnReturn} \{boolean\} When set to \texttt{false},
    calling \texttt{return} on the async iterator, or exiting a
    \texttt{for\ await...of} iteration using a \texttt{break},
    \texttt{return}, or \texttt{throw} will not destroy the stream.
    \textbf{Default:} \texttt{true}.
  \end{itemize}
\item
  Returns: \{AsyncIterator\} to consume the stream.
\end{itemize}

The iterator created by this method gives users the option to cancel the
destruction of the stream if the \texttt{for\ await...of} loop is exited
by \texttt{return}, \texttt{break}, or \texttt{throw}, or if the
iterator should destroy the stream if the stream emitted an error during
iteration.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Readable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{async} \KeywordTok{function} \FunctionTok{printIterator}\NormalTok{(readable) \{}
  \ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ readable}\OperatorTok{.}\FunctionTok{iterator}\NormalTok{(\{ }\DataTypeTok{destroyOnReturn}\OperatorTok{:} \KeywordTok{false}\NormalTok{ \})) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(chunk)}\OperatorTok{;} \CommentTok{// 1}
    \ControlFlowTok{break}\OperatorTok{;}
\NormalTok{  \}}

  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(readable}\OperatorTok{.}\AttributeTok{destroyed}\NormalTok{)}\OperatorTok{;} \CommentTok{// false}

  \ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ readable}\OperatorTok{.}\FunctionTok{iterator}\NormalTok{(\{ }\DataTypeTok{destroyOnReturn}\OperatorTok{:} \KeywordTok{false}\NormalTok{ \})) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(chunk)}\OperatorTok{;} \CommentTok{// Will print 2 and then 3}
\NormalTok{  \}}

  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(readable}\OperatorTok{.}\AttributeTok{destroyed}\NormalTok{)}\OperatorTok{;} \CommentTok{// True, stream was totally consumed}
\NormalTok{\}}

\KeywordTok{async} \KeywordTok{function} \FunctionTok{printSymbolAsyncIterator}\NormalTok{(readable) \{}
  \ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ readable) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(chunk)}\OperatorTok{;} \CommentTok{// 1}
    \ControlFlowTok{break}\OperatorTok{;}
\NormalTok{  \}}

  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(readable}\OperatorTok{.}\AttributeTok{destroyed}\NormalTok{)}\OperatorTok{;} \CommentTok{// true}
\NormalTok{\}}

\KeywordTok{async} \KeywordTok{function} \FunctionTok{showBoth}\NormalTok{() \{}
  \ControlFlowTok{await} \FunctionTok{printIterator}\NormalTok{(Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\NormalTok{]))}\OperatorTok{;}
  \ControlFlowTok{await} \FunctionTok{printSymbolAsyncIterator}\NormalTok{(Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\NormalTok{]))}\OperatorTok{;}
\NormalTok{\}}

\FunctionTok{showBoth}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable.map(fn{[},\ options{]})}}{readable.map(fn{[}, options{]})}}\label{readable.mapfn-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{fn} \{Function\textbar AsyncFunction\} a function to map over
  every chunk in the stream.

  \begin{itemize}
  \tightlist
  \item
    \texttt{data} \{any\} a chunk of data from the stream.
  \item
    \texttt{options} \{Object\}

    \begin{itemize}
    \tightlist
    \item
      \texttt{signal} \{AbortSignal\} aborted if the stream is destroyed
      allowing to abort the \texttt{fn} call early.
    \end{itemize}
  \end{itemize}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{concurrency} \{number\} the maximum concurrent invocation of
    \texttt{fn} to call on the stream at once. \textbf{Default:}
    \texttt{1}.
  \item
    \texttt{highWaterMark} \{number\} how many items to buffer while
    waiting for user consumption of the mapped items. \textbf{Default:}
    \texttt{concurrency\ *\ 2\ -\ 1}.
  \item
    \texttt{signal} \{AbortSignal\} allows destroying the stream if the
    signal is aborted.
  \end{itemize}
\item
  Returns: \{Readable\} a stream mapped with the function \texttt{fn}.
\end{itemize}

This method allows mapping over the stream. The \texttt{fn} function
will be called for every chunk in the stream. If the \texttt{fn}
function returns a promise - that promise will be \texttt{await}ed
before being passed to the result stream.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Readable \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ Resolver \} }\ImportTok{from} \StringTok{\textquotesingle{}node:dns/promises\textquotesingle{}}\OperatorTok{;}

\CommentTok{// With a synchronous mapper.}
\ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{.}\FunctionTok{map}\NormalTok{((x) }\KeywordTok{=\textgreater{}}\NormalTok{ x }\OperatorTok{*} \DecValTok{2}\NormalTok{)) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(chunk)}\OperatorTok{;} \CommentTok{// 2, 4, 6, 8}
\NormalTok{\}}
\CommentTok{// With an asynchronous mapper, making at most 2 queries at a time.}
\KeywordTok{const}\NormalTok{ resolver }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Resolver}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ dnsResults }\OperatorTok{=}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}
  \StringTok{\textquotesingle{}nodejs.org\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}openjsf.org\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}www.linuxfoundation.org\textquotesingle{}}\OperatorTok{,}
\NormalTok{])}\OperatorTok{.}\FunctionTok{map}\NormalTok{((domain) }\KeywordTok{=\textgreater{}}\NormalTok{ resolver}\OperatorTok{.}\FunctionTok{resolve4}\NormalTok{(domain)}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{concurrency}\OperatorTok{:} \DecValTok{2}\NormalTok{ \})}\OperatorTok{;}
\ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ result }\KeywordTok{of}\NormalTok{ dnsResults) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(result)}\OperatorTok{;} \CommentTok{// Logs the DNS result of resolver.resolve4.}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable.filter(fn{[},\ options{]})}}{readable.filter(fn{[}, options{]})}}\label{readable.filterfn-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{fn} \{Function\textbar AsyncFunction\} a function to filter
  chunks from the stream.

  \begin{itemize}
  \tightlist
  \item
    \texttt{data} \{any\} a chunk of data from the stream.
  \item
    \texttt{options} \{Object\}

    \begin{itemize}
    \tightlist
    \item
      \texttt{signal} \{AbortSignal\} aborted if the stream is destroyed
      allowing to abort the \texttt{fn} call early.
    \end{itemize}
  \end{itemize}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{concurrency} \{number\} the maximum concurrent invocation of
    \texttt{fn} to call on the stream at once. \textbf{Default:}
    \texttt{1}.
  \item
    \texttt{highWaterMark} \{number\} how many items to buffer while
    waiting for user consumption of the filtered items.
    \textbf{Default:} \texttt{concurrency\ *\ 2\ -\ 1}.
  \item
    \texttt{signal} \{AbortSignal\} allows destroying the stream if the
    signal is aborted.
  \end{itemize}
\item
  Returns: \{Readable\} a stream filtered with the predicate
  \texttt{fn}.
\end{itemize}

This method allows filtering the stream. For each chunk in the stream
the \texttt{fn} function will be called and if it returns a truthy
value, the chunk will be passed to the result stream. If the \texttt{fn}
function returns a promise - that promise will be \texttt{await}ed.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Readable \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ Resolver \} }\ImportTok{from} \StringTok{\textquotesingle{}node:dns/promises\textquotesingle{}}\OperatorTok{;}

\CommentTok{// With a synchronous predicate.}
\ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{.}\FunctionTok{filter}\NormalTok{((x) }\KeywordTok{=\textgreater{}}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{2}\NormalTok{)) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(chunk)}\OperatorTok{;} \CommentTok{// 3, 4}
\NormalTok{\}}
\CommentTok{// With an asynchronous predicate, making at most 2 queries at a time.}
\KeywordTok{const}\NormalTok{ resolver }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Resolver}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ dnsResults }\OperatorTok{=}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}
  \StringTok{\textquotesingle{}nodejs.org\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}openjsf.org\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}www.linuxfoundation.org\textquotesingle{}}\OperatorTok{,}
\NormalTok{])}\OperatorTok{.}\FunctionTok{filter}\NormalTok{(}\KeywordTok{async}\NormalTok{ (domain) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{const}\NormalTok{ \{ address \} }\OperatorTok{=} \ControlFlowTok{await}\NormalTok{ resolver}\OperatorTok{.}\FunctionTok{resolve4}\NormalTok{(domain}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{ttl}\OperatorTok{:} \KeywordTok{true}\NormalTok{ \})}\OperatorTok{;}
  \ControlFlowTok{return}\NormalTok{ address}\OperatorTok{.}\AttributeTok{ttl} \OperatorTok{\textgreater{}} \DecValTok{60}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{concurrency}\OperatorTok{:} \DecValTok{2}\NormalTok{ \})}\OperatorTok{;}
\ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ result }\KeywordTok{of}\NormalTok{ dnsResults) \{}
  \CommentTok{// Logs domains with more than 60 seconds on the resolved dns record.}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(result)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable.forEach(fn{[},\ options{]})}}{readable.forEach(fn{[}, options{]})}}\label{readable.foreachfn-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{fn} \{Function\textbar AsyncFunction\} a function to call on
  each chunk of the stream.

  \begin{itemize}
  \tightlist
  \item
    \texttt{data} \{any\} a chunk of data from the stream.
  \item
    \texttt{options} \{Object\}

    \begin{itemize}
    \tightlist
    \item
      \texttt{signal} \{AbortSignal\} aborted if the stream is destroyed
      allowing to abort the \texttt{fn} call early.
    \end{itemize}
  \end{itemize}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{concurrency} \{number\} the maximum concurrent invocation of
    \texttt{fn} to call on the stream at once. \textbf{Default:}
    \texttt{1}.
  \item
    \texttt{signal} \{AbortSignal\} allows destroying the stream if the
    signal is aborted.
  \end{itemize}
\item
  Returns: \{Promise\} a promise for when the stream has finished.
\end{itemize}

This method allows iterating a stream. For each chunk in the stream the
\texttt{fn} function will be called. If the \texttt{fn} function returns
a promise - that promise will be \texttt{await}ed.

This method is different from \texttt{for\ await...of} loops in that it
can optionally process chunks concurrently. In addition, a
\texttt{forEach} iteration can only be stopped by having passed a
\texttt{signal} option and aborting the related \texttt{AbortController}
while \texttt{for\ await...of} can be stopped with \texttt{break} or
\texttt{return}. In either case the stream will be destroyed.

This method is different from listening to the
\hyperref[event-data]{\texttt{\textquotesingle{}data\textquotesingle{}}}
event in that it uses the
\hyperref[class-streamreadable]{\texttt{readable}} event in the
underlying machinary and can limit the number of concurrent \texttt{fn}
calls.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Readable \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ Resolver \} }\ImportTok{from} \StringTok{\textquotesingle{}node:dns/promises\textquotesingle{}}\OperatorTok{;}

\CommentTok{// With a synchronous predicate.}
\ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{.}\FunctionTok{filter}\NormalTok{((x) }\KeywordTok{=\textgreater{}}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{2}\NormalTok{)) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(chunk)}\OperatorTok{;} \CommentTok{// 3, 4}
\NormalTok{\}}
\CommentTok{// With an asynchronous predicate, making at most 2 queries at a time.}
\KeywordTok{const}\NormalTok{ resolver }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Resolver}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ dnsResults }\OperatorTok{=}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}
  \StringTok{\textquotesingle{}nodejs.org\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}openjsf.org\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}www.linuxfoundation.org\textquotesingle{}}\OperatorTok{,}
\NormalTok{])}\OperatorTok{.}\FunctionTok{map}\NormalTok{(}\KeywordTok{async}\NormalTok{ (domain) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{const}\NormalTok{ \{ address \} }\OperatorTok{=} \ControlFlowTok{await}\NormalTok{ resolver}\OperatorTok{.}\FunctionTok{resolve4}\NormalTok{(domain}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{ttl}\OperatorTok{:} \KeywordTok{true}\NormalTok{ \})}\OperatorTok{;}
  \ControlFlowTok{return}\NormalTok{ address}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{concurrency}\OperatorTok{:} \DecValTok{2}\NormalTok{ \})}\OperatorTok{;}
\ControlFlowTok{await}\NormalTok{ dnsResults}\OperatorTok{.}\FunctionTok{forEach}\NormalTok{((result) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \CommentTok{// Logs result, similar to \textasciigrave{}for await (const result of dnsResults)\textasciigrave{}}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(result)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}done\textquotesingle{}}\NormalTok{)}\OperatorTok{;} \CommentTok{// Stream has finished}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable.toArray({[}options{]})}}{readable.toArray({[}options{]})}}\label{readable.toarrayoptions}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{signal} \{AbortSignal\} allows cancelling the toArray
    operation if the signal is aborted.
  \end{itemize}
\item
  Returns: \{Promise\} a promise containing an array with the contents
  of the stream.
\end{itemize}

This method allows easily obtaining the contents of a stream.

As this method reads the entire stream into memory, it negates the
benefits of streams. It's intended for interoperability and convenience,
not as the primary way to consume streams.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Readable \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ Resolver \} }\ImportTok{from} \StringTok{\textquotesingle{}node:dns/promises\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{.}\FunctionTok{toArray}\NormalTok{()}\OperatorTok{;} \CommentTok{// [1, 2, 3, 4]}

\CommentTok{// Make dns queries concurrently using .map and collect}
\CommentTok{// the results into an array using toArray}
\KeywordTok{const}\NormalTok{ dnsResults }\OperatorTok{=} \ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}
  \StringTok{\textquotesingle{}nodejs.org\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}openjsf.org\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}www.linuxfoundation.org\textquotesingle{}}\OperatorTok{,}
\NormalTok{])}\OperatorTok{.}\FunctionTok{map}\NormalTok{(}\KeywordTok{async}\NormalTok{ (domain) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{const}\NormalTok{ \{ address \} }\OperatorTok{=} \ControlFlowTok{await}\NormalTok{ resolver}\OperatorTok{.}\FunctionTok{resolve4}\NormalTok{(domain}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{ttl}\OperatorTok{:} \KeywordTok{true}\NormalTok{ \})}\OperatorTok{;}
  \ControlFlowTok{return}\NormalTok{ address}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{concurrency}\OperatorTok{:} \DecValTok{2}\NormalTok{ \})}\OperatorTok{.}\FunctionTok{toArray}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable.some(fn{[},\ options{]})}}{readable.some(fn{[}, options{]})}}\label{readable.somefn-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{fn} \{Function\textbar AsyncFunction\} a function to call on
  each chunk of the stream.

  \begin{itemize}
  \tightlist
  \item
    \texttt{data} \{any\} a chunk of data from the stream.
  \item
    \texttt{options} \{Object\}

    \begin{itemize}
    \tightlist
    \item
      \texttt{signal} \{AbortSignal\} aborted if the stream is destroyed
      allowing to abort the \texttt{fn} call early.
    \end{itemize}
  \end{itemize}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{concurrency} \{number\} the maximum concurrent invocation of
    \texttt{fn} to call on the stream at once. \textbf{Default:}
    \texttt{1}.
  \item
    \texttt{signal} \{AbortSignal\} allows destroying the stream if the
    signal is aborted.
  \end{itemize}
\item
  Returns: \{Promise\} a promise evaluating to \texttt{true} if
  \texttt{fn} returned a truthy value for at least one of the chunks.
\end{itemize}

This method is similar to \texttt{Array.prototype.some} and calls
\texttt{fn} on each chunk in the stream until the awaited return value
is \texttt{true} (or any truthy value). Once an \texttt{fn} call on a
chunk awaited return value is truthy, the stream is destroyed and the
promise is fulfilled with \texttt{true}. If none of the \texttt{fn}
calls on the chunks return a truthy value, the promise is fulfilled with
\texttt{false}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Readable \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ stat \} }\ImportTok{from} \StringTok{\textquotesingle{}node:fs/promises\textquotesingle{}}\OperatorTok{;}

\CommentTok{// With a synchronous predicate.}
\ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{.}\FunctionTok{some}\NormalTok{((x) }\KeywordTok{=\textgreater{}}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{2}\NormalTok{)}\OperatorTok{;} \CommentTok{// true}
\ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{.}\FunctionTok{some}\NormalTok{((x) }\KeywordTok{=\textgreater{}}\NormalTok{ x }\OperatorTok{\textless{}} \DecValTok{0}\NormalTok{)}\OperatorTok{;} \CommentTok{// false}

\CommentTok{// With an asynchronous predicate, making at most 2 file checks at a time.}
\KeywordTok{const}\NormalTok{ anyBigFile }\OperatorTok{=} \ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}
  \StringTok{\textquotesingle{}file1\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}file2\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}file3\textquotesingle{}}\OperatorTok{,}
\NormalTok{])}\OperatorTok{.}\FunctionTok{some}\NormalTok{(}\KeywordTok{async}\NormalTok{ (fileName) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{const}\NormalTok{ stats }\OperatorTok{=} \ControlFlowTok{await} \FunctionTok{stat}\NormalTok{(fileName)}\OperatorTok{;}
  \ControlFlowTok{return}\NormalTok{ stats}\OperatorTok{.}\AttributeTok{size} \OperatorTok{\textgreater{}} \DecValTok{1024} \OperatorTok{*} \DecValTok{1024}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{concurrency}\OperatorTok{:} \DecValTok{2}\NormalTok{ \})}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(anyBigFile)}\OperatorTok{;} \CommentTok{// \textasciigrave{}true\textasciigrave{} if any file in the list is bigger than 1MB}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}done\textquotesingle{}}\NormalTok{)}\OperatorTok{;} \CommentTok{// Stream has finished}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable.find(fn{[},\ options{]})}}{readable.find(fn{[}, options{]})}}\label{readable.findfn-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{fn} \{Function\textbar AsyncFunction\} a function to call on
  each chunk of the stream.

  \begin{itemize}
  \tightlist
  \item
    \texttt{data} \{any\} a chunk of data from the stream.
  \item
    \texttt{options} \{Object\}

    \begin{itemize}
    \tightlist
    \item
      \texttt{signal} \{AbortSignal\} aborted if the stream is destroyed
      allowing to abort the \texttt{fn} call early.
    \end{itemize}
  \end{itemize}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{concurrency} \{number\} the maximum concurrent invocation of
    \texttt{fn} to call on the stream at once. \textbf{Default:}
    \texttt{1}.
  \item
    \texttt{signal} \{AbortSignal\} allows destroying the stream if the
    signal is aborted.
  \end{itemize}
\item
  Returns: \{Promise\} a promise evaluating to the first chunk for which
  \texttt{fn} evaluated with a truthy value, or \texttt{undefined} if no
  element was found.
\end{itemize}

This method is similar to \texttt{Array.prototype.find} and calls
\texttt{fn} on each chunk in the stream to find a chunk with a truthy
value for \texttt{fn}. Once an \texttt{fn} call's awaited return value
is truthy, the stream is destroyed and the promise is fulfilled with
value for which \texttt{fn} returned a truthy value. If all of the
\texttt{fn} calls on the chunks return a falsy value, the promise is
fulfilled with \texttt{undefined}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Readable \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ stat \} }\ImportTok{from} \StringTok{\textquotesingle{}node:fs/promises\textquotesingle{}}\OperatorTok{;}

\CommentTok{// With a synchronous predicate.}
\ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{.}\FunctionTok{find}\NormalTok{((x) }\KeywordTok{=\textgreater{}}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{2}\NormalTok{)}\OperatorTok{;} \CommentTok{// 3}
\ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{.}\FunctionTok{find}\NormalTok{((x) }\KeywordTok{=\textgreater{}}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{)}\OperatorTok{;} \CommentTok{// 1}
\ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{.}\FunctionTok{find}\NormalTok{((x) }\KeywordTok{=\textgreater{}}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{10}\NormalTok{)}\OperatorTok{;} \CommentTok{// undefined}

\CommentTok{// With an asynchronous predicate, making at most 2 file checks at a time.}
\KeywordTok{const}\NormalTok{ foundBigFile }\OperatorTok{=} \ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}
  \StringTok{\textquotesingle{}file1\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}file2\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}file3\textquotesingle{}}\OperatorTok{,}
\NormalTok{])}\OperatorTok{.}\FunctionTok{find}\NormalTok{(}\KeywordTok{async}\NormalTok{ (fileName) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{const}\NormalTok{ stats }\OperatorTok{=} \ControlFlowTok{await} \FunctionTok{stat}\NormalTok{(fileName)}\OperatorTok{;}
  \ControlFlowTok{return}\NormalTok{ stats}\OperatorTok{.}\AttributeTok{size} \OperatorTok{\textgreater{}} \DecValTok{1024} \OperatorTok{*} \DecValTok{1024}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{concurrency}\OperatorTok{:} \DecValTok{2}\NormalTok{ \})}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(foundBigFile)}\OperatorTok{;} \CommentTok{// File name of large file, if any file in the list is bigger than 1MB}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}done\textquotesingle{}}\NormalTok{)}\OperatorTok{;} \CommentTok{// Stream has finished}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable.every(fn{[},\ options{]})}}{readable.every(fn{[}, options{]})}}\label{readable.everyfn-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{fn} \{Function\textbar AsyncFunction\} a function to call on
  each chunk of the stream.

  \begin{itemize}
  \tightlist
  \item
    \texttt{data} \{any\} a chunk of data from the stream.
  \item
    \texttt{options} \{Object\}

    \begin{itemize}
    \tightlist
    \item
      \texttt{signal} \{AbortSignal\} aborted if the stream is destroyed
      allowing to abort the \texttt{fn} call early.
    \end{itemize}
  \end{itemize}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{concurrency} \{number\} the maximum concurrent invocation of
    \texttt{fn} to call on the stream at once. \textbf{Default:}
    \texttt{1}.
  \item
    \texttt{signal} \{AbortSignal\} allows destroying the stream if the
    signal is aborted.
  \end{itemize}
\item
  Returns: \{Promise\} a promise evaluating to \texttt{true} if
  \texttt{fn} returned a truthy value for all of the chunks.
\end{itemize}

This method is similar to \texttt{Array.prototype.every} and calls
\texttt{fn} on each chunk in the stream to check if all awaited return
values are truthy value for \texttt{fn}. Once an \texttt{fn} call on a
chunk awaited return value is falsy, the stream is destroyed and the
promise is fulfilled with \texttt{false}. If all of the \texttt{fn}
calls on the chunks return a truthy value, the promise is fulfilled with
\texttt{true}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Readable \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ stat \} }\ImportTok{from} \StringTok{\textquotesingle{}node:fs/promises\textquotesingle{}}\OperatorTok{;}

\CommentTok{// With a synchronous predicate.}
\ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{.}\FunctionTok{every}\NormalTok{((x) }\KeywordTok{=\textgreater{}}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{2}\NormalTok{)}\OperatorTok{;} \CommentTok{// false}
\ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{.}\FunctionTok{every}\NormalTok{((x) }\KeywordTok{=\textgreater{}}\NormalTok{ x }\OperatorTok{\textgreater{}} \DecValTok{0}\NormalTok{)}\OperatorTok{;} \CommentTok{// true}

\CommentTok{// With an asynchronous predicate, making at most 2 file checks at a time.}
\KeywordTok{const}\NormalTok{ allBigFiles }\OperatorTok{=} \ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}
  \StringTok{\textquotesingle{}file1\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}file2\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}file3\textquotesingle{}}\OperatorTok{,}
\NormalTok{])}\OperatorTok{.}\FunctionTok{every}\NormalTok{(}\KeywordTok{async}\NormalTok{ (fileName) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{const}\NormalTok{ stats }\OperatorTok{=} \ControlFlowTok{await} \FunctionTok{stat}\NormalTok{(fileName)}\OperatorTok{;}
  \ControlFlowTok{return}\NormalTok{ stats}\OperatorTok{.}\AttributeTok{size} \OperatorTok{\textgreater{}} \DecValTok{1024} \OperatorTok{*} \DecValTok{1024}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{concurrency}\OperatorTok{:} \DecValTok{2}\NormalTok{ \})}\OperatorTok{;}
\CommentTok{// \textasciigrave{}true\textasciigrave{} if all files in the list are bigger than 1MiB}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(allBigFiles)}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}done\textquotesingle{}}\NormalTok{)}\OperatorTok{;} \CommentTok{// Stream has finished}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable.flatMap(fn{[},\ options{]})}}{readable.flatMap(fn{[}, options{]})}}\label{readable.flatmapfn-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{fn}
  \{Function\textbar AsyncGeneratorFunction\textbar AsyncFunction\} a
  function to map over every chunk in the stream.

  \begin{itemize}
  \tightlist
  \item
    \texttt{data} \{any\} a chunk of data from the stream.
  \item
    \texttt{options} \{Object\}

    \begin{itemize}
    \tightlist
    \item
      \texttt{signal} \{AbortSignal\} aborted if the stream is destroyed
      allowing to abort the \texttt{fn} call early.
    \end{itemize}
  \end{itemize}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{concurrency} \{number\} the maximum concurrent invocation of
    \texttt{fn} to call on the stream at once. \textbf{Default:}
    \texttt{1}.
  \item
    \texttt{signal} \{AbortSignal\} allows destroying the stream if the
    signal is aborted.
  \end{itemize}
\item
  Returns: \{Readable\} a stream flat-mapped with the function
  \texttt{fn}.
\end{itemize}

This method returns a new stream by applying the given callback to each
chunk of the stream and then flattening the result.

It is possible to return a stream or another iterable or async iterable
from \texttt{fn} and the result streams will be merged (flattened) into
the returned stream.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Readable \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ createReadStream \} }\ImportTok{from} \StringTok{\textquotesingle{}node:fs\textquotesingle{}}\OperatorTok{;}

\CommentTok{// With a synchronous mapper.}
\ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{.}\FunctionTok{flatMap}\NormalTok{((x) }\KeywordTok{=\textgreater{}}\NormalTok{ [x}\OperatorTok{,}\NormalTok{ x])) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(chunk)}\OperatorTok{;} \CommentTok{// 1, 1, 2, 2, 3, 3, 4, 4}
\NormalTok{\}}
\CommentTok{// With an asynchronous mapper, combine the contents of 4 files}
\KeywordTok{const}\NormalTok{ concatResult }\OperatorTok{=}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}
  \StringTok{\textquotesingle{}./1.mjs\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}./2.mjs\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}./3.mjs\textquotesingle{}}\OperatorTok{,}
  \StringTok{\textquotesingle{}./4.mjs\textquotesingle{}}\OperatorTok{,}
\NormalTok{])}\OperatorTok{.}\FunctionTok{flatMap}\NormalTok{((fileName) }\KeywordTok{=\textgreater{}} \FunctionTok{createReadStream}\NormalTok{(fileName))}\OperatorTok{;}
\ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ result }\KeywordTok{of}\NormalTok{ concatResult) \{}
  \CommentTok{// This will contain the contents (all chunks) of all 4 files}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(result)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable.drop(limit{[},\ options{]})}}{readable.drop(limit{[}, options{]})}}\label{readable.droplimit-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{limit} \{number\} the number of chunks to drop from the
  readable.
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{signal} \{AbortSignal\} allows destroying the stream if the
    signal is aborted.
  \end{itemize}
\item
  Returns: \{Readable\} a stream with \texttt{limit} chunks dropped.
\end{itemize}

This method returns a new stream with the first \texttt{limit} chunks
dropped.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Readable \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{.}\FunctionTok{drop}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{.}\FunctionTok{toArray}\NormalTok{()}\OperatorTok{;} \CommentTok{// [3, 4]}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable.take(limit{[},\ options{]})}}{readable.take(limit{[}, options{]})}}\label{readable.takelimit-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{limit} \{number\} the number of chunks to take from the
  readable.
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{signal} \{AbortSignal\} allows destroying the stream if the
    signal is aborted.
  \end{itemize}
\item
  Returns: \{Readable\} a stream with \texttt{limit} chunks taken.
\end{itemize}

This method returns a new stream with the first \texttt{limit} chunks.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Readable \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}\DecValTok{1}\OperatorTok{,} \DecValTok{2}\OperatorTok{,} \DecValTok{3}\OperatorTok{,} \DecValTok{4}\NormalTok{])}\OperatorTok{.}\FunctionTok{take}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{.}\FunctionTok{toArray}\NormalTok{()}\OperatorTok{;} \CommentTok{// [1, 2]}
\end{Highlighting}
\end{Shaded}

\subparagraph{\texorpdfstring{\texttt{readable.reduce(fn{[},\ initial{[},\ options{]}{]})}}{readable.reduce(fn{[}, initial{[}, options{]}{]})}}\label{readable.reducefn-initial-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{fn} \{Function\textbar AsyncFunction\} a reducer function to
  call over every chunk in the stream.

  \begin{itemize}
  \tightlist
  \item
    \texttt{previous} \{any\} the value obtained from the last call to
    \texttt{fn} or the \texttt{initial} value if specified or the first
    chunk of the stream otherwise.
  \item
    \texttt{data} \{any\} a chunk of data from the stream.
  \item
    \texttt{options} \{Object\}

    \begin{itemize}
    \tightlist
    \item
      \texttt{signal} \{AbortSignal\} aborted if the stream is destroyed
      allowing to abort the \texttt{fn} call early.
    \end{itemize}
  \end{itemize}
\item
  \texttt{initial} \{any\} the initial value to use in the reduction.
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{signal} \{AbortSignal\} allows destroying the stream if the
    signal is aborted.
  \end{itemize}
\item
  Returns: \{Promise\} a promise for the final value of the reduction.
\end{itemize}

This method calls \texttt{fn} on each chunk of the stream in order,
passing it the result from the calculation on the previous element. It
returns a promise for the final value of the reduction.

If no \texttt{initial} value is supplied the first chunk of the stream
is used as the initial value. If the stream is empty, the promise is
rejected with a \texttt{TypeError} with the \texttt{ERR\_INVALID\_ARGS}
code property.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Readable \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ readdir}\OperatorTok{,}\NormalTok{ stat \} }\ImportTok{from} \StringTok{\textquotesingle{}node:fs/promises\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ join \} }\ImportTok{from} \StringTok{\textquotesingle{}node:path\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ directoryPath }\OperatorTok{=} \StringTok{\textquotesingle{}./src\textquotesingle{}}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ filesInDir }\OperatorTok{=} \ControlFlowTok{await} \FunctionTok{readdir}\NormalTok{(directoryPath)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ folderSize }\OperatorTok{=} \ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{(filesInDir)}
  \OperatorTok{.}\FunctionTok{reduce}\NormalTok{(}\KeywordTok{async}\NormalTok{ (totalSize}\OperatorTok{,}\NormalTok{ file) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
    \KeywordTok{const}\NormalTok{ \{ size \} }\OperatorTok{=} \ControlFlowTok{await} \FunctionTok{stat}\NormalTok{(}\FunctionTok{join}\NormalTok{(directoryPath}\OperatorTok{,}\NormalTok{ file))}\OperatorTok{;}
    \ControlFlowTok{return}\NormalTok{ totalSize }\OperatorTok{+}\NormalTok{ size}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(folderSize)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The reducer function iterates the stream element-by-element which means
that there is no \texttt{concurrency} parameter or parallelism. To
perform a \texttt{reduce} concurrently, you can extract the async
function to \hyperref[readablemapfn-options]{\texttt{readable.map}}
method.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Readable \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ readdir}\OperatorTok{,}\NormalTok{ stat \} }\ImportTok{from} \StringTok{\textquotesingle{}node:fs/promises\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ join \} }\ImportTok{from} \StringTok{\textquotesingle{}node:path\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ directoryPath }\OperatorTok{=} \StringTok{\textquotesingle{}./src\textquotesingle{}}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ filesInDir }\OperatorTok{=} \ControlFlowTok{await} \FunctionTok{readdir}\NormalTok{(directoryPath)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ folderSize }\OperatorTok{=} \ControlFlowTok{await}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{(filesInDir)}
  \OperatorTok{.}\FunctionTok{map}\NormalTok{((file) }\KeywordTok{=\textgreater{}} \FunctionTok{stat}\NormalTok{(}\FunctionTok{join}\NormalTok{(directoryPath}\OperatorTok{,}\NormalTok{ file))}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{concurrency}\OperatorTok{:} \DecValTok{2}\NormalTok{ \})}
  \OperatorTok{.}\FunctionTok{reduce}\NormalTok{((totalSize}\OperatorTok{,}\NormalTok{ \{ size \}) }\KeywordTok{=\textgreater{}}\NormalTok{ totalSize }\OperatorTok{+}\NormalTok{ size}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(folderSize)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Duplex and transform
streams}\label{duplex-and-transform-streams}

\paragraph{\texorpdfstring{Class:
\texttt{stream.Duplex}}{Class: stream.Duplex}}\label{class-stream.duplex}

Duplex streams are streams that implement both the
\hyperref[class-streamreadable]{\texttt{Readable}} and
\hyperref[class-streamwritable]{\texttt{Writable}} interfaces.

Examples of \texttt{Duplex} streams include:

\begin{itemize}
\tightlist
\item
  \href{net.md\#class-netsocket}{TCP sockets}
\item
  \href{zlib.md}{zlib streams}
\item
  \href{crypto.md}{crypto streams}
\end{itemize}

\subparagraph{\texorpdfstring{\texttt{duplex.allowHalfOpen}}{duplex.allowHalfOpen}}\label{duplex.allowhalfopen}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

If \texttt{false} then the stream will automatically end the writable
side when the readable side ends. Set initially by the
\texttt{allowHalfOpen} constructor option, which defaults to
\texttt{true}.

This can be changed manually to change the half-open behavior of an
existing \texttt{Duplex} stream instance, but must be changed before the
\texttt{\textquotesingle{}end\textquotesingle{}} event is emitted.

\paragraph{\texorpdfstring{Class:
\texttt{stream.Transform}}{Class: stream.Transform}}\label{class-stream.transform}

Transform streams are \hyperref[class-streamduplex]{\texttt{Duplex}}
streams where the output is in some way related to the input. Like all
\hyperref[class-streamduplex]{\texttt{Duplex}} streams,
\texttt{Transform} streams implement both the
\hyperref[class-streamreadable]{\texttt{Readable}} and
\hyperref[class-streamwritable]{\texttt{Writable}} interfaces.

Examples of \texttt{Transform} streams include:

\begin{itemize}
\tightlist
\item
  \href{zlib.md}{zlib streams}
\item
  \href{crypto.md}{crypto streams}
\end{itemize}

\subparagraph{\texorpdfstring{\texttt{transform.destroy({[}error{]})}}{transform.destroy({[}error{]})}}\label{transform.destroyerror}

\begin{itemize}
\tightlist
\item
  \texttt{error} \{Error\}
\item
  Returns: \{this\}
\end{itemize}

Destroy the stream, and optionally emit an
\texttt{\textquotesingle{}error\textquotesingle{}} event. After this
call, the transform stream would release any internal resources.
Implementors should not override this method, but instead implement
\hyperref[readable_destroyerr-callback]{\texttt{readable.\_destroy()}}.
The default implementation of \texttt{\_destroy()} for
\texttt{Transform} also emit
\texttt{\textquotesingle{}close\textquotesingle{}} unless
\texttt{emitClose} is set in false.

Once \texttt{destroy()} has been called, any further calls will be a
no-op and no further errors except from \texttt{\_destroy()} may be
emitted as \texttt{\textquotesingle{}error\textquotesingle{}}.

\subsubsection{\texorpdfstring{\texttt{stream.finished(stream{[},\ options{]},\ callback)}}{stream.finished(stream{[}, options{]}, callback)}}\label{stream.finishedstream-options-callback}

\begin{itemize}
\tightlist
\item
  \texttt{stream}
  \{Stream\textbar ReadableStream\textbar WritableStream\}
\end{itemize}

A readable and/or writable stream/webstream.

\begin{itemize}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{error} \{boolean\} If set to \texttt{false}, then a call to
    \texttt{emit(\textquotesingle{}error\textquotesingle{},\ err)} is
    not treated as finished. \textbf{Default:} \texttt{true}.
  \item
    \texttt{readable} \{boolean\} When set to \texttt{false}, the
    callback will be called when the stream ends even though the stream
    might still be readable. \textbf{Default:} \texttt{true}.
  \item
    \texttt{writable} \{boolean\} When set to \texttt{false}, the
    callback will be called when the stream ends even though the stream
    might still be writable. \textbf{Default:} \texttt{true}.
  \item
    \texttt{signal} \{AbortSignal\} allows aborting the wait for the
    stream finish. The underlying stream will \emph{not} be aborted if
    the signal is aborted. The callback will get called with an
    \texttt{AbortError}. All registered listeners added by this function
    will also be removed.
  \item
    \texttt{cleanup} \{boolean\} remove all registered stream listeners.
    \textbf{Default:} \texttt{false}.
  \end{itemize}
\item
  \texttt{callback} \{Function\} A callback function that takes an
  optional error argument.
\item
  Returns: \{Function\} A cleanup function which removes all registered
  listeners.
\end{itemize}

A function to get notified when a stream is no longer readable, writable
or has experienced an error or a premature close event.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ finished \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ rs }\OperatorTok{=}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}archive.tar\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\FunctionTok{finished}\NormalTok{(rs}\OperatorTok{,}\NormalTok{ (err) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \ControlFlowTok{if}\NormalTok{ (err) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\StringTok{\textquotesingle{}Stream failed.\textquotesingle{}}\OperatorTok{,}\NormalTok{ err)}\OperatorTok{;}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Stream is done reading.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\})}\OperatorTok{;}

\NormalTok{rs}\OperatorTok{.}\FunctionTok{resume}\NormalTok{()}\OperatorTok{;} \CommentTok{// Drain the stream.}
\end{Highlighting}
\end{Shaded}

Especially useful in error handling scenarios where a stream is
destroyed prematurely (like an aborted HTTP request), and will not emit
\texttt{\textquotesingle{}end\textquotesingle{}} or
\texttt{\textquotesingle{}finish\textquotesingle{}}.

The \texttt{finished} API provides
\hyperref[streamfinishedstream-options]{promise version}.

\texttt{stream.finished()} leaves dangling event listeners (in
particular \texttt{\textquotesingle{}error\textquotesingle{}},
\texttt{\textquotesingle{}end\textquotesingle{}},
\texttt{\textquotesingle{}finish\textquotesingle{}} and
\texttt{\textquotesingle{}close\textquotesingle{}}) after
\texttt{callback} has been invoked. The reason for this is so that
unexpected \texttt{\textquotesingle{}error\textquotesingle{}} events
(due to incorrect stream implementations) do not cause unexpected
crashes. If this is unwanted behavior then the returned cleanup function
needs to be invoked in the callback:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ cleanup }\OperatorTok{=} \FunctionTok{finished}\NormalTok{(rs}\OperatorTok{,}\NormalTok{ (err) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \FunctionTok{cleanup}\NormalTok{()}\OperatorTok{;}
  \CommentTok{// ...}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{stream.pipeline(source{[},\ ...transforms{]},\ destination,\ callback)}}{stream.pipeline(source{[}, ...transforms{]}, destination, callback)}}\label{stream.pipelinesource-...transforms-destination-callback}

\subsubsection{\texorpdfstring{\texttt{stream.pipeline(streams,\ callback)}}{stream.pipeline(streams, callback)}}\label{stream.pipelinestreams-callback}

\begin{itemize}
\tightlist
\item
  \texttt{streams}
  \{Stream{[}{]}\textbar Iterable{[}{]}\textbar AsyncIterable{[}{]}\textbar Function{[}{]}\textbar{}
  ReadableStream{[}{]}\textbar WritableStream{[}{]}\textbar TransformStream{[}{]}\}
\item
  \texttt{source}
  \{Stream\textbar Iterable\textbar AsyncIterable\textbar Function\textbar ReadableStream\}

  \begin{itemize}
  \tightlist
  \item
    Returns: \{Iterable\textbar AsyncIterable\}
  \end{itemize}
\item
  \texttt{...transforms}
  \{Stream\textbar Function\textbar TransformStream\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{source} \{AsyncIterable\}
  \item
    Returns: \{AsyncIterable\}
  \end{itemize}
\item
  \texttt{destination}
  \{Stream\textbar Function\textbar WritableStream\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{source} \{AsyncIterable\}
  \item
    Returns: \{AsyncIterable\textbar Promise\}
  \end{itemize}
\item
  \texttt{callback} \{Function\} Called when the pipeline is fully done.

  \begin{itemize}
  \tightlist
  \item
    \texttt{err} \{Error\}
  \item
    \texttt{val} Resolved value of \texttt{Promise} returned by
    \texttt{destination}.
  \end{itemize}
\item
  Returns: \{Stream\}
\end{itemize}

A module method to pipe between streams and generators forwarding errors
and properly cleaning up and provide a callback when the pipeline is
complete.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ pipeline \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ zlib }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:zlib\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Use the pipeline API to easily pipe a series of streams}
\CommentTok{// together and get notified when the pipeline is fully done.}

\CommentTok{// A pipeline to gzip a potentially huge tar file efficiently:}

\FunctionTok{pipeline}\NormalTok{(}
\NormalTok{  fs}\OperatorTok{.}\FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}archive.tar\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
\NormalTok{  zlib}\OperatorTok{.}\FunctionTok{createGzip}\NormalTok{()}\OperatorTok{,}
\NormalTok{  fs}\OperatorTok{.}\FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}archive.tar.gz\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
\NormalTok{  (err) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
    \ControlFlowTok{if}\NormalTok{ (err) \{}
      \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\StringTok{\textquotesingle{}Pipeline failed.\textquotesingle{}}\OperatorTok{,}\NormalTok{ err)}\OperatorTok{;}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Pipeline succeeded.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The \texttt{pipeline} API provides a
\hyperref[streampipelinesource-transforms-destination-options]{promise
version}.

\texttt{stream.pipeline()} will call \texttt{stream.destroy(err)} on all
streams except:

\begin{itemize}
\tightlist
\item
  \texttt{Readable} streams which have emitted
  \texttt{\textquotesingle{}end\textquotesingle{}} or
  \texttt{\textquotesingle{}close\textquotesingle{}}.
\item
  \texttt{Writable} streams which have emitted
  \texttt{\textquotesingle{}finish\textquotesingle{}} or
  \texttt{\textquotesingle{}close\textquotesingle{}}.
\end{itemize}

\texttt{stream.pipeline()} leaves dangling event listeners on the
streams after the \texttt{callback} has been invoked. In the case of
reuse of streams after failure, this can cause event listener leaks and
swallowed errors. If the last stream is readable, dangling event
listeners will be removed so that the last stream can be consumed later.

\texttt{stream.pipeline()} closes all the streams when an error is
raised. The \texttt{IncomingRequest} usage with \texttt{pipeline} could
lead to an unexpected behavior once it would destroy the socket without
sending the expected response. See the example below:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ http }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:http\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ \{ pipeline \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ server }\OperatorTok{=}\NormalTok{ http}\OperatorTok{.}\FunctionTok{createServer}\NormalTok{((req}\OperatorTok{,}\NormalTok{ res) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{const}\NormalTok{ fileStream }\OperatorTok{=}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}./fileNotExist.txt\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
  \FunctionTok{pipeline}\NormalTok{(fileStream}\OperatorTok{,}\NormalTok{ res}\OperatorTok{,}\NormalTok{ (err) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
    \ControlFlowTok{if}\NormalTok{ (err) \{}
      \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(err)}\OperatorTok{;} \CommentTok{// No such file}
      \CommentTok{// this message can\textquotesingle{}t be sent once \textasciigrave{}pipeline\textasciigrave{} already destroyed the socket}
      \ControlFlowTok{return}\NormalTok{ res}\OperatorTok{.}\FunctionTok{end}\NormalTok{(}\StringTok{\textquotesingle{}error!!!\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \})}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{stream.compose(...streams)}}{stream.compose(...streams)}}\label{stream.compose...streams}

\begin{quote}
Stability: 1 - \texttt{stream.compose} is experimental.
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{streams}
  \{Stream{[}{]}\textbar Iterable{[}{]}\textbar AsyncIterable{[}{]}\textbar Function{[}{]}\textbar{}
  ReadableStream{[}{]}\textbar WritableStream{[}{]}\textbar TransformStream{[}{]}\textbar Duplex{[}{]}\textbar Function\}
\item
  Returns: \{stream.Duplex\}
\end{itemize}

Combines two or more streams into a \texttt{Duplex} stream that writes
to the first stream and reads from the last. Each provided stream is
piped into the next, using \texttt{stream.pipeline}. If any of the
streams error then all are destroyed, including the outer
\texttt{Duplex} stream.

Because \texttt{stream.compose} returns a new stream that in turn can
(and should) be piped into other streams, it enables composition. In
contrast, when passing streams to \texttt{stream.pipeline}, typically
the first stream is a readable stream and the last a writable stream,
forming a closed circuit.

If passed a \texttt{Function} it must be a factory method taking a
\texttt{source} \texttt{Iterable}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ compose}\OperatorTok{,}\NormalTok{ Transform \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ removeSpaces }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Transform}\NormalTok{(\{}
  \FunctionTok{transform}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
    \FunctionTok{callback}\NormalTok{(}\KeywordTok{null}\OperatorTok{,} \BuiltInTok{String}\NormalTok{(chunk)}\OperatorTok{.}\FunctionTok{replace}\NormalTok{(}\StringTok{\textquotesingle{} \textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}

\KeywordTok{async} \KeywordTok{function}\OperatorTok{*} \FunctionTok{toUpper}\NormalTok{(source) \{}
  \ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ source) \{}
    \KeywordTok{yield} \BuiltInTok{String}\NormalTok{(chunk)}\OperatorTok{.}\FunctionTok{toUpperCase}\NormalTok{()}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}

\KeywordTok{let}\NormalTok{ res }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\OperatorTok{;}
\ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ buf }\KeywordTok{of} \FunctionTok{compose}\NormalTok{(removeSpaces}\OperatorTok{,}\NormalTok{ toUpper)}\OperatorTok{.}\FunctionTok{end}\NormalTok{(}\StringTok{\textquotesingle{}hello world\textquotesingle{}}\NormalTok{)) \{}
\NormalTok{  res }\OperatorTok{+=}\NormalTok{ buf}\OperatorTok{;}
\NormalTok{\}}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(res)}\OperatorTok{;} \CommentTok{// prints \textquotesingle{}HELLOWORLD\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\texttt{stream.compose} can be used to convert async iterables,
generators and functions into streams.

\begin{itemize}
\tightlist
\item
  \texttt{AsyncIterable} converts into a readable \texttt{Duplex}.
  Cannot yield \texttt{null}.
\item
  \texttt{AsyncGeneratorFunction} converts into a readable/writable
  transform \texttt{Duplex}. Must take a source \texttt{AsyncIterable}
  as first parameter. Cannot yield \texttt{null}.
\item
  \texttt{AsyncFunction} converts into a writable \texttt{Duplex}. Must
  return either \texttt{null} or \texttt{undefined}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ compose \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ finished \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream/promises\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Convert AsyncIterable into readable Duplex.}
\KeywordTok{const}\NormalTok{ s1 }\OperatorTok{=} \FunctionTok{compose}\NormalTok{(}\KeywordTok{async} \KeywordTok{function}\OperatorTok{*}\NormalTok{() \{}
  \KeywordTok{yield} \StringTok{\textquotesingle{}Hello\textquotesingle{}}\OperatorTok{;}
  \KeywordTok{yield} \StringTok{\textquotesingle{}World\textquotesingle{}}\OperatorTok{;}
\NormalTok{\}())}\OperatorTok{;}

\CommentTok{// Convert AsyncGenerator into transform Duplex.}
\KeywordTok{const}\NormalTok{ s2 }\OperatorTok{=} \FunctionTok{compose}\NormalTok{(}\KeywordTok{async} \KeywordTok{function}\OperatorTok{*}\NormalTok{(source) \{}
  \ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ source) \{}
    \KeywordTok{yield} \BuiltInTok{String}\NormalTok{(chunk)}\OperatorTok{.}\FunctionTok{toUpperCase}\NormalTok{()}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\})}\OperatorTok{;}

\KeywordTok{let}\NormalTok{ res }\OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Convert AsyncFunction into writable Duplex.}
\KeywordTok{const}\NormalTok{ s3 }\OperatorTok{=} \FunctionTok{compose}\NormalTok{(}\KeywordTok{async} \KeywordTok{function}\NormalTok{(source) \{}
  \ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ source) \{}
\NormalTok{    res }\OperatorTok{+=}\NormalTok{ chunk}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\})}\OperatorTok{;}

\ControlFlowTok{await} \FunctionTok{finished}\NormalTok{(}\FunctionTok{compose}\NormalTok{(s1}\OperatorTok{,}\NormalTok{ s2}\OperatorTok{,}\NormalTok{ s3))}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(res)}\OperatorTok{;} \CommentTok{// prints \textquotesingle{}HELLOWORLD\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

See
\hyperref[readablecomposestream-options]{\texttt{readable.compose(stream)}}
for \texttt{stream.compose} as operator.

\subsubsection{\texorpdfstring{\texttt{stream.Readable.from(iterable{[},\ options{]})}}{stream.Readable.from(iterable{[}, options{]})}}\label{stream.readable.fromiterable-options}

\begin{itemize}
\tightlist
\item
  \texttt{iterable} \{Iterable\} Object implementing the
  \texttt{Symbol.asyncIterator} or \texttt{Symbol.iterator} iterable
  protocol. Emits an `error' event if a null value is passed.
\item
  \texttt{options} \{Object\} Options provided to
  \texttt{new\ stream.Readable({[}options{]})}. By default,
  \texttt{Readable.from()} will set \texttt{options.objectMode} to
  \texttt{true}, unless this is explicitly opted out by setting
  \texttt{options.objectMode} to \texttt{false}.
\item
  Returns: \{stream.Readable\}
\end{itemize}

A utility method for creating readable streams out of iterators.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Readable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{async} \KeywordTok{function} \OperatorTok{*} \FunctionTok{generate}\NormalTok{() \{}
  \KeywordTok{yield} \StringTok{\textquotesingle{}hello\textquotesingle{}}\OperatorTok{;}
  \KeywordTok{yield} \StringTok{\textquotesingle{}streams\textquotesingle{}}\OperatorTok{;}
\NormalTok{\}}

\KeywordTok{const}\NormalTok{ readable }\OperatorTok{=}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\FunctionTok{generate}\NormalTok{())}\OperatorTok{;}

\NormalTok{readable}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}data\textquotesingle{}}\OperatorTok{,}\NormalTok{ (chunk) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(chunk)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Calling \texttt{Readable.from(string)} or \texttt{Readable.from(buffer)}
will not have the strings or buffers be iterated to match the other
streams semantics for performance reasons.

If an \texttt{Iterable} object containing promises is passed as an
argument, it might result in unhandled rejection.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Readable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\NormalTok{Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}
  \KeywordTok{new} \BuiltInTok{Promise}\NormalTok{((resolve) }\KeywordTok{=\textgreater{}} \PreprocessorTok{setTimeout}\NormalTok{(}\FunctionTok{resolve}\NormalTok{(}\StringTok{\textquotesingle{}1\textquotesingle{}}\NormalTok{)}\OperatorTok{,} \DecValTok{1500}\NormalTok{))}\OperatorTok{,}
  \KeywordTok{new} \BuiltInTok{Promise}\NormalTok{((\_}\OperatorTok{,}\NormalTok{ reject) }\KeywordTok{=\textgreater{}} \PreprocessorTok{setTimeout}\NormalTok{(}\FunctionTok{reject}\NormalTok{(}\KeywordTok{new} \BuiltInTok{Error}\NormalTok{(}\StringTok{\textquotesingle{}2\textquotesingle{}}\NormalTok{))}\OperatorTok{,} \DecValTok{1000}\NormalTok{))}\OperatorTok{,} \CommentTok{// Unhandled rejection}
\NormalTok{])}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{stream.Readable.fromWeb(readableStream{[},\ options{]})}}{stream.Readable.fromWeb(readableStream{[}, options{]})}}\label{stream.readable.fromwebreadablestream-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{readableStream} \{ReadableStream\}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{encoding} \{string\}
  \item
    \texttt{highWaterMark} \{number\}
  \item
    \texttt{objectMode} \{boolean\}
  \item
    \texttt{signal} \{AbortSignal\}
  \end{itemize}
\item
  Returns: \{stream.Readable\}
\end{itemize}

\subsubsection{\texorpdfstring{\texttt{stream.Readable.isDisturbed(stream)}}{stream.Readable.isDisturbed(stream)}}\label{stream.readable.isdisturbedstream}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{stream} \{stream.Readable\textbar ReadableStream\}
\item
  Returns: \texttt{boolean}
\end{itemize}

Returns whether the stream has been read from or cancelled.

\subsubsection{\texorpdfstring{\texttt{stream.isErrored(stream)}}{stream.isErrored(stream)}}\label{stream.iserroredstream}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{stream}
  \{Readable\textbar Writable\textbar Duplex\textbar WritableStream\textbar ReadableStream\}
\item
  Returns: \{boolean\}
\end{itemize}

Returns whether the stream has encountered an error.

\subsubsection{\texorpdfstring{\texttt{stream.isReadable(stream)}}{stream.isReadable(stream)}}\label{stream.isreadablestream}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{stream} \{Readable\textbar Duplex\textbar ReadableStream\}
\item
  Returns: \{boolean\}
\end{itemize}

Returns whether the stream is readable.

\subsubsection{\texorpdfstring{\texttt{stream.Readable.toWeb(streamReadable{[},\ options{]})}}{stream.Readable.toWeb(streamReadable{[}, options{]})}}\label{stream.readable.towebstreamreadable-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{streamReadable} \{stream.Readable\}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{strategy} \{Object\}

    \begin{itemize}
    \tightlist
    \item
      \texttt{highWaterMark} \{number\} The maximum internal queue size
      (of the created \texttt{ReadableStream}) before backpressure is
      applied in reading from the given \texttt{stream.Readable}. If no
      value is provided, it will be taken from the given
      \texttt{stream.Readable}.
    \item
      \texttt{size} \{Function\} A function that size of the given chunk
      of data. If no value is provided, the size will be \texttt{1} for
      all the chunks.

      \begin{itemize}
      \tightlist
      \item
        \texttt{chunk} \{any\}
      \item
        Returns: \{number\}
      \end{itemize}
    \end{itemize}
  \end{itemize}
\item
  Returns: \{ReadableStream\}
\end{itemize}

\subsubsection{\texorpdfstring{\texttt{stream.Writable.fromWeb(writableStream{[},\ options{]})}}{stream.Writable.fromWeb(writableStream{[}, options{]})}}\label{stream.writable.fromwebwritablestream-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{writableStream} \{WritableStream\}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{decodeStrings} \{boolean\}
  \item
    \texttt{highWaterMark} \{number\}
  \item
    \texttt{objectMode} \{boolean\}
  \item
    \texttt{signal} \{AbortSignal\}
  \end{itemize}
\item
  Returns: \{stream.Writable\}
\end{itemize}

\subsubsection{\texorpdfstring{\texttt{stream.Writable.toWeb(streamWritable)}}{stream.Writable.toWeb(streamWritable)}}\label{stream.writable.towebstreamwritable}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{streamWritable} \{stream.Writable\}
\item
  Returns: \{WritableStream\}
\end{itemize}

\subsubsection{\texorpdfstring{\texttt{stream.Duplex.from(src)}}{stream.Duplex.from(src)}}\label{stream.duplex.fromsrc}

\begin{itemize}
\tightlist
\item
  \texttt{src}
  \{Stream\textbar Blob\textbar ArrayBuffer\textbar string\textbar Iterable\textbar AsyncIterable\textbar{}
  AsyncGeneratorFunction\textbar AsyncFunction\textbar Promise\textbar Object\textbar{}
  ReadableStream\textbar WritableStream\}
\end{itemize}

A utility method for creating duplex streams.

\begin{itemize}
\tightlist
\item
  \texttt{Stream} converts writable stream into writable \texttt{Duplex}
  and readable stream to \texttt{Duplex}.
\item
  \texttt{Blob} converts into readable \texttt{Duplex}.
\item
  \texttt{string} converts into readable \texttt{Duplex}.
\item
  \texttt{ArrayBuffer} converts into readable \texttt{Duplex}.
\item
  \texttt{AsyncIterable} converts into a readable \texttt{Duplex}.
  Cannot yield \texttt{null}.
\item
  \texttt{AsyncGeneratorFunction} converts into a readable/writable
  transform \texttt{Duplex}. Must take a source \texttt{AsyncIterable}
  as first parameter. Cannot yield \texttt{null}.
\item
  \texttt{AsyncFunction} converts into a writable \texttt{Duplex}. Must
  return either \texttt{null} or \texttt{undefined}
\item
  \texttt{Object\ (\{\ writable,\ readable\ \})} converts
  \texttt{readable} and \texttt{writable} into \texttt{Stream} and then
  combines them into \texttt{Duplex} where the \texttt{Duplex} will
  write to the \texttt{writable} and read from the \texttt{readable}.
\item
  \texttt{Promise} converts into readable \texttt{Duplex}. Value
  \texttt{null} is ignored.
\item
  \texttt{ReadableStream} converts into readable \texttt{Duplex}.
\item
  \texttt{WritableStream} converts into writable \texttt{Duplex}.
\item
  Returns: \{stream.Duplex\}
\end{itemize}

If an \texttt{Iterable} object containing promises is passed as an
argument, it might result in unhandled rejection.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Duplex \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\NormalTok{Duplex}\OperatorTok{.}\FunctionTok{from}\NormalTok{([}
  \KeywordTok{new} \BuiltInTok{Promise}\NormalTok{((resolve) }\KeywordTok{=\textgreater{}} \PreprocessorTok{setTimeout}\NormalTok{(}\FunctionTok{resolve}\NormalTok{(}\StringTok{\textquotesingle{}1\textquotesingle{}}\NormalTok{)}\OperatorTok{,} \DecValTok{1500}\NormalTok{))}\OperatorTok{,}
  \KeywordTok{new} \BuiltInTok{Promise}\NormalTok{((\_}\OperatorTok{,}\NormalTok{ reject) }\KeywordTok{=\textgreater{}} \PreprocessorTok{setTimeout}\NormalTok{(}\FunctionTok{reject}\NormalTok{(}\KeywordTok{new} \BuiltInTok{Error}\NormalTok{(}\StringTok{\textquotesingle{}2\textquotesingle{}}\NormalTok{))}\OperatorTok{,} \DecValTok{1000}\NormalTok{))}\OperatorTok{,} \CommentTok{// Unhandled rejection}
\NormalTok{])}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{stream.Duplex.fromWeb(pair{[},\ options{]})}}{stream.Duplex.fromWeb(pair{[}, options{]})}}\label{stream.duplex.fromwebpair-options}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{pair} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{readable} \{ReadableStream\}
  \item
    \texttt{writable} \{WritableStream\}
  \end{itemize}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{allowHalfOpen} \{boolean\}
  \item
    \texttt{decodeStrings} \{boolean\}
  \item
    \texttt{encoding} \{string\}
  \item
    \texttt{highWaterMark} \{number\}
  \item
    \texttt{objectMode} \{boolean\}
  \item
    \texttt{signal} \{AbortSignal\}
  \end{itemize}
\item
  Returns: \{stream.Duplex\}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Duplex \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{}
\NormalTok{  ReadableStream}\OperatorTok{,}
\NormalTok{  WritableStream}\OperatorTok{,}
\NormalTok{\} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream/web\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ readable }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ReadableStream}\NormalTok{(\{}
  \FunctionTok{start}\NormalTok{(controller) \{}
\NormalTok{    controller}\OperatorTok{.}\FunctionTok{enqueue}\NormalTok{(}\StringTok{\textquotesingle{}world\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ writable }\OperatorTok{=} \KeywordTok{new} \FunctionTok{WritableStream}\NormalTok{(\{}
  \FunctionTok{write}\NormalTok{(chunk) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}writable\textquotesingle{}}\OperatorTok{,}\NormalTok{ chunk)}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ pair }\OperatorTok{=}\NormalTok{ \{}
\NormalTok{  readable}\OperatorTok{,}
\NormalTok{  writable}\OperatorTok{,}
\NormalTok{\}}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ duplex }\OperatorTok{=}\NormalTok{ Duplex}\OperatorTok{.}\FunctionTok{fromWeb}\NormalTok{(pair}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{encoding}\OperatorTok{:} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\OperatorTok{,} \DataTypeTok{objectMode}\OperatorTok{:} \KeywordTok{true}\NormalTok{ \})}\OperatorTok{;}

\NormalTok{duplex}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}hello\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ duplex) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}readable\textquotesingle{}}\OperatorTok{,}\NormalTok{ chunk)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Duplex \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ \{}
\NormalTok{  ReadableStream}\OperatorTok{,}
\NormalTok{  WritableStream}\OperatorTok{,}
\NormalTok{\} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream/web\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ readable }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ReadableStream}\NormalTok{(\{}
  \FunctionTok{start}\NormalTok{(controller) \{}
\NormalTok{    controller}\OperatorTok{.}\FunctionTok{enqueue}\NormalTok{(}\StringTok{\textquotesingle{}world\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ writable }\OperatorTok{=} \KeywordTok{new} \FunctionTok{WritableStream}\NormalTok{(\{}
  \FunctionTok{write}\NormalTok{(chunk) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}writable\textquotesingle{}}\OperatorTok{,}\NormalTok{ chunk)}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ pair }\OperatorTok{=}\NormalTok{ \{}
\NormalTok{  readable}\OperatorTok{,}
\NormalTok{  writable}\OperatorTok{,}
\NormalTok{\}}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ duplex }\OperatorTok{=}\NormalTok{ Duplex}\OperatorTok{.}\FunctionTok{fromWeb}\NormalTok{(pair}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{encoding}\OperatorTok{:} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\OperatorTok{,} \DataTypeTok{objectMode}\OperatorTok{:} \KeywordTok{true}\NormalTok{ \})}\OperatorTok{;}

\NormalTok{duplex}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}hello\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{duplex}\OperatorTok{.}\FunctionTok{once}\NormalTok{(}\StringTok{\textquotesingle{}readable\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}} \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}readable\textquotesingle{}}\OperatorTok{,}\NormalTok{ duplex}\OperatorTok{.}\FunctionTok{read}\NormalTok{()))}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{stream.Duplex.toWeb(streamDuplex)}}{stream.Duplex.toWeb(streamDuplex)}}\label{stream.duplex.towebstreamduplex}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{streamDuplex} \{stream.Duplex\}
\item
  Returns: \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{readable} \{ReadableStream\}
  \item
    \texttt{writable} \{WritableStream\}
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ Duplex \} }\ImportTok{from} \StringTok{\textquotesingle{}node:stream\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ duplex }\OperatorTok{=} \FunctionTok{Duplex}\NormalTok{(\{}
  \DataTypeTok{objectMode}\OperatorTok{:} \KeywordTok{true}\OperatorTok{,}
  \FunctionTok{read}\NormalTok{() \{}
    \KeywordTok{this}\OperatorTok{.}\FunctionTok{push}\NormalTok{(}\StringTok{\textquotesingle{}world\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{this}\OperatorTok{.}\FunctionTok{push}\NormalTok{(}\KeywordTok{null}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,}
  \FunctionTok{write}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}writable\textquotesingle{}}\OperatorTok{,}\NormalTok{ chunk)}\OperatorTok{;}
    \FunctionTok{callback}\NormalTok{()}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ \{ readable}\OperatorTok{,}\NormalTok{ writable \} }\OperatorTok{=}\NormalTok{ Duplex}\OperatorTok{.}\FunctionTok{toWeb}\NormalTok{(duplex)}\OperatorTok{;}
\NormalTok{writable}\OperatorTok{.}\FunctionTok{getWriter}\NormalTok{()}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}hello\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ \{ value \} }\OperatorTok{=} \ControlFlowTok{await}\NormalTok{ readable}\OperatorTok{.}\FunctionTok{getReader}\NormalTok{()}\OperatorTok{.}\FunctionTok{read}\NormalTok{()}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}readable\textquotesingle{}}\OperatorTok{,}\NormalTok{ value)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Duplex \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ duplex }\OperatorTok{=} \FunctionTok{Duplex}\NormalTok{(\{}
  \DataTypeTok{objectMode}\OperatorTok{:} \KeywordTok{true}\OperatorTok{,}
  \FunctionTok{read}\NormalTok{() \{}
    \KeywordTok{this}\OperatorTok{.}\FunctionTok{push}\NormalTok{(}\StringTok{\textquotesingle{}world\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{this}\OperatorTok{.}\FunctionTok{push}\NormalTok{(}\KeywordTok{null}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,}
  \FunctionTok{write}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}writable\textquotesingle{}}\OperatorTok{,}\NormalTok{ chunk)}\OperatorTok{;}
    \FunctionTok{callback}\NormalTok{()}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ \{ readable}\OperatorTok{,}\NormalTok{ writable \} }\OperatorTok{=}\NormalTok{ Duplex}\OperatorTok{.}\FunctionTok{toWeb}\NormalTok{(duplex)}\OperatorTok{;}
\NormalTok{writable}\OperatorTok{.}\FunctionTok{getWriter}\NormalTok{()}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}hello\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\NormalTok{readable}\OperatorTok{.}\FunctionTok{getReader}\NormalTok{()}\OperatorTok{.}\FunctionTok{read}\NormalTok{()}\OperatorTok{.}\FunctionTok{then}\NormalTok{((result) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}readable\textquotesingle{}}\OperatorTok{,}\NormalTok{ result}\OperatorTok{.}\AttributeTok{value}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{stream.addAbortSignal(signal,\ stream)}}{stream.addAbortSignal(signal, stream)}}\label{stream.addabortsignalsignal-stream}

\begin{itemize}
\tightlist
\item
  \texttt{signal} \{AbortSignal\} A signal representing possible
  cancellation
\item
  \texttt{stream}
  \{Stream\textbar ReadableStream\textbar WritableStream\}
\end{itemize}

A stream to attach a signal to.

Attaches an AbortSignal to a readable or writeable stream. This lets
code control stream destruction using an \texttt{AbortController}.

Calling \texttt{abort} on the \texttt{AbortController} corresponding to
the passed \texttt{AbortSignal} will behave the same way as calling
\texttt{.destroy(new\ AbortError())} on the stream, and
\texttt{controller.error(new\ AbortError())} for webstreams.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ controller }\OperatorTok{=} \KeywordTok{new} \FunctionTok{AbortController}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ read }\OperatorTok{=} \FunctionTok{addAbortSignal}\NormalTok{(}
\NormalTok{  controller}\OperatorTok{.}\AttributeTok{signal}\OperatorTok{,}
\NormalTok{  fs}\OperatorTok{.}\FunctionTok{createReadStream}\NormalTok{((}\StringTok{\textquotesingle{}object.json\textquotesingle{}}\NormalTok{))}\OperatorTok{,}
\NormalTok{)}\OperatorTok{;}
\CommentTok{// Later, abort the operation closing the stream}
\NormalTok{controller}\OperatorTok{.}\FunctionTok{abort}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Or using an \texttt{AbortSignal} with a readable stream as an async
iterable:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ controller }\OperatorTok{=} \KeywordTok{new} \FunctionTok{AbortController}\NormalTok{()}\OperatorTok{;}
\PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ controller}\OperatorTok{.}\FunctionTok{abort}\NormalTok{()}\OperatorTok{,} \DecValTok{10\_000}\NormalTok{)}\OperatorTok{;} \CommentTok{// set a timeout}
\KeywordTok{const}\NormalTok{ stream }\OperatorTok{=} \FunctionTok{addAbortSignal}\NormalTok{(}
\NormalTok{  controller}\OperatorTok{.}\AttributeTok{signal}\OperatorTok{,}
\NormalTok{  fs}\OperatorTok{.}\FunctionTok{createReadStream}\NormalTok{((}\StringTok{\textquotesingle{}object.json\textquotesingle{}}\NormalTok{))}\OperatorTok{,}
\NormalTok{)}\OperatorTok{;}
\NormalTok{(}\KeywordTok{async}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \ControlFlowTok{try}\NormalTok{ \{}
    \ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ stream) \{}
      \ControlFlowTok{await} \BuiltInTok{process}\NormalTok{(chunk)}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \} }\ControlFlowTok{catch}\NormalTok{ (e) \{}
    \ControlFlowTok{if}\NormalTok{ (e}\OperatorTok{.}\AttributeTok{name} \OperatorTok{===} \StringTok{\textquotesingle{}AbortError\textquotesingle{}}\NormalTok{) \{}
      \CommentTok{// The operation was cancelled}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \ControlFlowTok{throw}\NormalTok{ e}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\})()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Or using an \texttt{AbortSignal} with a ReadableStream:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ controller }\OperatorTok{=} \KeywordTok{new} \FunctionTok{AbortController}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ rs }\OperatorTok{=} \KeywordTok{new} \FunctionTok{ReadableStream}\NormalTok{(\{}
  \FunctionTok{start}\NormalTok{(controller) \{}
\NormalTok{    controller}\OperatorTok{.}\FunctionTok{enqueue}\NormalTok{(}\StringTok{\textquotesingle{}hello\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{    controller}\OperatorTok{.}\FunctionTok{enqueue}\NormalTok{(}\StringTok{\textquotesingle{}world\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{    controller}\OperatorTok{.}\FunctionTok{close}\NormalTok{()}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}

\FunctionTok{addAbortSignal}\NormalTok{(controller}\OperatorTok{.}\AttributeTok{signal}\OperatorTok{,}\NormalTok{ rs)}\OperatorTok{;}

\FunctionTok{finished}\NormalTok{(rs}\OperatorTok{,}\NormalTok{ (err) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \ControlFlowTok{if}\NormalTok{ (err) \{}
    \ControlFlowTok{if}\NormalTok{ (err}\OperatorTok{.}\AttributeTok{name} \OperatorTok{===} \StringTok{\textquotesingle{}AbortError\textquotesingle{}}\NormalTok{) \{}
      \CommentTok{// The operation was cancelled}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\})}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ reader }\OperatorTok{=}\NormalTok{ rs}\OperatorTok{.}\FunctionTok{getReader}\NormalTok{()}\OperatorTok{;}

\NormalTok{reader}\OperatorTok{.}\FunctionTok{read}\NormalTok{()}\OperatorTok{.}\FunctionTok{then}\NormalTok{((\{ value}\OperatorTok{,}\NormalTok{ done \}) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(value)}\OperatorTok{;} \CommentTok{// hello}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(done)}\OperatorTok{;} \CommentTok{// false}
\NormalTok{  controller}\OperatorTok{.}\FunctionTok{abort}\NormalTok{()}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{stream.getDefaultHighWaterMark(objectMode)}}{stream.getDefaultHighWaterMark(objectMode)}}\label{stream.getdefaulthighwatermarkobjectmode}

\begin{itemize}
\tightlist
\item
  \texttt{objectMode} \{boolean\}
\item
  Returns: \{integer\}
\end{itemize}

Returns the default highWaterMark used by streams. Defaults to
\texttt{16384} (16 KiB), or \texttt{16} for \texttt{objectMode}.

\subsubsection{\texorpdfstring{\texttt{stream.setDefaultHighWaterMark(objectMode,\ value)}}{stream.setDefaultHighWaterMark(objectMode, value)}}\label{stream.setdefaulthighwatermarkobjectmode-value}

\begin{itemize}
\tightlist
\item
  \texttt{objectMode} \{boolean\}
\item
  \texttt{value} \{integer\} highWaterMark value
\end{itemize}

Sets the default highWaterMark used by streams.

\subsection{API for stream
implementers}\label{api-for-stream-implementers}

The \texttt{node:stream} module API has been designed to make it
possible to easily implement streams using JavaScript's prototypal
inheritance model.

First, a stream developer would declare a new JavaScript class that
extends one of the four basic stream classes (\texttt{stream.Writable},
\texttt{stream.Readable}, \texttt{stream.Duplex}, or
\texttt{stream.Transform}), making sure they call the appropriate parent
class constructor:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{class}\NormalTok{ MyWritable }\KeywordTok{extends}\NormalTok{ Writable \{}
  \FunctionTok{constructor}\NormalTok{(\{ highWaterMark}\OperatorTok{,} \OperatorTok{...}\NormalTok{options \}) \{}
    \KeywordTok{super}\NormalTok{(\{ highWaterMark \})}\OperatorTok{;}
    \CommentTok{// ...}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

When extending streams, keep in mind what options the user can and
should provide before forwarding these to the base constructor. For
example, if the implementation makes assumptions in regard to the
\texttt{autoDestroy} and \texttt{emitClose} options, do not allow the
user to override these. Be explicit about what options are forwarded
instead of implicitly forwarding all options.

The new stream class must then implement one or more specific methods,
depending on the type of stream being created, as detailed in the chart
below:

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.2586}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.0862}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 4\tabcolsep) * \real{0.6552}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Use-case
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Class
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Method(s) to implement
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Reading only & \hyperref[class-streamreadable]{\texttt{Readable}} &
\hyperref[readable_readsize]{\texttt{\_read()}} \\
Writing only & \hyperref[class-streamwritable]{\texttt{Writable}} &
\hyperref[writable_writechunk-encoding-callback]{\texttt{\_write()}},
\hyperref[writable_writevchunks-callback]{\texttt{\_writev()}},
\hyperref[writable_finalcallback]{\texttt{\_final()}} \\
Reading and writing & \hyperref[class-streamduplex]{\texttt{Duplex}} &
\hyperref[readable_readsize]{\texttt{\_read()}},
\hyperref[writable_writechunk-encoding-callback]{\texttt{\_write()}},
\hyperref[writable_writevchunks-callback]{\texttt{\_writev()}},
\hyperref[writable_finalcallback]{\texttt{\_final()}} \\
Operate on written data, then read the result &
\hyperref[class-streamtransform]{\texttt{Transform}} &
\hyperref[transform_transformchunk-encoding-callback]{\texttt{\_transform()}},
\hyperref[transform_flushcallback]{\texttt{\_flush()}},
\hyperref[writable_finalcallback]{\texttt{\_final()}} \\
\end{longtable}

The implementation code for a stream should \emph{never} call the
``public'' methods of a stream that are intended for use by consumers
(as described in the \hyperref[api-for-stream-consumers]{API for stream
consumers} section). Doing so may lead to adverse side effects in
application code consuming the stream.

Avoid overriding public methods such as \texttt{write()},
\texttt{end()}, \texttt{cork()}, \texttt{uncork()}, \texttt{read()} and
\texttt{destroy()}, or emitting internal events such as
\texttt{\textquotesingle{}error\textquotesingle{}},
\texttt{\textquotesingle{}data\textquotesingle{}},
\texttt{\textquotesingle{}end\textquotesingle{}},
\texttt{\textquotesingle{}finish\textquotesingle{}} and
\texttt{\textquotesingle{}close\textquotesingle{}} through
\texttt{.emit()}. Doing so can break current and future stream
invariants leading to behavior and/or compatibility issues with other
streams, stream utilities, and user expectations.

\subsubsection{Simplified construction}\label{simplified-construction}

For many simple cases, it is possible to create a stream without relying
on inheritance. This can be accomplished by directly creating instances
of the \texttt{stream.Writable}, \texttt{stream.Readable},
\texttt{stream.Duplex}, or \texttt{stream.Transform} objects and passing
appropriate methods as constructor options.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ myWritable }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Writable}\NormalTok{(\{}
  \FunctionTok{construct}\NormalTok{(callback) \{}
    \CommentTok{// Initialize state and load resources...}
\NormalTok{  \}}\OperatorTok{,}
  \FunctionTok{write}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
    \CommentTok{// ...}
\NormalTok{  \}}\OperatorTok{,}
  \FunctionTok{destroy}\NormalTok{() \{}
    \CommentTok{// Free resources...}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Implementing a writable
stream}\label{implementing-a-writable-stream}

The \texttt{stream.Writable} class is extended to implement a
\hyperref[class-streamwritable]{\texttt{Writable}} stream.

Custom \texttt{Writable} streams \emph{must} call the
\texttt{new\ stream.Writable({[}options{]})} constructor and implement
the \texttt{writable.\_write()} and/or \texttt{writable.\_writev()}
method.

\paragraph{\texorpdfstring{\texttt{new\ stream.Writable({[}options{]})}}{new stream.Writable({[}options{]})}}\label{new-stream.writableoptions}

\begin{itemize}
\tightlist
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{highWaterMark} \{number\} Buffer level when
    \hyperref[writablewritechunk-encoding-callback]{\texttt{stream.write()}}
    starts returning \texttt{false}. \textbf{Default:} \texttt{16384}
    (16 KiB), or \texttt{16} for \texttt{objectMode} streams.
  \item
    \texttt{decodeStrings} \{boolean\} Whether to encode
    \texttt{string}s passed to
    \hyperref[writablewritechunk-encoding-callback]{\texttt{stream.write()}}
    to \texttt{Buffer}s (with the encoding specified in the
    \hyperref[writablewritechunk-encoding-callback]{\texttt{stream.write()}}
    call) before passing them to
    \hyperref[writable_writechunk-encoding-callback]{\texttt{stream.\_write()}}.
    Other types of data are not converted (i.e.~\texttt{Buffer}s are not
    decoded into \texttt{string}s). Setting to false will prevent
    \texttt{string}s from being converted. \textbf{Default:}
    \texttt{true}.
  \item
    \texttt{defaultEncoding} \{string\} The default encoding that is
    used when no encoding is specified as an argument to
    \hyperref[writablewritechunk-encoding-callback]{\texttt{stream.write()}}.
    \textbf{Default:} \texttt{\textquotesingle{}utf8\textquotesingle{}}.
  \item
    \texttt{objectMode} \{boolean\} Whether or not the
    \hyperref[writablewritechunk-encoding-callback]{\texttt{stream.write(anyObj)}}
    is a valid operation. When set, it becomes possible to write
    JavaScript values other than string, \texttt{Buffer} or
    \texttt{Uint8Array} if supported by the stream implementation.
    \textbf{Default:} \texttt{false}.
  \item
    \texttt{emitClose} \{boolean\} Whether or not the stream should emit
    \texttt{\textquotesingle{}close\textquotesingle{}} after it has been
    destroyed. \textbf{Default:} \texttt{true}.
  \item
    \texttt{write} \{Function\} Implementation for the
    \hyperref[writable_writechunk-encoding-callback]{\texttt{stream.\_write()}}
    method.
  \item
    \texttt{writev} \{Function\} Implementation for the
    \hyperref[writable_writevchunks-callback]{\texttt{stream.\_writev()}}
    method.
  \item
    \texttt{destroy} \{Function\} Implementation for the
    \hyperref[writable_destroyerr-callback]{\texttt{stream.\_destroy()}}
    method.
  \item
    \texttt{final} \{Function\} Implementation for the
    \hyperref[writable_finalcallback]{\texttt{stream.\_final()}} method.
  \item
    \texttt{construct} \{Function\} Implementation for the
    \hyperref[writable_constructcallback]{\texttt{stream.\_construct()}}
    method.
  \item
    \texttt{autoDestroy} \{boolean\} Whether this stream should
    automatically call \texttt{.destroy()} on itself after ending.
    \textbf{Default:} \texttt{true}.
  \item
    \texttt{signal} \{AbortSignal\} A signal representing possible
    cancellation.
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{class}\NormalTok{ MyWritable }\KeywordTok{extends}\NormalTok{ Writable \{}
  \FunctionTok{constructor}\NormalTok{(options) \{}
    \CommentTok{// Calls the stream.Writable() constructor.}
    \KeywordTok{super}\NormalTok{(options)}\OperatorTok{;}
    \CommentTok{// ...}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Or, when using pre-ES6 style constructors:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ util }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:util\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{function} \FunctionTok{MyWritable}\NormalTok{(options) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\NormalTok{(}\KeywordTok{this} \KeywordTok{instanceof}\NormalTok{ MyWritable))}
    \ControlFlowTok{return} \KeywordTok{new} \FunctionTok{MyWritable}\NormalTok{(options)}\OperatorTok{;}
\NormalTok{  Writable}\OperatorTok{.}\FunctionTok{call}\NormalTok{(}\KeywordTok{this}\OperatorTok{,}\NormalTok{ options)}\OperatorTok{;}
\NormalTok{\}}
\NormalTok{util}\OperatorTok{.}\FunctionTok{inherits}\NormalTok{(MyWritable}\OperatorTok{,}\NormalTok{ Writable)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Or, using the simplified constructor approach:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ myWritable }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Writable}\NormalTok{(\{}
  \FunctionTok{write}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
    \CommentTok{// ...}
\NormalTok{  \}}\OperatorTok{,}
  \FunctionTok{writev}\NormalTok{(chunks}\OperatorTok{,}\NormalTok{ callback) \{}
    \CommentTok{// ...}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Calling \texttt{abort} on the \texttt{AbortController} corresponding to
the passed \texttt{AbortSignal} will behave the same way as calling
\texttt{.destroy(new\ AbortError())} on the writeable stream.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ controller }\OperatorTok{=} \KeywordTok{new} \FunctionTok{AbortController}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ myWritable }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Writable}\NormalTok{(\{}
  \FunctionTok{write}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
    \CommentTok{// ...}
\NormalTok{  \}}\OperatorTok{,}
  \FunctionTok{writev}\NormalTok{(chunks}\OperatorTok{,}\NormalTok{ callback) \{}
    \CommentTok{// ...}
\NormalTok{  \}}\OperatorTok{,}
  \DataTypeTok{signal}\OperatorTok{:}\NormalTok{ controller}\OperatorTok{.}\AttributeTok{signal}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}
\CommentTok{// Later, abort the operation closing the stream}
\NormalTok{controller}\OperatorTok{.}\FunctionTok{abort}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\paragraph{\texorpdfstring{\texttt{writable.\_construct(callback)}}{writable.\_construct(callback)}}\label{writable._constructcallback}

\begin{itemize}
\tightlist
\item
  \texttt{callback} \{Function\} Call this function (optionally with an
  error argument) when the stream has finished initializing.
\end{itemize}

The \texttt{\_construct()} method MUST NOT be called directly. It may be
implemented by child classes, and if so, will be called by the internal
\texttt{Writable} class methods only.

This optional function will be called in a tick after the stream
constructor has returned, delaying any \texttt{\_write()},
\texttt{\_final()} and \texttt{\_destroy()} calls until
\texttt{callback} is called. This is useful to initialize state or
asynchronously initialize resources before the stream can be used.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{class} \BuiltInTok{WriteStream} \KeywordTok{extends}\NormalTok{ Writable \{}
  \FunctionTok{constructor}\NormalTok{(filename) \{}
    \KeywordTok{super}\NormalTok{()}\OperatorTok{;}
    \KeywordTok{this}\OperatorTok{.}\AttributeTok{filename} \OperatorTok{=}\NormalTok{ filename}\OperatorTok{;}
    \KeywordTok{this}\OperatorTok{.}\AttributeTok{fd} \OperatorTok{=} \KeywordTok{null}\OperatorTok{;}
\NormalTok{  \}}
  \FunctionTok{\_construct}\NormalTok{(callback) \{}
\NormalTok{    fs}\OperatorTok{.}\FunctionTok{open}\NormalTok{(}\KeywordTok{this}\OperatorTok{.}\AttributeTok{filename}\OperatorTok{,}\NormalTok{ (err}\OperatorTok{,}\NormalTok{ fd) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
      \ControlFlowTok{if}\NormalTok{ (err) \{}
        \FunctionTok{callback}\NormalTok{(err)}\OperatorTok{;}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
        \KeywordTok{this}\OperatorTok{.}\AttributeTok{fd} \OperatorTok{=}\NormalTok{ fd}\OperatorTok{;}
        \FunctionTok{callback}\NormalTok{()}\OperatorTok{;}
\NormalTok{      \}}
\NormalTok{    \})}\OperatorTok{;}
\NormalTok{  \}}
  \FunctionTok{\_write}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
\NormalTok{    fs}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\KeywordTok{this}\OperatorTok{.}\AttributeTok{fd}\OperatorTok{,}\NormalTok{ chunk}\OperatorTok{,}\NormalTok{ callback)}\OperatorTok{;}
\NormalTok{  \}}
  \FunctionTok{\_destroy}\NormalTok{(err}\OperatorTok{,}\NormalTok{ callback) \{}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{this}\OperatorTok{.}\AttributeTok{fd}\NormalTok{) \{}
\NormalTok{      fs}\OperatorTok{.}\FunctionTok{close}\NormalTok{(}\KeywordTok{this}\OperatorTok{.}\AttributeTok{fd}\OperatorTok{,}\NormalTok{ (er) }\KeywordTok{=\textgreater{}} \FunctionTok{callback}\NormalTok{(er }\OperatorTok{||}\NormalTok{ err))}\OperatorTok{;}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \FunctionTok{callback}\NormalTok{(err)}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\paragraph{\texorpdfstring{\texttt{writable.\_write(chunk,\ encoding,\ callback)}}{writable.\_write(chunk, encoding, callback)}}\label{writable._writechunk-encoding-callback}

\begin{itemize}
\tightlist
\item
  \texttt{chunk} \{Buffer\textbar string\textbar any\} The
  \texttt{Buffer} to be written, converted from the \texttt{string}
  passed to
  \hyperref[writablewritechunk-encoding-callback]{\texttt{stream.write()}}.
  If the stream's \texttt{decodeStrings} option is \texttt{false} or the
  stream is operating in object mode, the chunk will not be converted \&
  will be whatever was passed to
  \hyperref[writablewritechunk-encoding-callback]{\texttt{stream.write()}}.
\item
  \texttt{encoding} \{string\} If the chunk is a string, then
  \texttt{encoding} is the character encoding of that string. If chunk
  is a \texttt{Buffer}, or if the stream is operating in object mode,
  \texttt{encoding} may be ignored.
\item
  \texttt{callback} \{Function\} Call this function (optionally with an
  error argument) when processing is complete for the supplied chunk.
\end{itemize}

All \texttt{Writable} stream implementations must provide a
\hyperref[writable_writechunk-encoding-callback]{\texttt{writable.\_write()}}
and/or
\hyperref[writable_writevchunks-callback]{\texttt{writable.\_writev()}}
method to send data to the underlying resource.

\hyperref[class-streamtransform]{\texttt{Transform}} streams provide
their own implementation of the
\hyperref[writable_writechunk-encoding-callback]{\texttt{writable.\_write()}}.

This function MUST NOT be called by application code directly. It should
be implemented by child classes, and called by the internal
\texttt{Writable} class methods only.

The \texttt{callback} function must be called synchronously inside of
\texttt{writable.\_write()} or asynchronously (i.e.~different tick) to
signal either that the write completed successfully or failed with an
error. The first argument passed to the \texttt{callback} must be the
\texttt{Error} object if the call failed or \texttt{null} if the write
succeeded.

All calls to \texttt{writable.write()} that occur between the time
\texttt{writable.\_write()} is called and the \texttt{callback} is
called will cause the written data to be buffered. When the
\texttt{callback} is invoked, the stream might emit a
\hyperref[event-drain]{\texttt{\textquotesingle{}drain\textquotesingle{}}}
event. If a stream implementation is capable of processing multiple
chunks of data at once, the \texttt{writable.\_writev()} method should
be implemented.

If the \texttt{decodeStrings} property is explicitly set to
\texttt{false} in the constructor options, then \texttt{chunk} will
remain the same object that is passed to \texttt{.write()}, and may be a
string rather than a \texttt{Buffer}. This is to support implementations
that have an optimized handling for certain string data encodings. In
that case, the \texttt{encoding} argument will indicate the character
encoding of the string. Otherwise, the \texttt{encoding} argument can be
safely ignored.

The \texttt{writable.\_write()} method is prefixed with an underscore
because it is internal to the class that defines it, and should never be
called directly by user programs.

\paragraph{\texorpdfstring{\texttt{writable.\_writev(chunks,\ callback)}}{writable.\_writev(chunks, callback)}}\label{writable._writevchunks-callback}

\begin{itemize}
\tightlist
\item
  \texttt{chunks} \{Object{[}{]}\} The data to be written. The value is
  an array of \{Object\} that each represent a discrete chunk of data to
  write. The properties of these objects are:

  \begin{itemize}
  \tightlist
  \item
    \texttt{chunk} \{Buffer\textbar string\} A buffer instance or string
    containing the data to be written. The \texttt{chunk} will be a
    string if the \texttt{Writable} was created with the
    \texttt{decodeStrings} option set to \texttt{false} and a string was
    passed to \texttt{write()}.
  \item
    \texttt{encoding} \{string\} The character encoding of the
    \texttt{chunk}. If \texttt{chunk} is a \texttt{Buffer}, the
    \texttt{encoding} will be
    \texttt{\textquotesingle{}buffer\textquotesingle{}}.
  \end{itemize}
\item
  \texttt{callback} \{Function\} A callback function (optionally with an
  error argument) to be invoked when processing is complete for the
  supplied chunks.
\end{itemize}

This function MUST NOT be called by application code directly. It should
be implemented by child classes, and called by the internal
\texttt{Writable} class methods only.

The \texttt{writable.\_writev()} method may be implemented in addition
or alternatively to \texttt{writable.\_write()} in stream
implementations that are capable of processing multiple chunks of data
at once. If implemented and if there is buffered data from previous
writes, \texttt{\_writev()} will be called instead of
\texttt{\_write()}.

The \texttt{writable.\_writev()} method is prefixed with an underscore
because it is internal to the class that defines it, and should never be
called directly by user programs.

\paragraph{\texorpdfstring{\texttt{writable.\_destroy(err,\ callback)}}{writable.\_destroy(err, callback)}}\label{writable._destroyerr-callback}

\begin{itemize}
\tightlist
\item
  \texttt{err} \{Error\} A possible error.
\item
  \texttt{callback} \{Function\} A callback function that takes an
  optional error argument.
\end{itemize}

The \texttt{\_destroy()} method is called by
\hyperref[writabledestroyerror]{\texttt{writable.destroy()}}. It can be
overridden by child classes but it \textbf{must not} be called directly.
Furthermore, the \texttt{callback} should not be mixed with async/await
once it is executed when a promise is resolved.

\paragraph{\texorpdfstring{\texttt{writable.\_final(callback)}}{writable.\_final(callback)}}\label{writable._finalcallback}

\begin{itemize}
\tightlist
\item
  \texttt{callback} \{Function\} Call this function (optionally with an
  error argument) when finished writing any remaining data.
\end{itemize}

The \texttt{\_final()} method \textbf{must not} be called directly. It
may be implemented by child classes, and if so, will be called by the
internal \texttt{Writable} class methods only.

This optional function will be called before the stream closes, delaying
the \texttt{\textquotesingle{}finish\textquotesingle{}} event until
\texttt{callback} is called. This is useful to close resources or write
buffered data before a stream ends.

\paragraph{Errors while writing}\label{errors-while-writing}

Errors occurring during the processing of the
\hyperref[writable_writechunk-encoding-callback]{\texttt{writable.\_write()}},
\hyperref[writable_writevchunks-callback]{\texttt{writable.\_writev()}}
and \hyperref[writable_finalcallback]{\texttt{writable.\_final()}}
methods must be propagated by invoking the callback and passing the
error as the first argument. Throwing an \texttt{Error} from within
these methods or manually emitting an
\texttt{\textquotesingle{}error\textquotesingle{}} event results in
undefined behavior.

If a \texttt{Readable} stream pipes into a \texttt{Writable} stream when
\texttt{Writable} emits an error, the \texttt{Readable} stream will be
unpiped.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ myWritable }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Writable}\NormalTok{(\{}
  \FunctionTok{write}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
    \ControlFlowTok{if}\NormalTok{ (chunk}\OperatorTok{.}\FunctionTok{toString}\NormalTok{()}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{) }\OperatorTok{\textgreater{}=} \DecValTok{0}\NormalTok{) \{}
      \FunctionTok{callback}\NormalTok{(}\KeywordTok{new} \BuiltInTok{Error}\NormalTok{(}\StringTok{\textquotesingle{}chunk is invalid\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \FunctionTok{callback}\NormalTok{()}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\paragraph{An example writable stream}\label{an-example-writable-stream}

The following illustrates a rather simplistic (and somewhat pointless)
custom \texttt{Writable} stream implementation. While this specific
\texttt{Writable} stream instance is not of any real particular
usefulness, the example illustrates each of the required elements of a
custom \hyperref[class-streamwritable]{\texttt{Writable}} stream
instance:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{class}\NormalTok{ MyWritable }\KeywordTok{extends}\NormalTok{ Writable \{}
  \FunctionTok{\_write}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
    \ControlFlowTok{if}\NormalTok{ (chunk}\OperatorTok{.}\FunctionTok{toString}\NormalTok{()}\OperatorTok{.}\FunctionTok{indexOf}\NormalTok{(}\StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{) }\OperatorTok{\textgreater{}=} \DecValTok{0}\NormalTok{) \{}
      \FunctionTok{callback}\NormalTok{(}\KeywordTok{new} \BuiltInTok{Error}\NormalTok{(}\StringTok{\textquotesingle{}chunk is invalid\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \FunctionTok{callback}\NormalTok{()}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\paragraph{Decoding buffers in a writable
stream}\label{decoding-buffers-in-a-writable-stream}

Decoding buffers is a common task, for instance, when using transformers
whose input is a string. This is not a trivial process when using
multi-byte characters encoding, such as UTF-8. The following example
shows how to decode multi-byte strings using \texttt{StringDecoder} and
\hyperref[class-streamwritable]{\texttt{Writable}}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Writable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ \{ StringDecoder \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:string\_decoder\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{class}\NormalTok{ StringWritable }\KeywordTok{extends}\NormalTok{ Writable \{}
  \FunctionTok{constructor}\NormalTok{(options) \{}
    \KeywordTok{super}\NormalTok{(options)}\OperatorTok{;}
    \KeywordTok{this}\OperatorTok{.}\AttributeTok{\_decoder} \OperatorTok{=} \KeywordTok{new} \FunctionTok{StringDecoder}\NormalTok{(options }\OperatorTok{\&\&}\NormalTok{ options}\OperatorTok{.}\AttributeTok{defaultEncoding}\NormalTok{)}\OperatorTok{;}
    \KeywordTok{this}\OperatorTok{.}\AttributeTok{data} \OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\OperatorTok{;}
\NormalTok{  \}}
  \FunctionTok{\_write}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
    \ControlFlowTok{if}\NormalTok{ (encoding }\OperatorTok{===} \StringTok{\textquotesingle{}buffer\textquotesingle{}}\NormalTok{) \{}
\NormalTok{      chunk }\OperatorTok{=} \KeywordTok{this}\OperatorTok{.}\AttributeTok{\_decoder}\OperatorTok{.}\FunctionTok{write}\NormalTok{(chunk)}\OperatorTok{;}
\NormalTok{    \}}
    \KeywordTok{this}\OperatorTok{.}\AttributeTok{data} \OperatorTok{+=}\NormalTok{ chunk}\OperatorTok{;}
    \FunctionTok{callback}\NormalTok{()}\OperatorTok{;}
\NormalTok{  \}}
  \FunctionTok{\_final}\NormalTok{(callback) \{}
    \KeywordTok{this}\OperatorTok{.}\AttributeTok{data} \OperatorTok{+=} \KeywordTok{this}\OperatorTok{.}\AttributeTok{\_decoder}\OperatorTok{.}\FunctionTok{end}\NormalTok{()}\OperatorTok{;}
    \FunctionTok{callback}\NormalTok{()}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}

\KeywordTok{const}\NormalTok{ euro }\OperatorTok{=}\NormalTok{ [[}\BaseNTok{0xE2}\OperatorTok{,} \BaseNTok{0x82}\NormalTok{]}\OperatorTok{,}\NormalTok{ [}\BaseNTok{0xAC}\NormalTok{]]}\OperatorTok{.}\FunctionTok{map}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\AttributeTok{from}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ w }\OperatorTok{=} \KeywordTok{new} \FunctionTok{StringWritable}\NormalTok{()}\OperatorTok{;}

\NormalTok{w}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}currency: \textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{w}\OperatorTok{.}\FunctionTok{write}\NormalTok{(euro[}\DecValTok{0}\NormalTok{])}\OperatorTok{;}
\NormalTok{w}\OperatorTok{.}\FunctionTok{end}\NormalTok{(euro[}\DecValTok{1}\NormalTok{])}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(w}\OperatorTok{.}\AttributeTok{data}\NormalTok{)}\OperatorTok{;} \CommentTok{// currency: €}
\end{Highlighting}
\end{Shaded}

\subsubsection{Implementing a readable
stream}\label{implementing-a-readable-stream}

The \texttt{stream.Readable} class is extended to implement a
\hyperref[class-streamreadable]{\texttt{Readable}} stream.

Custom \texttt{Readable} streams \emph{must} call the
\texttt{new\ stream.Readable({[}options{]})} constructor and implement
the \hyperref[readable_readsize]{\texttt{readable.\_read()}} method.

\paragraph{\texorpdfstring{\texttt{new\ stream.Readable({[}options{]})}}{new stream.Readable({[}options{]})}}\label{new-stream.readableoptions}

\begin{itemize}
\tightlist
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{highWaterMark} \{number\} The maximum
    \hyperref[highwatermark-discrepancy-after-calling-readablesetencoding]{number
    of bytes} to store in the internal buffer before ceasing to read
    from the underlying resource. \textbf{Default:} \texttt{16384} (16
    KiB), or \texttt{16} for \texttt{objectMode} streams.
  \item
    \texttt{encoding} \{string\} If specified, then buffers will be
    decoded to strings using the specified encoding. \textbf{Default:}
    \texttt{null}.
  \item
    \texttt{objectMode} \{boolean\} Whether this stream should behave as
    a stream of objects. Meaning that
    \hyperref[readablereadsize]{\texttt{stream.read(n)}} returns a
    single value instead of a \texttt{Buffer} of size \texttt{n}.
    \textbf{Default:} \texttt{false}.
  \item
    \texttt{emitClose} \{boolean\} Whether or not the stream should emit
    \texttt{\textquotesingle{}close\textquotesingle{}} after it has been
    destroyed. \textbf{Default:} \texttt{true}.
  \item
    \texttt{read} \{Function\} Implementation for the
    \hyperref[readable_readsize]{\texttt{stream.\_read()}} method.
  \item
    \texttt{destroy} \{Function\} Implementation for the
    \hyperref[readable_destroyerr-callback]{\texttt{stream.\_destroy()}}
    method.
  \item
    \texttt{construct} \{Function\} Implementation for the
    \hyperref[readable_constructcallback]{\texttt{stream.\_construct()}}
    method.
  \item
    \texttt{autoDestroy} \{boolean\} Whether this stream should
    automatically call \texttt{.destroy()} on itself after ending.
    \textbf{Default:} \texttt{true}.
  \item
    \texttt{signal} \{AbortSignal\} A signal representing possible
    cancellation.
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Readable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{class}\NormalTok{ MyReadable }\KeywordTok{extends}\NormalTok{ Readable \{}
  \FunctionTok{constructor}\NormalTok{(options) \{}
    \CommentTok{// Calls the stream.Readable(options) constructor.}
    \KeywordTok{super}\NormalTok{(options)}\OperatorTok{;}
    \CommentTok{// ...}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Or, when using pre-ES6 style constructors:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Readable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ util }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:util\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{function} \FunctionTok{MyReadable}\NormalTok{(options) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\NormalTok{(}\KeywordTok{this} \KeywordTok{instanceof}\NormalTok{ MyReadable))}
    \ControlFlowTok{return} \KeywordTok{new} \FunctionTok{MyReadable}\NormalTok{(options)}\OperatorTok{;}
\NormalTok{  Readable}\OperatorTok{.}\FunctionTok{call}\NormalTok{(}\KeywordTok{this}\OperatorTok{,}\NormalTok{ options)}\OperatorTok{;}
\NormalTok{\}}
\NormalTok{util}\OperatorTok{.}\FunctionTok{inherits}\NormalTok{(MyReadable}\OperatorTok{,}\NormalTok{ Readable)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Or, using the simplified constructor approach:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Readable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ myReadable }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Readable}\NormalTok{(\{}
  \FunctionTok{read}\NormalTok{(size) \{}
    \CommentTok{// ...}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Calling \texttt{abort} on the \texttt{AbortController} corresponding to
the passed \texttt{AbortSignal} will behave the same way as calling
\texttt{.destroy(new\ AbortError())} on the readable created.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Readable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ controller }\OperatorTok{=} \KeywordTok{new} \FunctionTok{AbortController}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ read }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Readable}\NormalTok{(\{}
  \FunctionTok{read}\NormalTok{(size) \{}
    \CommentTok{// ...}
\NormalTok{  \}}\OperatorTok{,}
  \DataTypeTok{signal}\OperatorTok{:}\NormalTok{ controller}\OperatorTok{.}\AttributeTok{signal}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}
\CommentTok{// Later, abort the operation closing the stream}
\NormalTok{controller}\OperatorTok{.}\FunctionTok{abort}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\paragraph{\texorpdfstring{\texttt{readable.\_construct(callback)}}{readable.\_construct(callback)}}\label{readable._constructcallback}

\begin{itemize}
\tightlist
\item
  \texttt{callback} \{Function\} Call this function (optionally with an
  error argument) when the stream has finished initializing.
\end{itemize}

The \texttt{\_construct()} method MUST NOT be called directly. It may be
implemented by child classes, and if so, will be called by the internal
\texttt{Readable} class methods only.

This optional function will be scheduled in the next tick by the stream
constructor, delaying any \texttt{\_read()} and \texttt{\_destroy()}
calls until \texttt{callback} is called. This is useful to initialize
state or asynchronously initialize resources before the stream can be
used.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Readable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{class} \BuiltInTok{ReadStream} \KeywordTok{extends}\NormalTok{ Readable \{}
  \FunctionTok{constructor}\NormalTok{(filename) \{}
    \KeywordTok{super}\NormalTok{()}\OperatorTok{;}
    \KeywordTok{this}\OperatorTok{.}\AttributeTok{filename} \OperatorTok{=}\NormalTok{ filename}\OperatorTok{;}
    \KeywordTok{this}\OperatorTok{.}\AttributeTok{fd} \OperatorTok{=} \KeywordTok{null}\OperatorTok{;}
\NormalTok{  \}}
  \FunctionTok{\_construct}\NormalTok{(callback) \{}
\NormalTok{    fs}\OperatorTok{.}\FunctionTok{open}\NormalTok{(}\KeywordTok{this}\OperatorTok{.}\AttributeTok{filename}\OperatorTok{,}\NormalTok{ (err}\OperatorTok{,}\NormalTok{ fd) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
      \ControlFlowTok{if}\NormalTok{ (err) \{}
        \FunctionTok{callback}\NormalTok{(err)}\OperatorTok{;}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
        \KeywordTok{this}\OperatorTok{.}\AttributeTok{fd} \OperatorTok{=}\NormalTok{ fd}\OperatorTok{;}
        \FunctionTok{callback}\NormalTok{()}\OperatorTok{;}
\NormalTok{      \}}
\NormalTok{    \})}\OperatorTok{;}
\NormalTok{  \}}
  \FunctionTok{\_read}\NormalTok{(n) \{}
    \KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{alloc}\NormalTok{(n)}\OperatorTok{;}
\NormalTok{    fs}\OperatorTok{.}\FunctionTok{read}\NormalTok{(}\KeywordTok{this}\OperatorTok{.}\AttributeTok{fd}\OperatorTok{,}\NormalTok{ buf}\OperatorTok{,} \DecValTok{0}\OperatorTok{,}\NormalTok{ n}\OperatorTok{,} \KeywordTok{null}\OperatorTok{,}\NormalTok{ (err}\OperatorTok{,}\NormalTok{ bytesRead) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
      \ControlFlowTok{if}\NormalTok{ (err) \{}
        \KeywordTok{this}\OperatorTok{.}\FunctionTok{destroy}\NormalTok{(err)}\OperatorTok{;}
\NormalTok{      \} }\ControlFlowTok{else}\NormalTok{ \{}
        \KeywordTok{this}\OperatorTok{.}\FunctionTok{push}\NormalTok{(bytesRead }\OperatorTok{\textgreater{}} \DecValTok{0} \OperatorTok{?}\NormalTok{ buf}\OperatorTok{.}\FunctionTok{slice}\NormalTok{(}\DecValTok{0}\OperatorTok{,}\NormalTok{ bytesRead) }\OperatorTok{:} \KeywordTok{null}\NormalTok{)}\OperatorTok{;}
\NormalTok{      \}}
\NormalTok{    \})}\OperatorTok{;}
\NormalTok{  \}}
  \FunctionTok{\_destroy}\NormalTok{(err}\OperatorTok{,}\NormalTok{ callback) \{}
    \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{this}\OperatorTok{.}\AttributeTok{fd}\NormalTok{) \{}
\NormalTok{      fs}\OperatorTok{.}\FunctionTok{close}\NormalTok{(}\KeywordTok{this}\OperatorTok{.}\AttributeTok{fd}\OperatorTok{,}\NormalTok{ (er) }\KeywordTok{=\textgreater{}} \FunctionTok{callback}\NormalTok{(er }\OperatorTok{||}\NormalTok{ err))}\OperatorTok{;}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \FunctionTok{callback}\NormalTok{(err)}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\paragraph{\texorpdfstring{\texttt{readable.\_read(size)}}{readable.\_read(size)}}\label{readable._readsize}

\begin{itemize}
\tightlist
\item
  \texttt{size} \{number\} Number of bytes to read asynchronously
\end{itemize}

This function MUST NOT be called by application code directly. It should
be implemented by child classes, and called by the internal
\texttt{Readable} class methods only.

All \texttt{Readable} stream implementations must provide an
implementation of the
\hyperref[readable_readsize]{\texttt{readable.\_read()}} method to fetch
data from the underlying resource.

When \hyperref[readable_readsize]{\texttt{readable.\_read()}} is called,
if data is available from the resource, the implementation should begin
pushing that data into the read queue using the
\hyperref[readablepushchunk-encoding]{\texttt{this.push(dataChunk)}}
method. \texttt{\_read()} will be called again after each call to
\hyperref[readablepushchunk-encoding]{\texttt{this.push(dataChunk)}}
once the stream is ready to accept more data. \texttt{\_read()} may
continue reading from the resource and pushing data until
\texttt{readable.push()} returns \texttt{false}. Only when
\texttt{\_read()} is called again after it has stopped should it resume
pushing additional data into the queue.

Once the \hyperref[readable_readsize]{\texttt{readable.\_read()}} method
has been called, it will not be called again until more data is pushed
through the
\hyperref[readablepushchunk-encoding]{\texttt{readable.push()}} method.
Empty data such as empty buffers and strings will not cause
\hyperref[readable_readsize]{\texttt{readable.\_read()}} to be called.

The \texttt{size} argument is advisory. For implementations where a
``read'' is a single operation that returns data can use the
\texttt{size} argument to determine how much data to fetch. Other
implementations may ignore this argument and simply provide data
whenever it becomes available. There is no need to ``wait'' until
\texttt{size} bytes are available before calling
\hyperref[readablepushchunk-encoding]{\texttt{stream.push(chunk)}}.

The \hyperref[readable_readsize]{\texttt{readable.\_read()}} method is
prefixed with an underscore because it is internal to the class that
defines it, and should never be called directly by user programs.

\paragraph{\texorpdfstring{\texttt{readable.\_destroy(err,\ callback)}}{readable.\_destroy(err, callback)}}\label{readable._destroyerr-callback}

\begin{itemize}
\tightlist
\item
  \texttt{err} \{Error\} A possible error.
\item
  \texttt{callback} \{Function\} A callback function that takes an
  optional error argument.
\end{itemize}

The \texttt{\_destroy()} method is called by
\hyperref[readabledestroyerror]{\texttt{readable.destroy()}}. It can be
overridden by child classes but it \textbf{must not} be called directly.

\paragraph{\texorpdfstring{\texttt{readable.push(chunk{[},\ encoding{]})}}{readable.push(chunk{[}, encoding{]})}}\label{readable.pushchunk-encoding}

\begin{itemize}
\tightlist
\item
  \texttt{chunk}
  \{Buffer\textbar Uint8Array\textbar string\textbar null\textbar any\}
  Chunk of data to push into the read queue. For streams not operating
  in object mode, \texttt{chunk} must be a string, \texttt{Buffer} or
  \texttt{Uint8Array}. For object mode streams, \texttt{chunk} may be
  any JavaScript value.
\item
  \texttt{encoding} \{string\} Encoding of string chunks. Must be a
  valid \texttt{Buffer} encoding, such as
  \texttt{\textquotesingle{}utf8\textquotesingle{}} or
  \texttt{\textquotesingle{}ascii\textquotesingle{}}.
\item
  Returns: \{boolean\} \texttt{true} if additional chunks of data may
  continue to be pushed; \texttt{false} otherwise.
\end{itemize}

When \texttt{chunk} is a \texttt{Buffer}, \texttt{Uint8Array}, or
\texttt{string}, the \texttt{chunk} of data will be added to the
internal queue for users of the stream to consume. Passing
\texttt{chunk} as \texttt{null} signals the end of the stream (EOF),
after which no more data can be written.

When the \texttt{Readable} is operating in paused mode, the data added
with \texttt{readable.push()} can be read out by calling the
\hyperref[readablereadsize]{\texttt{readable.read()}} method when the
\hyperref[event-readable]{\texttt{\textquotesingle{}readable\textquotesingle{}}}
event is emitted.

When the \texttt{Readable} is operating in flowing mode, the data added
with \texttt{readable.push()} will be delivered by emitting a
\texttt{\textquotesingle{}data\textquotesingle{}} event.

The \texttt{readable.push()} method is designed to be as flexible as
possible. For example, when wrapping a lower-level source that provides
some form of pause/resume mechanism, and a data callback, the low-level
source can be wrapped by the custom \texttt{Readable} instance:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// \textasciigrave{}\_source\textasciigrave{} is an object with readStop() and readStart() methods,}
\CommentTok{// and an \textasciigrave{}ondata\textasciigrave{} member that gets called when it has data, and}
\CommentTok{// an \textasciigrave{}onend\textasciigrave{} member that gets called when the data is over.}

\KeywordTok{class}\NormalTok{ SourceWrapper }\KeywordTok{extends}\NormalTok{ Readable \{}
  \FunctionTok{constructor}\NormalTok{(options) \{}
    \KeywordTok{super}\NormalTok{(options)}\OperatorTok{;}

    \KeywordTok{this}\OperatorTok{.}\AttributeTok{\_source} \OperatorTok{=} \FunctionTok{getLowLevelSourceObject}\NormalTok{()}\OperatorTok{;}

    \CommentTok{// Every time there\textquotesingle{}s data, push it into the internal buffer.}
    \KeywordTok{this}\OperatorTok{.}\AttributeTok{\_source}\OperatorTok{.}\AttributeTok{ondata} \OperatorTok{=}\NormalTok{ (chunk) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
      \CommentTok{// If push() returns false, then stop reading from source.}
      \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\KeywordTok{this}\OperatorTok{.}\FunctionTok{push}\NormalTok{(chunk))}
        \KeywordTok{this}\OperatorTok{.}\AttributeTok{\_source}\OperatorTok{.}\FunctionTok{readStop}\NormalTok{()}\OperatorTok{;}
\NormalTok{    \}}\OperatorTok{;}

    \CommentTok{// When the source ends, push the EOF{-}signaling \textasciigrave{}null\textasciigrave{} chunk.}
    \KeywordTok{this}\OperatorTok{.}\AttributeTok{\_source}\OperatorTok{.}\AttributeTok{onend} \OperatorTok{=}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
      \KeywordTok{this}\OperatorTok{.}\FunctionTok{push}\NormalTok{(}\KeywordTok{null}\NormalTok{)}\OperatorTok{;}
\NormalTok{    \}}\OperatorTok{;}
\NormalTok{  \}}
  \CommentTok{// \_read() will be called when the stream wants to pull more data in.}
  \CommentTok{// The advisory size argument is ignored in this case.}
  \FunctionTok{\_read}\NormalTok{(size) \{}
    \KeywordTok{this}\OperatorTok{.}\AttributeTok{\_source}\OperatorTok{.}\FunctionTok{readStart}\NormalTok{()}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{readable.push()} method is used to push the content into the
internal buffer. It can be driven by the
\hyperref[readable_readsize]{\texttt{readable.\_read()}} method.

For streams not operating in object mode, if the \texttt{chunk}
parameter of \texttt{readable.push()} is \texttt{undefined}, it will be
treated as empty string or buffer. See
\hyperref[readablepush]{\texttt{readable.push(\textquotesingle{}\textquotesingle{})}}
for more information.

\paragraph{Errors while reading}\label{errors-while-reading}

Errors occurring during processing of the
\hyperref[readable_readsize]{\texttt{readable.\_read()}} must be
propagated through the
\hyperref[readable_destroyerr-callback]{\texttt{readable.destroy(err)}}
method. Throwing an \texttt{Error} from within
\hyperref[readable_readsize]{\texttt{readable.\_read()}} or manually
emitting an \texttt{\textquotesingle{}error\textquotesingle{}} event
results in undefined behavior.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Readable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ myReadable }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Readable}\NormalTok{(\{}
  \FunctionTok{read}\NormalTok{(size) \{}
    \KeywordTok{const}\NormalTok{ err }\OperatorTok{=} \FunctionTok{checkSomeErrorCondition}\NormalTok{()}\OperatorTok{;}
    \ControlFlowTok{if}\NormalTok{ (err) \{}
      \KeywordTok{this}\OperatorTok{.}\FunctionTok{destroy}\NormalTok{(err)}\OperatorTok{;}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \CommentTok{// Do some work.}
\NormalTok{    \}}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\paragraph{An example counting stream}\label{an-example-counting-stream}

The following is a basic example of a \texttt{Readable} stream that
emits the numerals from 1 to 1,000,000 in ascending order, and then
ends.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Readable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{class}\NormalTok{ Counter }\KeywordTok{extends}\NormalTok{ Readable \{}
  \FunctionTok{constructor}\NormalTok{(opt) \{}
    \KeywordTok{super}\NormalTok{(opt)}\OperatorTok{;}
    \KeywordTok{this}\OperatorTok{.}\AttributeTok{\_max} \OperatorTok{=} \DecValTok{1000000}\OperatorTok{;}
    \KeywordTok{this}\OperatorTok{.}\AttributeTok{\_index} \OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{  \}}

  \FunctionTok{\_read}\NormalTok{() \{}
    \KeywordTok{const}\NormalTok{ i }\OperatorTok{=} \KeywordTok{this}\OperatorTok{.}\AttributeTok{\_index}\OperatorTok{++;}
    \ControlFlowTok{if}\NormalTok{ (i }\OperatorTok{\textgreater{}} \KeywordTok{this}\OperatorTok{.}\AttributeTok{\_max}\NormalTok{)}
      \KeywordTok{this}\OperatorTok{.}\FunctionTok{push}\NormalTok{(}\KeywordTok{null}\NormalTok{)}\OperatorTok{;}
    \ControlFlowTok{else}\NormalTok{ \{}
      \KeywordTok{const}\NormalTok{ str }\OperatorTok{=} \BuiltInTok{String}\NormalTok{(i)}\OperatorTok{;}
      \KeywordTok{const}\NormalTok{ buf }\OperatorTok{=} \BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(str}\OperatorTok{,} \StringTok{\textquotesingle{}ascii\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
      \KeywordTok{this}\OperatorTok{.}\FunctionTok{push}\NormalTok{(buf)}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{Implementing a duplex
stream}\label{implementing-a-duplex-stream}

A \hyperref[class-streamduplex]{\texttt{Duplex}} stream is one that
implements both \hyperref[class-streamreadable]{\texttt{Readable}} and
\hyperref[class-streamwritable]{\texttt{Writable}}, such as a TCP socket
connection.

Because JavaScript does not have support for multiple inheritance, the
\texttt{stream.Duplex} class is extended to implement a
\hyperref[class-streamduplex]{\texttt{Duplex}} stream (as opposed to
extending the \texttt{stream.Readable} \emph{and}
\texttt{stream.Writable} classes).

The \texttt{stream.Duplex} class prototypically inherits from
\texttt{stream.Readable} and parasitically from
\texttt{stream.Writable}, but \texttt{instanceof} will work properly for
both base classes due to overriding
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance}{\texttt{Symbol.hasInstance}}
on \texttt{stream.Writable}.

Custom \texttt{Duplex} streams \emph{must} call the
\texttt{new\ stream.Duplex({[}options{]})} constructor and implement
\emph{both} the \hyperref[readable_readsize]{\texttt{readable.\_read()}}
and \texttt{writable.\_write()} methods.

\paragraph{\texorpdfstring{\texttt{new\ stream.Duplex(options)}}{new stream.Duplex(options)}}\label{new-stream.duplexoptions}

\begin{itemize}
\tightlist
\item
  \texttt{options} \{Object\} Passed to both \texttt{Writable} and
  \texttt{Readable} constructors. Also has the following fields:

  \begin{itemize}
  \tightlist
  \item
    \texttt{allowHalfOpen} \{boolean\} If set to \texttt{false}, then
    the stream will automatically end the writable side when the
    readable side ends. \textbf{Default:} \texttt{true}.
  \item
    \texttt{readable} \{boolean\} Sets whether the \texttt{Duplex}
    should be readable. \textbf{Default:} \texttt{true}.
  \item
    \texttt{writable} \{boolean\} Sets whether the \texttt{Duplex}
    should be writable. \textbf{Default:} \texttt{true}.
  \item
    \texttt{readableObjectMode} \{boolean\} Sets \texttt{objectMode} for
    readable side of the stream. Has no effect if \texttt{objectMode} is
    \texttt{true}. \textbf{Default:} \texttt{false}.
  \item
    \texttt{writableObjectMode} \{boolean\} Sets \texttt{objectMode} for
    writable side of the stream. Has no effect if \texttt{objectMode} is
    \texttt{true}. \textbf{Default:} \texttt{false}.
  \item
    \texttt{readableHighWaterMark} \{number\} Sets
    \texttt{highWaterMark} for the readable side of the stream. Has no
    effect if \texttt{highWaterMark} is provided.
  \item
    \texttt{writableHighWaterMark} \{number\} Sets
    \texttt{highWaterMark} for the writable side of the stream. Has no
    effect if \texttt{highWaterMark} is provided.
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Duplex \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{class}\NormalTok{ MyDuplex }\KeywordTok{extends}\NormalTok{ Duplex \{}
  \FunctionTok{constructor}\NormalTok{(options) \{}
    \KeywordTok{super}\NormalTok{(options)}\OperatorTok{;}
    \CommentTok{// ...}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Or, when using pre-ES6 style constructors:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Duplex \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ util }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:util\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{function} \FunctionTok{MyDuplex}\NormalTok{(options) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\NormalTok{(}\KeywordTok{this} \KeywordTok{instanceof}\NormalTok{ MyDuplex))}
    \ControlFlowTok{return} \KeywordTok{new} \FunctionTok{MyDuplex}\NormalTok{(options)}\OperatorTok{;}
\NormalTok{  Duplex}\OperatorTok{.}\FunctionTok{call}\NormalTok{(}\KeywordTok{this}\OperatorTok{,}\NormalTok{ options)}\OperatorTok{;}
\NormalTok{\}}
\NormalTok{util}\OperatorTok{.}\FunctionTok{inherits}\NormalTok{(MyDuplex}\OperatorTok{,}\NormalTok{ Duplex)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Or, using the simplified constructor approach:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Duplex \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ myDuplex }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Duplex}\NormalTok{(\{}
  \FunctionTok{read}\NormalTok{(size) \{}
    \CommentTok{// ...}
\NormalTok{  \}}\OperatorTok{,}
  \FunctionTok{write}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
    \CommentTok{// ...}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

When using pipeline:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Transform}\OperatorTok{,}\NormalTok{ pipeline \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\FunctionTok{pipeline}\NormalTok{(}
\NormalTok{  fs}\OperatorTok{.}\FunctionTok{createReadStream}\NormalTok{(}\StringTok{\textquotesingle{}object.json\textquotesingle{}}\NormalTok{)}
    \OperatorTok{.}\FunctionTok{setEncoding}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
  \KeywordTok{new} \FunctionTok{Transform}\NormalTok{(\{}
    \DataTypeTok{decodeStrings}\OperatorTok{:} \KeywordTok{false}\OperatorTok{,} \CommentTok{// Accept string input rather than Buffers}
    \FunctionTok{construct}\NormalTok{(callback) \{}
      \KeywordTok{this}\OperatorTok{.}\AttributeTok{data} \OperatorTok{=} \StringTok{\textquotesingle{}\textquotesingle{}}\OperatorTok{;}
      \FunctionTok{callback}\NormalTok{()}\OperatorTok{;}
\NormalTok{    \}}\OperatorTok{,}
    \FunctionTok{transform}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
      \KeywordTok{this}\OperatorTok{.}\AttributeTok{data} \OperatorTok{+=}\NormalTok{ chunk}\OperatorTok{;}
      \FunctionTok{callback}\NormalTok{()}\OperatorTok{;}
\NormalTok{    \}}\OperatorTok{,}
    \FunctionTok{flush}\NormalTok{(callback) \{}
      \ControlFlowTok{try}\NormalTok{ \{}
        \CommentTok{// Make sure is valid json.}
        \BuiltInTok{JSON}\OperatorTok{.}\FunctionTok{parse}\NormalTok{(}\KeywordTok{this}\OperatorTok{.}\AttributeTok{data}\NormalTok{)}\OperatorTok{;}
        \KeywordTok{this}\OperatorTok{.}\FunctionTok{push}\NormalTok{(}\KeywordTok{this}\OperatorTok{.}\AttributeTok{data}\NormalTok{)}\OperatorTok{;}
        \FunctionTok{callback}\NormalTok{()}\OperatorTok{;}
\NormalTok{      \} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
        \FunctionTok{callback}\NormalTok{(err)}\OperatorTok{;}
\NormalTok{      \}}
\NormalTok{    \}}\OperatorTok{,}
\NormalTok{  \})}\OperatorTok{,}
\NormalTok{  fs}\OperatorTok{.}\FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}valid{-}object.json\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
\NormalTok{  (err) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
    \ControlFlowTok{if}\NormalTok{ (err) \{}
      \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\StringTok{\textquotesingle{}failed\textquotesingle{}}\OperatorTok{,}\NormalTok{ err)}\OperatorTok{;}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
      \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}completed\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{    \}}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\paragraph{An example duplex stream}\label{an-example-duplex-stream}

The following illustrates a simple example of a \texttt{Duplex} stream
that wraps a hypothetical lower-level source object to which data can be
written, and from which data can be read, albeit using an API that is
not compatible with Node.js streams. The following illustrates a simple
example of a \texttt{Duplex} stream that buffers incoming written data
via the \hyperref[class-streamwritable]{\texttt{Writable}} interface
that is read back out via the
\hyperref[class-streamreadable]{\texttt{Readable}} interface.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Duplex \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ kSource }\OperatorTok{=} \BuiltInTok{Symbol}\NormalTok{(}\StringTok{\textquotesingle{}source\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{class}\NormalTok{ MyDuplex }\KeywordTok{extends}\NormalTok{ Duplex \{}
  \FunctionTok{constructor}\NormalTok{(source}\OperatorTok{,}\NormalTok{ options) \{}
    \KeywordTok{super}\NormalTok{(options)}\OperatorTok{;}
    \KeywordTok{this}\NormalTok{[kSource] }\OperatorTok{=}\NormalTok{ source}\OperatorTok{;}
\NormalTok{  \}}

  \FunctionTok{\_write}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
    \CommentTok{// The underlying source only deals with strings.}
    \ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{isBuffer}\NormalTok{(chunk))}
\NormalTok{      chunk }\OperatorTok{=}\NormalTok{ chunk}\OperatorTok{.}\FunctionTok{toString}\NormalTok{()}\OperatorTok{;}
    \KeywordTok{this}\NormalTok{[kSource]}\OperatorTok{.}\FunctionTok{writeSomeData}\NormalTok{(chunk)}\OperatorTok{;}
    \FunctionTok{callback}\NormalTok{()}\OperatorTok{;}
\NormalTok{  \}}

  \FunctionTok{\_read}\NormalTok{(size) \{}
    \KeywordTok{this}\NormalTok{[kSource]}\OperatorTok{.}\FunctionTok{fetchSomeData}\NormalTok{(size}\OperatorTok{,}\NormalTok{ (data}\OperatorTok{,}\NormalTok{ encoding) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
      \KeywordTok{this}\OperatorTok{.}\FunctionTok{push}\NormalTok{(}\BuiltInTok{Buffer}\OperatorTok{.}\FunctionTok{from}\NormalTok{(data}\OperatorTok{,}\NormalTok{ encoding))}\OperatorTok{;}
\NormalTok{    \})}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The most important aspect of a \texttt{Duplex} stream is that the
\texttt{Readable} and \texttt{Writable} sides operate independently of
one another despite co-existing within a single object instance.

\paragraph{Object mode duplex streams}\label{object-mode-duplex-streams}

For \texttt{Duplex} streams, \texttt{objectMode} can be set exclusively
for either the \texttt{Readable} or \texttt{Writable} side using the
\texttt{readableObjectMode} and \texttt{writableObjectMode} options
respectively.

In the following example, for instance, a new \texttt{Transform} stream
(which is a type of \hyperref[class-streamduplex]{\texttt{Duplex}}
stream) is created that has an object mode \texttt{Writable} side that
accepts JavaScript numbers that are converted to hexadecimal strings on
the \texttt{Readable} side.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Transform \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// All Transform streams are also Duplex Streams.}
\KeywordTok{const}\NormalTok{ myTransform }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Transform}\NormalTok{(\{}
  \DataTypeTok{writableObjectMode}\OperatorTok{:} \KeywordTok{true}\OperatorTok{,}

  \FunctionTok{transform}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
    \CommentTok{// Coerce the chunk to a number if necessary.}
\NormalTok{    chunk }\OperatorTok{|=} \DecValTok{0}\OperatorTok{;}

    \CommentTok{// Transform the chunk into something else.}
    \KeywordTok{const}\NormalTok{ data }\OperatorTok{=}\NormalTok{ chunk}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{16}\NormalTok{)}\OperatorTok{;}

    \CommentTok{// Push the data onto the readable queue.}
    \FunctionTok{callback}\NormalTok{(}\KeywordTok{null}\OperatorTok{,} \StringTok{\textquotesingle{}0\textquotesingle{}}\OperatorTok{.}\FunctionTok{repeat}\NormalTok{(data}\OperatorTok{.}\AttributeTok{length} \OperatorTok{\%} \DecValTok{2}\NormalTok{) }\OperatorTok{+}\NormalTok{ data)}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}

\NormalTok{myTransform}\OperatorTok{.}\FunctionTok{setEncoding}\NormalTok{(}\StringTok{\textquotesingle{}ascii\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{myTransform}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}data\textquotesingle{}}\OperatorTok{,}\NormalTok{ (chunk) }\KeywordTok{=\textgreater{}} \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(chunk))}\OperatorTok{;}

\NormalTok{myTransform}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\DecValTok{1}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 01}
\NormalTok{myTransform}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\DecValTok{10}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 0a}
\NormalTok{myTransform}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\DecValTok{100}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Prints: 64}
\end{Highlighting}
\end{Shaded}

\subsubsection{Implementing a transform
stream}\label{implementing-a-transform-stream}

A \hyperref[class-streamtransform]{\texttt{Transform}} stream is a
\hyperref[class-streamduplex]{\texttt{Duplex}} stream where the output
is computed in some way from the input. Examples include
\href{zlib.md}{zlib} streams or \href{crypto.md}{crypto} streams that
compress, encrypt, or decrypt data.

There is no requirement that the output be the same size as the input,
the same number of chunks, or arrive at the same time. For example, a
\texttt{Hash} stream will only ever have a single chunk of output which
is provided when the input is ended. A \texttt{zlib} stream will produce
output that is either much smaller or much larger than its input.

The \texttt{stream.Transform} class is extended to implement a
\hyperref[class-streamtransform]{\texttt{Transform}} stream.

The \texttt{stream.Transform} class prototypically inherits from
\texttt{stream.Duplex} and implements its own versions of the
\texttt{writable.\_write()} and
\hyperref[readable_readsize]{\texttt{readable.\_read()}} methods. Custom
\texttt{Transform} implementations \emph{must} implement the
\hyperref[transform_transformchunk-encoding-callback]{\texttt{transform.\_transform()}}
method and \emph{may} also implement the
\hyperref[transform_flushcallback]{\texttt{transform.\_flush()}} method.

Care must be taken when using \texttt{Transform} streams in that data
written to the stream can cause the \texttt{Writable} side of the stream
to become paused if the output on the \texttt{Readable} side is not
consumed.

\paragraph{\texorpdfstring{\texttt{new\ stream.Transform({[}options{]})}}{new stream.Transform({[}options{]})}}\label{new-stream.transformoptions}

\begin{itemize}
\tightlist
\item
  \texttt{options} \{Object\} Passed to both \texttt{Writable} and
  \texttt{Readable} constructors. Also has the following fields:

  \begin{itemize}
  \tightlist
  \item
    \texttt{transform} \{Function\} Implementation for the
    \hyperref[transform_transformchunk-encoding-callback]{\texttt{stream.\_transform()}}
    method.
  \item
    \texttt{flush} \{Function\} Implementation for the
    \hyperref[transform_flushcallback]{\texttt{stream.\_flush()}}
    method.
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Transform \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{class}\NormalTok{ MyTransform }\KeywordTok{extends}\NormalTok{ Transform \{}
  \FunctionTok{constructor}\NormalTok{(options) \{}
    \KeywordTok{super}\NormalTok{(options)}\OperatorTok{;}
    \CommentTok{// ...}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Or, when using pre-ES6 style constructors:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Transform \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ util }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:util\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{function} \FunctionTok{MyTransform}\NormalTok{(options) \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\NormalTok{(}\KeywordTok{this} \KeywordTok{instanceof}\NormalTok{ MyTransform))}
    \ControlFlowTok{return} \KeywordTok{new} \FunctionTok{MyTransform}\NormalTok{(options)}\OperatorTok{;}
\NormalTok{  Transform}\OperatorTok{.}\FunctionTok{call}\NormalTok{(}\KeywordTok{this}\OperatorTok{,}\NormalTok{ options)}\OperatorTok{;}
\NormalTok{\}}
\NormalTok{util}\OperatorTok{.}\FunctionTok{inherits}\NormalTok{(MyTransform}\OperatorTok{,}\NormalTok{ Transform)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Or, using the simplified constructor approach:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Transform \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ myTransform }\OperatorTok{=} \KeywordTok{new} \FunctionTok{Transform}\NormalTok{(\{}
  \FunctionTok{transform}\NormalTok{(chunk}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
    \CommentTok{// ...}
\NormalTok{  \}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\paragraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}end\textquotesingle{}}}{Event: \textquotesingle end\textquotesingle{}}}\label{event-end-1}

The
\hyperref[event-end]{\texttt{\textquotesingle{}end\textquotesingle{}}}
event is from the \texttt{stream.Readable} class. The
\texttt{\textquotesingle{}end\textquotesingle{}} event is emitted after
all data has been output, which occurs after the callback in
\hyperref[transform_flushcallback]{\texttt{transform.\_flush()}} has
been called. In the case of an error,
\texttt{\textquotesingle{}end\textquotesingle{}} should not be emitted.

\paragraph{\texorpdfstring{Event:
\texttt{\textquotesingle{}finish\textquotesingle{}}}{Event: \textquotesingle finish\textquotesingle{}}}\label{event-finish-1}

The
\hyperref[event-finish]{\texttt{\textquotesingle{}finish\textquotesingle{}}}
event is from the \texttt{stream.Writable} class. The
\texttt{\textquotesingle{}finish\textquotesingle{}} event is emitted
after
\hyperref[writableendchunk-encoding-callback]{\texttt{stream.end()}} is
called and all chunks have been processed by
\hyperref[transform_transformchunk-encoding-callback]{\texttt{stream.\_transform()}}.
In the case of an error,
\texttt{\textquotesingle{}finish\textquotesingle{}} should not be
emitted.

\paragraph{\texorpdfstring{\texttt{transform.\_flush(callback)}}{transform.\_flush(callback)}}\label{transform._flushcallback}

\begin{itemize}
\tightlist
\item
  \texttt{callback} \{Function\} A callback function (optionally with an
  error argument and data) to be called when remaining data has been
  flushed.
\end{itemize}

This function MUST NOT be called by application code directly. It should
be implemented by child classes, and called by the internal
\texttt{Readable} class methods only.

In some cases, a transform operation may need to emit an additional bit
of data at the end of the stream. For example, a \texttt{zlib}
compression stream will store an amount of internal state used to
optimally compress the output. When the stream ends, however, that
additional data needs to be flushed so that the compressed data will be
complete.

Custom \hyperref[class-streamtransform]{\texttt{Transform}}
implementations \emph{may} implement the \texttt{transform.\_flush()}
method. This will be called when there is no more written data to be
consumed, but before the
\hyperref[event-end]{\texttt{\textquotesingle{}end\textquotesingle{}}}
event is emitted signaling the end of the
\hyperref[class-streamreadable]{\texttt{Readable}} stream.

Within the \texttt{transform.\_flush()} implementation, the
\texttt{transform.push()} method may be called zero or more times, as
appropriate. The \texttt{callback} function must be called when the
flush operation is complete.

The \texttt{transform.\_flush()} method is prefixed with an underscore
because it is internal to the class that defines it, and should never be
called directly by user programs.

\paragraph{\texorpdfstring{\texttt{transform.\_transform(chunk,\ encoding,\ callback)}}{transform.\_transform(chunk, encoding, callback)}}\label{transform._transformchunk-encoding-callback}

\begin{itemize}
\tightlist
\item
  \texttt{chunk} \{Buffer\textbar string\textbar any\} The
  \texttt{Buffer} to be transformed, converted from the \texttt{string}
  passed to
  \hyperref[writablewritechunk-encoding-callback]{\texttt{stream.write()}}.
  If the stream's \texttt{decodeStrings} option is \texttt{false} or the
  stream is operating in object mode, the chunk will not be converted \&
  will be whatever was passed to
  \hyperref[writablewritechunk-encoding-callback]{\texttt{stream.write()}}.
\item
  \texttt{encoding} \{string\} If the chunk is a string, then this is
  the encoding type. If chunk is a buffer, then this is the special
  value \texttt{\textquotesingle{}buffer\textquotesingle{}}. Ignore it
  in that case.
\item
  \texttt{callback} \{Function\} A callback function (optionally with an
  error argument and data) to be called after the supplied
  \texttt{chunk} has been processed.
\end{itemize}

This function MUST NOT be called by application code directly. It should
be implemented by child classes, and called by the internal
\texttt{Readable} class methods only.

All \texttt{Transform} stream implementations must provide a
\texttt{\_transform()} method to accept input and produce output. The
\texttt{transform.\_transform()} implementation handles the bytes being
written, computes an output, then passes that output off to the readable
portion using the \texttt{transform.push()} method.

The \texttt{transform.push()} method may be called zero or more times to
generate output from a single input chunk, depending on how much is to
be output as a result of the chunk.

It is possible that no output is generated from any given chunk of input
data.

The \texttt{callback} function must be called only when the current
chunk is completely consumed. The first argument passed to the
\texttt{callback} must be an \texttt{Error} object if an error occurred
while processing the input or \texttt{null} otherwise. If a second
argument is passed to the \texttt{callback}, it will be forwarded on to
the \texttt{transform.push()} method, but only if the first argument is
falsy. In other words, the following are equivalent:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{transform}\OperatorTok{.}\AttributeTok{prototype}\OperatorTok{.}\AttributeTok{\_transform} \OperatorTok{=} \KeywordTok{function}\NormalTok{(data}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
  \KeywordTok{this}\OperatorTok{.}\FunctionTok{push}\NormalTok{(data)}\OperatorTok{;}
  \FunctionTok{callback}\NormalTok{()}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{;}

\NormalTok{transform}\OperatorTok{.}\AttributeTok{prototype}\OperatorTok{.}\AttributeTok{\_transform} \OperatorTok{=} \KeywordTok{function}\NormalTok{(data}\OperatorTok{,}\NormalTok{ encoding}\OperatorTok{,}\NormalTok{ callback) \{}
  \FunctionTok{callback}\NormalTok{(}\KeywordTok{null}\OperatorTok{,}\NormalTok{ data)}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The \texttt{transform.\_transform()} method is prefixed with an
underscore because it is internal to the class that defines it, and
should never be called directly by user programs.

\texttt{transform.\_transform()} is never called in parallel; streams
implement a queue mechanism, and to receive the next chunk,
\texttt{callback} must be called, either synchronously or
asynchronously.

\paragraph{\texorpdfstring{Class:
\texttt{stream.PassThrough}}{Class: stream.PassThrough}}\label{class-stream.passthrough}

The \texttt{stream.PassThrough} class is a trivial implementation of a
\hyperref[class-streamtransform]{\texttt{Transform}} stream that simply
passes the input bytes across to the output. Its purpose is primarily
for examples and testing, but there are some use cases where
\texttt{stream.PassThrough} is useful as a building block for novel
sorts of streams.

\subsection{Additional notes}\label{additional-notes}

\subsubsection{Streams compatibility with async generators and async
iterators}\label{streams-compatibility-with-async-generators-and-async-iterators}

With the support of async generators and iterators in JavaScript, async
generators are effectively a first-class language-level stream construct
at this point.

Some common interop cases of using Node.js streams with async generators
and async iterators are provided below.

\paragraph{Consuming readable streams with async
iterators}\label{consuming-readable-streams-with-async-iterators}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\KeywordTok{async} \KeywordTok{function}\NormalTok{() \{}
  \ControlFlowTok{for} \ControlFlowTok{await}\NormalTok{ (}\KeywordTok{const}\NormalTok{ chunk }\KeywordTok{of}\NormalTok{ readable) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(chunk)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\})()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Async iterators register a permanent error handler on the stream to
prevent any unhandled post-destroy errors.

\paragraph{Creating readable streams with async
generators}\label{creating-readable-streams-with-async-generators}

A Node.js readable stream can be created from an asynchronous generator
using the \texttt{Readable.from()} utility method:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ Readable \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ ac }\OperatorTok{=} \KeywordTok{new} \FunctionTok{AbortController}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ signal }\OperatorTok{=}\NormalTok{ ac}\OperatorTok{.}\AttributeTok{signal}\OperatorTok{;}

\KeywordTok{async} \KeywordTok{function} \OperatorTok{*} \FunctionTok{generate}\NormalTok{() \{}
  \KeywordTok{yield} \StringTok{\textquotesingle{}a\textquotesingle{}}\OperatorTok{;}
  \ControlFlowTok{await} \FunctionTok{someLongRunningFn}\NormalTok{(\{ signal \})}\OperatorTok{;}
  \KeywordTok{yield} \StringTok{\textquotesingle{}b\textquotesingle{}}\OperatorTok{;}
  \KeywordTok{yield} \StringTok{\textquotesingle{}c\textquotesingle{}}\OperatorTok{;}
\NormalTok{\}}

\KeywordTok{const}\NormalTok{ readable }\OperatorTok{=}\NormalTok{ Readable}\OperatorTok{.}\FunctionTok{from}\NormalTok{(}\FunctionTok{generate}\NormalTok{())}\OperatorTok{;}
\NormalTok{readable}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}close\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  ac}\OperatorTok{.}\FunctionTok{abort}\NormalTok{()}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\NormalTok{readable}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}data\textquotesingle{}}\OperatorTok{,}\NormalTok{ (chunk) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(chunk)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\paragraph{Piping to writable streams from async
iterators}\label{piping-to-writable-streams-from-async-iterators}

When writing to a writable stream from an async iterator, ensure correct
handling of backpressure and errors.
\hyperref[streampipelinesource-transforms-destination-callback]{\texttt{stream.pipeline()}}
abstracts away the handling of backpressure and backpressure-related
errors:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ \{ pipeline \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ \{ }\DataTypeTok{pipeline}\OperatorTok{:}\NormalTok{ pipelinePromise \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:stream/promises\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ writable }\OperatorTok{=}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}./file\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ ac }\OperatorTok{=} \KeywordTok{new} \FunctionTok{AbortController}\NormalTok{()}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ signal }\OperatorTok{=}\NormalTok{ ac}\OperatorTok{.}\AttributeTok{signal}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ iterator }\OperatorTok{=} \FunctionTok{createIterator}\NormalTok{(\{ signal \})}\OperatorTok{;}

\CommentTok{// Callback Pattern}
\FunctionTok{pipeline}\NormalTok{(iterator}\OperatorTok{,}\NormalTok{ writable}\OperatorTok{,}\NormalTok{ (err}\OperatorTok{,}\NormalTok{ value) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \ControlFlowTok{if}\NormalTok{ (err) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(err)}\OperatorTok{;}
\NormalTok{  \} }\ControlFlowTok{else}\NormalTok{ \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(value}\OperatorTok{,} \StringTok{\textquotesingle{}value returned\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\})}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}close\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  ac}\OperatorTok{.}\FunctionTok{abort}\NormalTok{()}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\CommentTok{// Promise Pattern}
\FunctionTok{pipelinePromise}\NormalTok{(iterator}\OperatorTok{,}\NormalTok{ writable)}
  \OperatorTok{.}\FunctionTok{then}\NormalTok{((value) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(value}\OperatorTok{,} \StringTok{\textquotesingle{}value returned\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \})}
  \OperatorTok{.}\FunctionTok{catch}\NormalTok{((err) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(err)}\OperatorTok{;}
\NormalTok{    ac}\OperatorTok{.}\FunctionTok{abort}\NormalTok{()}\OperatorTok{;}
\NormalTok{  \})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{Compatibility with older Node.js
versions}\label{compatibility-with-older-node.js-versions}

Prior to Node.js 0.10, the \texttt{Readable} stream interface was
simpler, but also less powerful and less useful.

\begin{itemize}
\tightlist
\item
  Rather than waiting for calls to the
  \hyperref[readablereadsize]{\texttt{stream.read()}} method,
  \hyperref[event-data]{\texttt{\textquotesingle{}data\textquotesingle{}}}
  events would begin emitting immediately. Applications that would need
  to perform some amount of work to decide how to handle data were
  required to store read data into buffers so the data would not be
  lost.
\item
  The \hyperref[readablepause]{\texttt{stream.pause()}} method was
  advisory, rather than guaranteed. This meant that it was still
  necessary to be prepared to receive
  \hyperref[event-data]{\texttt{\textquotesingle{}data\textquotesingle{}}}
  events \emph{even when the stream was in a paused state}.
\end{itemize}

In Node.js 0.10, the \hyperref[class-streamreadable]{\texttt{Readable}}
class was added. For backward compatibility with older Node.js programs,
\texttt{Readable} streams switch into ``flowing mode'' when a
\hyperref[event-data]{\texttt{\textquotesingle{}data\textquotesingle{}}}
event handler is added, or when the
\hyperref[readableresume]{\texttt{stream.resume()}} method is called.
The effect is that, even when not using the new
\hyperref[readablereadsize]{\texttt{stream.read()}} method and
\hyperref[event-readable]{\texttt{\textquotesingle{}readable\textquotesingle{}}}
event, it is no longer necessary to worry about losing
\hyperref[event-data]{\texttt{\textquotesingle{}data\textquotesingle{}}}
chunks.

While most applications will continue to function normally, this
introduces an edge case in the following conditions:

\begin{itemize}
\tightlist
\item
  No
  \hyperref[event-data]{\texttt{\textquotesingle{}data\textquotesingle{}}}
  event listener is added.
\item
  The \hyperref[readableresume]{\texttt{stream.resume()}} method is
  never called.
\item
  The stream is not piped to any writable destination.
\end{itemize}

For example, consider the following code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// }\AlertTok{WARNING}\CommentTok{!  BROKEN!}
\NormalTok{net}\OperatorTok{.}\FunctionTok{createServer}\NormalTok{((socket) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}

  \CommentTok{// We add an \textquotesingle{}end\textquotesingle{} listener, but never consume the data.}
\NormalTok{  socket}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}end\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
    \CommentTok{// It will never get here.}
\NormalTok{    socket}\OperatorTok{.}\FunctionTok{end}\NormalTok{(}\StringTok{\textquotesingle{}The message was received but was not processed.}\SpecialCharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \})}\OperatorTok{;}

\NormalTok{\})}\OperatorTok{.}\FunctionTok{listen}\NormalTok{(}\DecValTok{1337}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Prior to Node.js 0.10, the incoming message data would be simply
discarded. However, in Node.js 0.10 and beyond, the socket remains
paused forever.

The workaround in this situation is to call the
\hyperref[readableresume]{\texttt{stream.resume()}} method to begin the
flow of data:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Workaround.}
\NormalTok{net}\OperatorTok{.}\FunctionTok{createServer}\NormalTok{((socket) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  socket}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}end\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{    socket}\OperatorTok{.}\FunctionTok{end}\NormalTok{(}\StringTok{\textquotesingle{}The message was received but was not processed.}\SpecialCharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \})}\OperatorTok{;}

  \CommentTok{// Start the flow of data, discarding it.}
\NormalTok{  socket}\OperatorTok{.}\FunctionTok{resume}\NormalTok{()}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{.}\FunctionTok{listen}\NormalTok{(}\DecValTok{1337}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

In addition to new \texttt{Readable} streams switching into flowing
mode, pre-0.10 style streams can be wrapped in a \texttt{Readable} class
using the \hyperref[readablewrapstream]{\texttt{readable.wrap()}}
method.

\subsubsection{\texorpdfstring{\texttt{readable.read(0)}}{readable.read(0)}}\label{readable.read0}

There are some cases where it is necessary to trigger a refresh of the
underlying readable stream mechanisms, without actually consuming any
data. In such cases, it is possible to call \texttt{readable.read(0)},
which will always return \texttt{null}.

If the internal read buffer is below the \texttt{highWaterMark}, and the
stream is not currently reading, then calling \texttt{stream.read(0)}
will trigger a low-level
\hyperref[readable_readsize]{\texttt{stream.\_read()}} call.

While most applications will almost never need to do this, there are
situations within Node.js where this is done, particularly in the
\texttt{Readable} stream class internals.

\subsubsection{\texorpdfstring{\texttt{readable.push(\textquotesingle{}\textquotesingle{})}}{readable.push(\textquotesingle\textquotesingle)}}\label{readable.push}

Use of \texttt{readable.push(\textquotesingle{}\textquotesingle{})} is
not recommended.

Pushing a zero-byte string, \texttt{Buffer}, or \texttt{Uint8Array} to a
stream that is not in object mode has an interesting side effect.
Because it \emph{is} a call to
\hyperref[readablepushchunk-encoding]{\texttt{readable.push()}}, the
call will end the reading process. However, because the argument is an
empty string, no data is added to the readable buffer so there is
nothing for a user to consume.

\subsubsection{\texorpdfstring{\texttt{highWaterMark} discrepancy after
calling
\texttt{readable.setEncoding()}}{highWaterMark discrepancy after calling readable.setEncoding()}}\label{highwatermark-discrepancy-after-calling-readable.setencoding}

The use of \texttt{readable.setEncoding()} will change the behavior of
how the \texttt{highWaterMark} operates in non-object mode.

Typically, the size of the current buffer is measured against the
\texttt{highWaterMark} in \emph{bytes}. However, after
\texttt{setEncoding()} is called, the comparison function will begin to
measure the buffer's size in \emph{characters}.

This is not a problem in common cases with \texttt{latin1} or
\texttt{ascii}. But it is advised to be mindful about this behavior when
working with strings that could contain multi-byte characters.
