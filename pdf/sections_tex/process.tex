\section{Process}\label{process}

The \texttt{process} object provides information about, and control
over, the current Node.js process.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{Process events}\label{process-events}

The \texttt{process} object is an instance of
\href{events.md\#class-eventemitter}{\texttt{EventEmitter}}.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}beforeExit\textquotesingle{}}}{Event: \textquotesingle beforeExit\textquotesingle{}}}\label{event-beforeexit}

The \texttt{\textquotesingle{}beforeExit\textquotesingle{}} event is
emitted when Node.js empties its event loop and has no additional work
to schedule. Normally, the Node.js process will exit when there is no
work scheduled, but a listener registered on the
\texttt{\textquotesingle{}beforeExit\textquotesingle{}} event can make
asynchronous calls, and thereby cause the Node.js process to continue.

The listener callback function is invoked with the value of
\hyperref[processexitcode_1]{\texttt{process.exitCode}} passed as the
only argument.

The \texttt{\textquotesingle{}beforeExit\textquotesingle{}} event is
\emph{not} emitted for conditions causing explicit termination, such as
calling \hyperref[processexitcode]{\texttt{process.exit()}} or uncaught
exceptions.

The \texttt{\textquotesingle{}beforeExit\textquotesingle{}} should
\emph{not} be used as an alternative to the
\texttt{\textquotesingle{}exit\textquotesingle{}} event unless the
intention is to schedule additional work.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}beforeExit\textquotesingle{}}\OperatorTok{,}\NormalTok{ (code) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Process beforeExit event with code: \textquotesingle{}}\OperatorTok{,}\NormalTok{ code)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}exit\textquotesingle{}}\OperatorTok{,}\NormalTok{ (code) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Process exit event with code: \textquotesingle{}}\OperatorTok{,}\NormalTok{ code)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}This message is displayed first.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Prints:}
\CommentTok{// This message is displayed first.}
\CommentTok{// Process beforeExit event with code: 0}
\CommentTok{// Process exit event with code: 0}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}beforeExit\textquotesingle{}}\OperatorTok{,}\NormalTok{ (code) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Process beforeExit event with code: \textquotesingle{}}\OperatorTok{,}\NormalTok{ code)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}exit\textquotesingle{}}\OperatorTok{,}\NormalTok{ (code) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Process exit event with code: \textquotesingle{}}\OperatorTok{,}\NormalTok{ code)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}This message is displayed first.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Prints:}
\CommentTok{// This message is displayed first.}
\CommentTok{// Process beforeExit event with code: 0}
\CommentTok{// Process exit event with code: 0}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}disconnect\textquotesingle{}}}{Event: \textquotesingle disconnect\textquotesingle{}}}\label{event-disconnect}

If the Node.js process is spawned with an IPC channel (see the
\href{child_process.md}{Child Process} and \href{cluster.md}{Cluster}
documentation), the
\texttt{\textquotesingle{}disconnect\textquotesingle{}} event will be
emitted when the IPC channel is closed.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}exit\textquotesingle{}}}{Event: \textquotesingle exit\textquotesingle{}}}\label{event-exit}

\begin{itemize}
\tightlist
\item
  \texttt{code} \{integer\}
\end{itemize}

The \texttt{\textquotesingle{}exit\textquotesingle{}} event is emitted
when the Node.js process is about to exit as a result of either:

\begin{itemize}
\tightlist
\item
  The \texttt{process.exit()} method being called explicitly;
\item
  The Node.js event loop no longer having any additional work to
  perform.
\end{itemize}

There is no way to prevent the exiting of the event loop at this point,
and once all \texttt{\textquotesingle{}exit\textquotesingle{}} listeners
have finished running the Node.js process will terminate.

The listener callback function is invoked with the exit code specified
either by the \hyperref[processexitcode_1]{\texttt{process.exitCode}}
property, or the \texttt{exitCode} argument passed to the
\hyperref[processexitcode]{\texttt{process.exit()}} method.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}exit\textquotesingle{}}\OperatorTok{,}\NormalTok{ (code) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}About to exit with code: }\SpecialCharTok{$\{}\NormalTok{code}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}exit\textquotesingle{}}\OperatorTok{,}\NormalTok{ (code) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}About to exit with code: }\SpecialCharTok{$\{}\NormalTok{code}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Listener functions \textbf{must} only perform \textbf{synchronous}
operations. The Node.js process will exit immediately after calling the
\texttt{\textquotesingle{}exit\textquotesingle{}} event listeners
causing any additional work still queued in the event loop to be
abandoned. In the following example, for instance, the timeout will
never occur:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}exit\textquotesingle{}}\OperatorTok{,}\NormalTok{ (code) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}This will not run\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}exit\textquotesingle{}}\OperatorTok{,}\NormalTok{ (code) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}This will not run\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}\OperatorTok{,} \DecValTok{0}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}message\textquotesingle{}}}{Event: \textquotesingle message\textquotesingle{}}}\label{event-message}

\begin{itemize}
\tightlist
\item
  \texttt{message} \{ Object \textbar{} boolean \textbar{} number
  \textbar{} string \textbar{} null \} a parsed JSON object or a
  serializable primitive value.
\item
  \texttt{sendHandle} \{net.Server\textbar net.Socket\} a
  \href{net.md\#class-netserver}{\texttt{net.Server}} or
  \href{net.md\#class-netsocket}{\texttt{net.Socket}} object, or
  undefined.
\end{itemize}

If the Node.js process is spawned with an IPC channel (see the
\href{child_process.md}{Child Process} and \href{cluster.md}{Cluster}
documentation), the \texttt{\textquotesingle{}message\textquotesingle{}}
event is emitted whenever a message sent by a parent process using
\href{child_process.md\#subprocesssendmessage-sendhandle-options-callback}{\texttt{childprocess.send()}}
is received by the child process.

The message goes through serialization and parsing. The resulting
message might not be the same as what is originally sent.

If the \texttt{serialization} option was set to \texttt{advanced} used
when spawning the process, the \texttt{message} argument can contain
data that JSON is not able to represent. See
\href{child_process.md\#advanced-serialization}{Advanced serialization
for \texttt{child\_process}} for more details.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}multipleResolves\textquotesingle{}}}{Event: \textquotesingle multipleResolves\textquotesingle{}}}\label{event-multipleresolves}

\begin{quote}
Stability: 0 - Deprecated
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{type} \{string\} The resolution type. One of
  \texttt{\textquotesingle{}resolve\textquotesingle{}} or
  \texttt{\textquotesingle{}reject\textquotesingle{}}.
\item
  \texttt{promise} \{Promise\} The promise that resolved or rejected
  more than once.
\item
  \texttt{value} \{any\} The value with which the promise was either
  resolved or rejected after the original resolve.
\end{itemize}

The \texttt{\textquotesingle{}multipleResolves\textquotesingle{}} event
is emitted whenever a \texttt{Promise} has been either:

\begin{itemize}
\tightlist
\item
  Resolved more than once.
\item
  Rejected more than once.
\item
  Rejected after resolve.
\item
  Resolved after reject.
\end{itemize}

This is useful for tracking potential errors in an application while
using the \texttt{Promise} constructor, as multiple resolutions are
silently swallowed. However, the occurrence of this event does not
necessarily indicate an error. For example,
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race}{\texttt{Promise.race()}}
can trigger a
\texttt{\textquotesingle{}multipleResolves\textquotesingle{}} event.

Because of the unreliability of the event in cases like the
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race}{\texttt{Promise.race()}}
example above it has been deprecated.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}multipleResolves\textquotesingle{}}\OperatorTok{,}\NormalTok{ (type}\OperatorTok{,}\NormalTok{ promise}\OperatorTok{,}\NormalTok{ reason) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(type}\OperatorTok{,}\NormalTok{ promise}\OperatorTok{,}\NormalTok{ reason)}\OperatorTok{;}
  \FunctionTok{setImmediate}\NormalTok{(() }\KeywordTok{=\textgreater{}} \BuiltInTok{process}\OperatorTok{.}\FunctionTok{exit}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\KeywordTok{async} \KeywordTok{function} \FunctionTok{main}\NormalTok{() \{}
  \ControlFlowTok{try}\NormalTok{ \{}
    \ControlFlowTok{return} \ControlFlowTok{await} \KeywordTok{new} \BuiltInTok{Promise}\NormalTok{((resolve}\OperatorTok{,}\NormalTok{ reject) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
      \FunctionTok{resolve}\NormalTok{(}\StringTok{\textquotesingle{}First call\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
      \FunctionTok{resolve}\NormalTok{(}\StringTok{\textquotesingle{}Swallowed resolve\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
      \FunctionTok{reject}\NormalTok{(}\KeywordTok{new} \BuiltInTok{Error}\NormalTok{(}\StringTok{\textquotesingle{}Swallowed reject\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\NormalTok{    \})}\OperatorTok{;}
\NormalTok{  \} }\ControlFlowTok{catch}\NormalTok{ \{}
    \ControlFlowTok{throw} \KeywordTok{new} \BuiltInTok{Error}\NormalTok{(}\StringTok{\textquotesingle{}Failed\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}

\FunctionTok{main}\NormalTok{()}\OperatorTok{.}\FunctionTok{then}\NormalTok{(}\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{)}\OperatorTok{;}
\CommentTok{// resolve: Promise \{ \textquotesingle{}First call\textquotesingle{} \} \textquotesingle{}Swallowed resolve\textquotesingle{}}
\CommentTok{// reject: Promise \{ \textquotesingle{}First call\textquotesingle{} \} Error: Swallowed reject}
\CommentTok{//     at Promise (*)}
\CommentTok{//     at new Promise (\textless{}anonymous\textgreater{})}
\CommentTok{//     at main (*)}
\CommentTok{// First call}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}multipleResolves\textquotesingle{}}\OperatorTok{,}\NormalTok{ (type}\OperatorTok{,}\NormalTok{ promise}\OperatorTok{,}\NormalTok{ reason) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(type}\OperatorTok{,}\NormalTok{ promise}\OperatorTok{,}\NormalTok{ reason)}\OperatorTok{;}
  \FunctionTok{setImmediate}\NormalTok{(() }\KeywordTok{=\textgreater{}} \BuiltInTok{process}\OperatorTok{.}\FunctionTok{exit}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\KeywordTok{async} \KeywordTok{function} \FunctionTok{main}\NormalTok{() \{}
  \ControlFlowTok{try}\NormalTok{ \{}
    \ControlFlowTok{return} \ControlFlowTok{await} \KeywordTok{new} \BuiltInTok{Promise}\NormalTok{((resolve}\OperatorTok{,}\NormalTok{ reject) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
      \FunctionTok{resolve}\NormalTok{(}\StringTok{\textquotesingle{}First call\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
      \FunctionTok{resolve}\NormalTok{(}\StringTok{\textquotesingle{}Swallowed resolve\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
      \FunctionTok{reject}\NormalTok{(}\KeywordTok{new} \BuiltInTok{Error}\NormalTok{(}\StringTok{\textquotesingle{}Swallowed reject\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\NormalTok{    \})}\OperatorTok{;}
\NormalTok{  \} }\ControlFlowTok{catch}\NormalTok{ \{}
    \ControlFlowTok{throw} \KeywordTok{new} \BuiltInTok{Error}\NormalTok{(}\StringTok{\textquotesingle{}Failed\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}

\FunctionTok{main}\NormalTok{()}\OperatorTok{.}\FunctionTok{then}\NormalTok{(}\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{)}\OperatorTok{;}
\CommentTok{// resolve: Promise \{ \textquotesingle{}First call\textquotesingle{} \} \textquotesingle{}Swallowed resolve\textquotesingle{}}
\CommentTok{// reject: Promise \{ \textquotesingle{}First call\textquotesingle{} \} Error: Swallowed reject}
\CommentTok{//     at Promise (*)}
\CommentTok{//     at new Promise (\textless{}anonymous\textgreater{})}
\CommentTok{//     at main (*)}
\CommentTok{// First call}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}rejectionHandled\textquotesingle{}}}{Event: \textquotesingle rejectionHandled\textquotesingle{}}}\label{event-rejectionhandled}

\begin{itemize}
\tightlist
\item
  \texttt{promise} \{Promise\} The late handled promise.
\end{itemize}

The \texttt{\textquotesingle{}rejectionHandled\textquotesingle{}} event
is emitted whenever a \texttt{Promise} has been rejected and an error
handler was attached to it (using
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch}{\texttt{promise.catch()}},
for example) later than one turn of the Node.js event loop.

The \texttt{Promise} object would have previously been emitted in an
\texttt{\textquotesingle{}unhandledRejection\textquotesingle{}} event,
but during the course of processing gained a rejection handler.

There is no notion of a top level for a \texttt{Promise} chain at which
rejections can always be handled. Being inherently asynchronous in
nature, a \texttt{Promise} rejection can be handled at a future point in
time, possibly much later than the event loop turn it takes for the
\texttt{\textquotesingle{}unhandledRejection\textquotesingle{}} event to
be emitted.

Another way of stating this is that, unlike in synchronous code where
there is an ever-growing list of unhandled exceptions, with Promises
there can be a growing-and-shrinking list of unhandled rejections.

In synchronous code, the
\texttt{\textquotesingle{}uncaughtException\textquotesingle{}} event is
emitted when the list of unhandled exceptions grows.

In asynchronous code, the
\texttt{\textquotesingle{}unhandledRejection\textquotesingle{}} event is
emitted when the list of unhandled rejections grows, and the
\texttt{\textquotesingle{}rejectionHandled\textquotesingle{}} event is
emitted when the list of unhandled rejections shrinks.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ unhandledRejections }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Map}\NormalTok{()}\OperatorTok{;}
\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}unhandledRejection\textquotesingle{}}\OperatorTok{,}\NormalTok{ (reason}\OperatorTok{,}\NormalTok{ promise) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  unhandledRejections}\OperatorTok{.}\FunctionTok{set}\NormalTok{(promise}\OperatorTok{,}\NormalTok{ reason)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}rejectionHandled\textquotesingle{}}\OperatorTok{,}\NormalTok{ (promise) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  unhandledRejections}\OperatorTok{.}\FunctionTok{delete}\NormalTok{(promise)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ unhandledRejections }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Map}\NormalTok{()}\OperatorTok{;}
\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}unhandledRejection\textquotesingle{}}\OperatorTok{,}\NormalTok{ (reason}\OperatorTok{,}\NormalTok{ promise) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  unhandledRejections}\OperatorTok{.}\FunctionTok{set}\NormalTok{(promise}\OperatorTok{,}\NormalTok{ reason)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}rejectionHandled\textquotesingle{}}\OperatorTok{,}\NormalTok{ (promise) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  unhandledRejections}\OperatorTok{.}\FunctionTok{delete}\NormalTok{(promise)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

In this example, the \texttt{unhandledRejections} \texttt{Map} will grow
and shrink over time, reflecting rejections that start unhandled and
then become handled. It is possible to record such errors in an error
log, either periodically (which is likely best for long-running
application) or upon process exit (which is likely most convenient for
scripts).

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}uncaughtException\textquotesingle{}}}{Event: \textquotesingle uncaughtException\textquotesingle{}}}\label{event-uncaughtexception}

\begin{itemize}
\tightlist
\item
  \texttt{err} \{Error\} The uncaught exception.
\item
  \texttt{origin} \{string\} Indicates if the exception originates from
  an unhandled rejection or from a synchronous error. Can either be
  \texttt{\textquotesingle{}uncaughtException\textquotesingle{}} or
  \texttt{\textquotesingle{}unhandledRejection\textquotesingle{}}. The
  latter is used when an exception happens in a \texttt{Promise} based
  async context (or if a \texttt{Promise} is rejected) and
  \href{cli.md\#--unhandled-rejectionsmode}{\texttt{-\/-unhandled-rejections}}
  flag set to \texttt{strict} or \texttt{throw} (which is the default)
  and the rejection is not handled, or when a rejection happens during
  the command line entry point's ES module static loading phase.
\end{itemize}

The \texttt{\textquotesingle{}uncaughtException\textquotesingle{}} event
is emitted when an uncaught JavaScript exception bubbles all the way
back to the event loop. By default, Node.js handles such exceptions by
printing the stack trace to \texttt{stderr} and exiting with code 1,
overriding any previously set
\hyperref[processexitcode_1]{\texttt{process.exitCode}}. Adding a
handler for the
\texttt{\textquotesingle{}uncaughtException\textquotesingle{}} event
overrides this default behavior. Alternatively, change the
\hyperref[processexitcode_1]{\texttt{process.exitCode}} in the
\texttt{\textquotesingle{}uncaughtException\textquotesingle{}} handler
which will result in the process exiting with the provided exit code.
Otherwise, in the presence of such handler the process will exit with 0.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}uncaughtException\textquotesingle{}}\OperatorTok{,}\NormalTok{ (err}\OperatorTok{,}\NormalTok{ origin) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  fs}\OperatorTok{.}\FunctionTok{writeSync}\NormalTok{(}
    \BuiltInTok{process}\OperatorTok{.}\AttributeTok{stderr}\OperatorTok{.}\AttributeTok{fd}\OperatorTok{,}
    \VerbatimStringTok{\textasciigrave{}Caught exception: }\SpecialCharTok{$\{}\NormalTok{err}\SpecialCharTok{\}\textbackslash{}n}\VerbatimStringTok{\textasciigrave{}} \OperatorTok{+}
    \VerbatimStringTok{\textasciigrave{}Exception origin: }\SpecialCharTok{$\{}\NormalTok{origin}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\OperatorTok{,}
\NormalTok{  )}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}This will still run.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{,} \DecValTok{500}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Intentionally cause an exception, but don\textquotesingle{}t catch it.}
\FunctionTok{nonexistentFunc}\NormalTok{()}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}This will not run.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}uncaughtException\textquotesingle{}}\OperatorTok{,}\NormalTok{ (err}\OperatorTok{,}\NormalTok{ origin) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  fs}\OperatorTok{.}\FunctionTok{writeSync}\NormalTok{(}
    \BuiltInTok{process}\OperatorTok{.}\AttributeTok{stderr}\OperatorTok{.}\AttributeTok{fd}\OperatorTok{,}
    \VerbatimStringTok{\textasciigrave{}Caught exception: }\SpecialCharTok{$\{}\NormalTok{err}\SpecialCharTok{\}\textbackslash{}n}\VerbatimStringTok{\textasciigrave{}} \OperatorTok{+}
    \VerbatimStringTok{\textasciigrave{}Exception origin: }\SpecialCharTok{$\{}\NormalTok{origin}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\OperatorTok{,}
\NormalTok{  )}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}This will still run.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{,} \DecValTok{500}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Intentionally cause an exception, but don\textquotesingle{}t catch it.}
\FunctionTok{nonexistentFunc}\NormalTok{()}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}This will not run.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

It is possible to monitor
\texttt{\textquotesingle{}uncaughtException\textquotesingle{}} events
without overriding the default behavior to exit the process by
installing a
\texttt{\textquotesingle{}uncaughtExceptionMonitor\textquotesingle{}}
listener.

\paragraph{\texorpdfstring{Warning: Using
\texttt{\textquotesingle{}uncaughtException\textquotesingle{}}
correctly}{Warning: Using \textquotesingle uncaughtException\textquotesingle{} correctly}}\label{warning-using-uncaughtexception-correctly}

\texttt{\textquotesingle{}uncaughtException\textquotesingle{}} is a
crude mechanism for exception handling intended to be used only as a
last resort. The event \emph{should not} be used as an equivalent to
\texttt{On\ Error\ Resume\ Next}. Unhandled exceptions inherently mean
that an application is in an undefined state. Attempting to resume
application code without properly recovering from the exception can
cause additional unforeseen and unpredictable issues.

Exceptions thrown from within the event handler will not be caught.
Instead the process will exit with a non-zero exit code and the stack
trace will be printed. This is to avoid infinite recursion.

Attempting to resume normally after an uncaught exception can be similar
to pulling out the power cord when upgrading a computer. Nine out of ten
times, nothing happens. But the tenth time, the system becomes
corrupted.

The correct use of
\texttt{\textquotesingle{}uncaughtException\textquotesingle{}} is to
perform synchronous cleanup of allocated resources (e.g.~file
descriptors, handles, etc) before shutting down the process. \textbf{It
is not safe to resume normal operation after
\texttt{\textquotesingle{}uncaughtException\textquotesingle{}}.}

To restart a crashed application in a more reliable way, whether
\texttt{\textquotesingle{}uncaughtException\textquotesingle{}} is
emitted or not, an external monitor should be employed in a separate
process to detect application failures and recover or restart as needed.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}uncaughtExceptionMonitor\textquotesingle{}}}{Event: \textquotesingle uncaughtExceptionMonitor\textquotesingle{}}}\label{event-uncaughtexceptionmonitor}

\begin{itemize}
\tightlist
\item
  \texttt{err} \{Error\} The uncaught exception.
\item
  \texttt{origin} \{string\} Indicates if the exception originates from
  an unhandled rejection or from synchronous errors. Can either be
  \texttt{\textquotesingle{}uncaughtException\textquotesingle{}} or
  \texttt{\textquotesingle{}unhandledRejection\textquotesingle{}}. The
  latter is used when an exception happens in a \texttt{Promise} based
  async context (or if a \texttt{Promise} is rejected) and
  \href{cli.md\#--unhandled-rejectionsmode}{\texttt{-\/-unhandled-rejections}}
  flag set to \texttt{strict} or \texttt{throw} (which is the default)
  and the rejection is not handled, or when a rejection happens during
  the command line entry point's ES module static loading phase.
\end{itemize}

The
\texttt{\textquotesingle{}uncaughtExceptionMonitor\textquotesingle{}}
event is emitted before an
\texttt{\textquotesingle{}uncaughtException\textquotesingle{}} event is
emitted or a hook installed via
\hyperref[processsetuncaughtexceptioncapturecallbackfn]{\texttt{process.setUncaughtExceptionCaptureCallback()}}
is called.

Installing an
\texttt{\textquotesingle{}uncaughtExceptionMonitor\textquotesingle{}}
listener does not change the behavior once an
\texttt{\textquotesingle{}uncaughtException\textquotesingle{}} event is
emitted. The process will still crash if no
\texttt{\textquotesingle{}uncaughtException\textquotesingle{}} listener
is installed.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}uncaughtExceptionMonitor\textquotesingle{}}\OperatorTok{,}\NormalTok{ (err}\OperatorTok{,}\NormalTok{ origin) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  MyMonitoringTool}\OperatorTok{.}\FunctionTok{logSync}\NormalTok{(err}\OperatorTok{,}\NormalTok{ origin)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\CommentTok{// Intentionally cause an exception, but don\textquotesingle{}t catch it.}
\FunctionTok{nonexistentFunc}\NormalTok{()}\OperatorTok{;}
\CommentTok{// Still crashes Node.js}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}uncaughtExceptionMonitor\textquotesingle{}}\OperatorTok{,}\NormalTok{ (err}\OperatorTok{,}\NormalTok{ origin) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  MyMonitoringTool}\OperatorTok{.}\FunctionTok{logSync}\NormalTok{(err}\OperatorTok{,}\NormalTok{ origin)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\CommentTok{// Intentionally cause an exception, but don\textquotesingle{}t catch it.}
\FunctionTok{nonexistentFunc}\NormalTok{()}\OperatorTok{;}
\CommentTok{// Still crashes Node.js}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}unhandledRejection\textquotesingle{}}}{Event: \textquotesingle unhandledRejection\textquotesingle{}}}\label{event-unhandledrejection}

\begin{itemize}
\tightlist
\item
  \texttt{reason} \{Error\textbar any\} The object with which the
  promise was rejected (typically an
  \href{errors.md\#class-error}{\texttt{Error}} object).
\item
  \texttt{promise} \{Promise\} The rejected promise.
\end{itemize}

The \texttt{\textquotesingle{}unhandledRejection\textquotesingle{}}
event is emitted whenever a \texttt{Promise} is rejected and no error
handler is attached to the promise within a turn of the event loop. When
programming with Promises, exceptions are encapsulated as ``rejected
promises''. Rejections can be caught and handled using
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch}{\texttt{promise.catch()}}
and are propagated through a \texttt{Promise} chain. The
\texttt{\textquotesingle{}unhandledRejection\textquotesingle{}} event is
useful for detecting and keeping track of promises that were rejected
whose rejections have not yet been handled.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}unhandledRejection\textquotesingle{}}\OperatorTok{,}\NormalTok{ (reason}\OperatorTok{,}\NormalTok{ promise) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Unhandled Rejection at:\textquotesingle{}}\OperatorTok{,}\NormalTok{ promise}\OperatorTok{,} \StringTok{\textquotesingle{}reason:\textquotesingle{}}\OperatorTok{,}\NormalTok{ reason)}\OperatorTok{;}
  \CommentTok{// Application specific logging, throwing an error, or other logic here}
\NormalTok{\})}\OperatorTok{;}

\NormalTok{somePromise}\OperatorTok{.}\FunctionTok{then}\NormalTok{((res) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \ControlFlowTok{return} \FunctionTok{reportToUser}\NormalTok{(}\BuiltInTok{JSON}\OperatorTok{.}\FunctionTok{pasre}\NormalTok{(res))}\OperatorTok{;} \CommentTok{// Note the typo (\textasciigrave{}pasre\textasciigrave{})}
\NormalTok{\})}\OperatorTok{;} \CommentTok{// No \textasciigrave{}.catch()\textasciigrave{} or \textasciigrave{}.then()\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}unhandledRejection\textquotesingle{}}\OperatorTok{,}\NormalTok{ (reason}\OperatorTok{,}\NormalTok{ promise) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Unhandled Rejection at:\textquotesingle{}}\OperatorTok{,}\NormalTok{ promise}\OperatorTok{,} \StringTok{\textquotesingle{}reason:\textquotesingle{}}\OperatorTok{,}\NormalTok{ reason)}\OperatorTok{;}
  \CommentTok{// Application specific logging, throwing an error, or other logic here}
\NormalTok{\})}\OperatorTok{;}

\NormalTok{somePromise}\OperatorTok{.}\FunctionTok{then}\NormalTok{((res) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \ControlFlowTok{return} \FunctionTok{reportToUser}\NormalTok{(}\BuiltInTok{JSON}\OperatorTok{.}\FunctionTok{pasre}\NormalTok{(res))}\OperatorTok{;} \CommentTok{// Note the typo (\textasciigrave{}pasre\textasciigrave{})}
\NormalTok{\})}\OperatorTok{;} \CommentTok{// No \textasciigrave{}.catch()\textasciigrave{} or \textasciigrave{}.then()\textasciigrave{}}
\end{Highlighting}
\end{Shaded}

The following will also trigger the
\texttt{\textquotesingle{}unhandledRejection\textquotesingle{}} event to
be emitted:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\KeywordTok{function} \FunctionTok{SomeResource}\NormalTok{() \{}
  \CommentTok{// Initially set the loaded status to a rejected promise}
  \KeywordTok{this}\OperatorTok{.}\AttributeTok{loaded} \OperatorTok{=} \BuiltInTok{Promise}\OperatorTok{.}\FunctionTok{reject}\NormalTok{(}\KeywordTok{new} \BuiltInTok{Error}\NormalTok{(}\StringTok{\textquotesingle{}Resource not yet loaded!\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\NormalTok{\}}

\KeywordTok{const}\NormalTok{ resource }\OperatorTok{=} \KeywordTok{new} \FunctionTok{SomeResource}\NormalTok{()}\OperatorTok{;}
\CommentTok{// no .catch or .then on resource.loaded for at least a turn}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{function} \FunctionTok{SomeResource}\NormalTok{() \{}
  \CommentTok{// Initially set the loaded status to a rejected promise}
  \KeywordTok{this}\OperatorTok{.}\AttributeTok{loaded} \OperatorTok{=} \BuiltInTok{Promise}\OperatorTok{.}\FunctionTok{reject}\NormalTok{(}\KeywordTok{new} \BuiltInTok{Error}\NormalTok{(}\StringTok{\textquotesingle{}Resource not yet loaded!\textquotesingle{}}\NormalTok{))}\OperatorTok{;}
\NormalTok{\}}

\KeywordTok{const}\NormalTok{ resource }\OperatorTok{=} \KeywordTok{new} \FunctionTok{SomeResource}\NormalTok{()}\OperatorTok{;}
\CommentTok{// no .catch or .then on resource.loaded for at least a turn}
\end{Highlighting}
\end{Shaded}

In this example case, it is possible to track the rejection as a
developer error as would typically be the case for other
\texttt{\textquotesingle{}unhandledRejection\textquotesingle{}} events.
To address such failures, a non-operational
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch}{\texttt{.catch(()\ =\textgreater{}\ \{\ \})}}
handler may be attached to \texttt{resource.loaded}, which would prevent
the \texttt{\textquotesingle{}unhandledRejection\textquotesingle{}}
event from being emitted.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}warning\textquotesingle{}}}{Event: \textquotesingle warning\textquotesingle{}}}\label{event-warning}

\begin{itemize}
\tightlist
\item
  \texttt{warning} \{Error\} Key properties of the warning are:

  \begin{itemize}
  \tightlist
  \item
    \texttt{name} \{string\} The name of the warning. \textbf{Default:}
    \texttt{\textquotesingle{}Warning\textquotesingle{}}.
  \item
    \texttt{message} \{string\} A system-provided description of the
    warning.
  \item
    \texttt{stack} \{string\} A stack trace to the location in the code
    where the warning was issued.
  \end{itemize}
\end{itemize}

The \texttt{\textquotesingle{}warning\textquotesingle{}} event is
emitted whenever Node.js emits a process warning.

A process warning is similar to an error in that it describes
exceptional conditions that are being brought to the user's attention.
However, warnings are not part of the normal Node.js and JavaScript
error handling flow. Node.js can emit warnings whenever it detects bad
coding practices that could lead to sub-optimal application performance,
bugs, or security vulnerabilities.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}warning\textquotesingle{}}\OperatorTok{,}\NormalTok{ (warning) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{name}\NormalTok{)}\OperatorTok{;}    \CommentTok{// Print the warning name}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{message}\NormalTok{)}\OperatorTok{;} \CommentTok{// Print the warning message}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{stack}\NormalTok{)}\OperatorTok{;}   \CommentTok{// Print the stack trace}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}warning\textquotesingle{}}\OperatorTok{,}\NormalTok{ (warning) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{name}\NormalTok{)}\OperatorTok{;}    \CommentTok{// Print the warning name}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{message}\NormalTok{)}\OperatorTok{;} \CommentTok{// Print the warning message}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{stack}\NormalTok{)}\OperatorTok{;}   \CommentTok{// Print the stack trace}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

By default, Node.js will print process warnings to \texttt{stderr}. The
\texttt{-\/-no-warnings} command-line option can be used to suppress the
default console output but the
\texttt{\textquotesingle{}warning\textquotesingle{}} event will still be
emitted by the \texttt{process} object. Currently, it is not possible to
suppress specific warning types other than deprecation warnings. To
suppress deprecation warnings, check out the
\href{cli.md\#--no-deprecation}{\texttt{-\/-no-deprecation}} flag.

The following example illustrates the warning that is printed to
\texttt{stderr} when too many listeners have been added to an event:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ node}
\NormalTok{\textgreater{} events.defaultMaxListeners = 1;}
\NormalTok{\textgreater{} process.on(\textquotesingle{}foo\textquotesingle{}, () =\textgreater{} \{\});}
\NormalTok{\textgreater{} process.on(\textquotesingle{}foo\textquotesingle{}, () =\textgreater{} \{\});}
\NormalTok{\textgreater{} (node:38638) MaxListenersExceededWarning: Possible EventEmitter memory leak}
\NormalTok{detected. 2 foo listeners added. Use emitter.setMaxListeners() to increase limit}
\end{Highlighting}
\end{Shaded}

In contrast, the following example turns off the default warning output
and adds a custom handler to the
\texttt{\textquotesingle{}warning\textquotesingle{}} event:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ node {-}{-}no{-}warnings}
\NormalTok{\textgreater{} const p = process.on(\textquotesingle{}warning\textquotesingle{}, (warning) =\textgreater{} console.warn(\textquotesingle{}Do not do that!\textquotesingle{}));}
\NormalTok{\textgreater{} events.defaultMaxListeners = 1;}
\NormalTok{\textgreater{} process.on(\textquotesingle{}foo\textquotesingle{}, () =\textgreater{} \{\});}
\NormalTok{\textgreater{} process.on(\textquotesingle{}foo\textquotesingle{}, () =\textgreater{} \{\});}
\NormalTok{\textgreater{} Do not do that!}
\end{Highlighting}
\end{Shaded}

The \texttt{-\/-trace-warnings} command-line option can be used to have
the default console output for warnings include the full stack trace of
the warning.

Launching Node.js using the \texttt{-\/-throw-deprecation} command-line
flag will cause custom deprecation warnings to be thrown as exceptions.

Using the \texttt{-\/-trace-deprecation} command-line flag will cause
the custom deprecation to be printed to \texttt{stderr} along with the
stack trace.

Using the \texttt{-\/-no-deprecation} command-line flag will suppress
all reporting of the custom deprecation.

The \texttt{*-deprecation} command-line flags only affect warnings that
use the name
\texttt{\textquotesingle{}DeprecationWarning\textquotesingle{}}.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}worker\textquotesingle{}}}{Event: \textquotesingle worker\textquotesingle{}}}\label{event-worker}

\begin{itemize}
\tightlist
\item
  \texttt{worker} \{Worker\} The \{Worker\} that was created.
\end{itemize}

The \texttt{\textquotesingle{}worker\textquotesingle{}} event is emitted
after a new \{Worker\} thread has been created.

\paragraph{Emitting custom warnings}\label{emitting-custom-warnings}

See the
\hyperref[processemitwarningwarning-type-code-ctor]{\texttt{process.emitWarning()}}
method for issuing custom or application-specific warnings.

\paragraph{Node.js warning names}\label{node.js-warning-names}

There are no strict guidelines for warning types (as identified by the
\texttt{name} property) emitted by Node.js. New types of warnings can be
added at any time. A few of the warning types that are most common
include:

\begin{itemize}
\tightlist
\item
  \texttt{\textquotesingle{}DeprecationWarning\textquotesingle{}} -
  Indicates use of a deprecated Node.js API or feature. Such warnings
  must include a \texttt{\textquotesingle{}code\textquotesingle{}}
  property identifying the \href{deprecations.md}{deprecation code}.
\item
  \texttt{\textquotesingle{}ExperimentalWarning\textquotesingle{}} -
  Indicates use of an experimental Node.js API or feature. Such features
  must be used with caution as they may change at any time and are not
  subject to the same strict semantic-versioning and long-term support
  policies as supported features.
\item
  \texttt{\textquotesingle{}MaxListenersExceededWarning\textquotesingle{}}
  - Indicates that too many listeners for a given event have been
  registered on either an \texttt{EventEmitter} or \texttt{EventTarget}.
  This is often an indication of a memory leak.
\item
  \texttt{\textquotesingle{}TimeoutOverflowWarning\textquotesingle{}} -
  Indicates that a numeric value that cannot fit within a 32-bit signed
  integer has been provided to either the \texttt{setTimeout()} or
  \texttt{setInterval()} functions.
\item
  \texttt{\textquotesingle{}UnsupportedWarning\textquotesingle{}} -
  Indicates use of an unsupported option or feature that will be ignored
  rather than treated as an error. One example is use of the HTTP
  response status message when using the HTTP/2 compatibility API.
\end{itemize}

\subsubsection{Signal events}\label{signal-events}

Signal events will be emitted when the Node.js process receives a
signal. Please refer to signal(7) for a listing of standard POSIX signal
names such as \texttt{\textquotesingle{}SIGINT\textquotesingle{}},
\texttt{\textquotesingle{}SIGHUP\textquotesingle{}}, etc.

Signals are not available on
\href{worker_threads.md\#class-worker}{\texttt{Worker}} threads.

The signal handler will receive the signal's name
(\texttt{\textquotesingle{}SIGINT\textquotesingle{}},
\texttt{\textquotesingle{}SIGTERM\textquotesingle{}}, etc.) as the first
argument.

The name of each event will be the uppercase common name for the signal
(e.g. \texttt{\textquotesingle{}SIGINT\textquotesingle{}} for
\texttt{SIGINT} signals).

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Begin reading from stdin so the process does not exit.}
\BuiltInTok{process}\OperatorTok{.}\AttributeTok{stdin}\OperatorTok{.}\FunctionTok{resume}\NormalTok{()}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}SIGINT\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Received SIGINT. Press Control{-}D to exit.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\CommentTok{// Using a single function to handle multiple signals}
\KeywordTok{function} \FunctionTok{handle}\NormalTok{(signal) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Received }\SpecialCharTok{$\{}\NormalTok{signal}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}SIGINT\textquotesingle{}}\OperatorTok{,}\NormalTok{ handle)}\OperatorTok{;}
\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}SIGTERM\textquotesingle{}}\OperatorTok{,}\NormalTok{ handle)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Begin reading from stdin so the process does not exit.}
\BuiltInTok{process}\OperatorTok{.}\AttributeTok{stdin}\OperatorTok{.}\FunctionTok{resume}\NormalTok{()}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}SIGINT\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Received SIGINT. Press Control{-}D to exit.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\CommentTok{// Using a single function to handle multiple signals}
\KeywordTok{function} \FunctionTok{handle}\NormalTok{(signal) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Received }\SpecialCharTok{$\{}\NormalTok{signal}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}SIGINT\textquotesingle{}}\OperatorTok{,}\NormalTok{ handle)}\OperatorTok{;}
\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}SIGTERM\textquotesingle{}}\OperatorTok{,}\NormalTok{ handle)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{\textquotesingle{}SIGUSR1\textquotesingle{}} is reserved by
  Node.js to start the \href{debugger.md}{debugger}. It's possible to
  install a listener but doing so might interfere with the debugger.
\item
  \texttt{\textquotesingle{}SIGTERM\textquotesingle{}} and
  \texttt{\textquotesingle{}SIGINT\textquotesingle{}} have default
  handlers on non-Windows platforms that reset the terminal mode before
  exiting with code \texttt{128\ +\ signal\ number}. If one of these
  signals has a listener installed, its default behavior will be removed
  (Node.js will no longer exit).
\item
  \texttt{\textquotesingle{}SIGPIPE\textquotesingle{}} is ignored by
  default. It can have a listener installed.
\item
  \texttt{\textquotesingle{}SIGHUP\textquotesingle{}} is generated on
  Windows when the console window is closed, and on other platforms
  under various similar conditions. See signal(7). It can have a
  listener installed, however Node.js will be unconditionally terminated
  by Windows about 10 seconds later. On non-Windows platforms, the
  default behavior of \texttt{SIGHUP} is to terminate Node.js, but once
  a listener has been installed its default behavior will be removed.
\item
  \texttt{\textquotesingle{}SIGTERM\textquotesingle{}} is not supported
  on Windows, it can be listened on.
\item
  \texttt{\textquotesingle{}SIGINT\textquotesingle{}} from the terminal
  is supported on all platforms, and can usually be generated with
  Ctrl+C (though this may be configurable). It is not generated when
  \href{tty.md\#readstreamsetrawmodemode}{terminal raw mode} is enabled
  and Ctrl+C is used.
\item
  \texttt{\textquotesingle{}SIGBREAK\textquotesingle{}} is delivered on
  Windows when Ctrl+Break is pressed. On non-Windows platforms, it can
  be listened on, but there is no way to send or generate it.
\item
  \texttt{\textquotesingle{}SIGWINCH\textquotesingle{}} is delivered
  when the console has been resized. On Windows, this will only happen
  on write to the console when the cursor is being moved, or when a
  readable tty is used in raw mode.
\item
  \texttt{\textquotesingle{}SIGKILL\textquotesingle{}} cannot have a
  listener installed, it will unconditionally terminate Node.js on all
  platforms.
\item
  \texttt{\textquotesingle{}SIGSTOP\textquotesingle{}} cannot have a
  listener installed.
\item
  \texttt{\textquotesingle{}SIGBUS\textquotesingle{}},
  \texttt{\textquotesingle{}SIGFPE\textquotesingle{}},
  \texttt{\textquotesingle{}SIGSEGV\textquotesingle{}}, and
  \texttt{\textquotesingle{}SIGILL\textquotesingle{}}, when not raised
  artificially using kill(2), inherently leave the process in a state
  from which it is not safe to call JS listeners. Doing so might cause
  the process to stop responding.
\item
  \texttt{0} can be sent to test for the existence of a process, it has
  no effect if the process exists, but will throw an error if the
  process does not exist.
\end{itemize}

Windows does not support signals so has no equivalent to termination by
signal, but Node.js offers some emulation with
\hyperref[processkillpid-signal]{\texttt{process.kill()}}, and
\href{child_process.md\#subprocesskillsignal}{\texttt{subprocess.kill()}}:

\begin{itemize}
\tightlist
\item
  Sending \texttt{SIGINT}, \texttt{SIGTERM}, and \texttt{SIGKILL} will
  cause the unconditional termination of the target process, and
  afterwards, subprocess will report that the process was terminated by
  signal.
\item
  Sending signal \texttt{0} can be used as a platform independent way to
  test for the existence of a process.
\end{itemize}

\subsection{\texorpdfstring{\texttt{process.abort()}}{process.abort()}}\label{process.abort}

The \texttt{process.abort()} method causes the Node.js process to exit
immediately and generate a core file.

This feature is not available in
\href{worker_threads.md\#class-worker}{\texttt{Worker}} threads.

\subsection{\texorpdfstring{\texttt{process.allowedNodeEnvironmentFlags}}{process.allowedNodeEnvironmentFlags}}\label{process.allowednodeenvironmentflags}

\begin{itemize}
\tightlist
\item
  \{Set\}
\end{itemize}

The \texttt{process.allowedNodeEnvironmentFlags} property is a special,
read-only \texttt{Set} of flags allowable within the
\href{cli.md\#node_optionsoptions}{\texttt{NODE\_OPTIONS}} environment
variable.

\texttt{process.allowedNodeEnvironmentFlags} extends \texttt{Set}, but
overrides \texttt{Set.prototype.has} to recognize several different
possible flag representations.
\texttt{process.allowedNodeEnvironmentFlags.has()} will return
\texttt{true} in the following cases:

\begin{itemize}
\tightlist
\item
  Flags may omit leading single (\texttt{-}) or double (\texttt{-\/-})
  dashes; e.g., \texttt{inspect-brk} for \texttt{-\/-inspect-brk}, or
  \texttt{r} for \texttt{-r}.
\item
  Flags passed through to V8 (as listed in \texttt{-\/-v8-options}) may
  replace one or more \emph{non-leading} dashes for an underscore, or
  vice-versa; e.g., \texttt{-\/-perf\_basic\_prof},
  \texttt{-\/-perf-basic-prof}, \texttt{-\/-perf\_basic-prof}, etc.
\item
  Flags may contain one or more equals (\texttt{=}) characters; all
  characters after and including the first equals will be ignored; e.g.,
  \texttt{-\/-stack-trace-limit=100}.
\item
  Flags \emph{must} be allowable within
  \href{cli.md\#node_optionsoptions}{\texttt{NODE\_OPTIONS}}.
\end{itemize}

When iterating over \texttt{process.allowedNodeEnvironmentFlags}, flags
will appear only \emph{once}; each will begin with one or more dashes.
Flags passed through to V8 will contain underscores instead of
non-leading dashes:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ allowedNodeEnvironmentFlags \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\NormalTok{allowedNodeEnvironmentFlags}\OperatorTok{.}\FunctionTok{forEach}\NormalTok{((flag) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \CommentTok{// {-}r}
  \CommentTok{// {-}{-}inspect{-}brk}
  \CommentTok{// {-}{-}abort\_on\_uncaught\_exception}
  \CommentTok{// ...}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ allowedNodeEnvironmentFlags \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\NormalTok{allowedNodeEnvironmentFlags}\OperatorTok{.}\FunctionTok{forEach}\NormalTok{((flag) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \CommentTok{// {-}r}
  \CommentTok{// {-}{-}inspect{-}brk}
  \CommentTok{// {-}{-}abort\_on\_uncaught\_exception}
  \CommentTok{// ...}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The methods \texttt{add()}, \texttt{clear()}, and \texttt{delete()} of
\texttt{process.allowedNodeEnvironmentFlags} do nothing, and will fail
silently.

If Node.js was compiled \emph{without}
\href{cli.md\#node_optionsoptions}{\texttt{NODE\_OPTIONS}} support
(shown in \hyperref[processconfig]{\texttt{process.config}}),
\texttt{process.allowedNodeEnvironmentFlags} will contain what
\emph{would have} been allowable.

\subsection{\texorpdfstring{\texttt{process.arch}}{process.arch}}\label{process.arch}

\begin{itemize}
\tightlist
\item
  \{string\}
\end{itemize}

The operating system CPU architecture for which the Node.js binary was
compiled. Possible values are:
\texttt{\textquotesingle{}arm\textquotesingle{}},
\texttt{\textquotesingle{}arm64\textquotesingle{}},
\texttt{\textquotesingle{}ia32\textquotesingle{}},
\texttt{\textquotesingle{}loong64\textquotesingle{}},
\texttt{\textquotesingle{}mips\textquotesingle{}},
\texttt{\textquotesingle{}mipsel\textquotesingle{}},
\texttt{\textquotesingle{}ppc\textquotesingle{}},
\texttt{\textquotesingle{}ppc64\textquotesingle{}},
\texttt{\textquotesingle{}riscv64\textquotesingle{}},
\texttt{\textquotesingle{}s390\textquotesingle{}},
\texttt{\textquotesingle{}s390x\textquotesingle{}}, and
\texttt{\textquotesingle{}x64\textquotesingle{}}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ arch \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}This processor architecture is }\SpecialCharTok{$\{}\NormalTok{arch}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ arch \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}This processor architecture is }\SpecialCharTok{$\{}\NormalTok{arch}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.argv}}{process.argv}}\label{process.argv}

\begin{itemize}
\tightlist
\item
  \{string{[}{]}\}
\end{itemize}

The \texttt{process.argv} property returns an array containing the
command-line arguments passed when the Node.js process was launched. The
first element will be
\hyperref[processexecpath]{\texttt{process.execPath}}. See
\texttt{process.argv0} if access to the original value of
\texttt{argv{[}0{]}} is needed. The second element will be the path to
the JavaScript file being executed. The remaining elements will be any
additional command-line arguments.

For example, assuming the following script for \texttt{process-args.js}:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ argv \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\CommentTok{// print process.argv}
\NormalTok{argv}\OperatorTok{.}\FunctionTok{forEach}\NormalTok{((val}\OperatorTok{,}\NormalTok{ index) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}}\SpecialCharTok{$\{}\NormalTok{index}\SpecialCharTok{\}}\VerbatimStringTok{: }\SpecialCharTok{$\{}\NormalTok{val}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ argv \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// print process.argv}
\NormalTok{argv}\OperatorTok{.}\FunctionTok{forEach}\NormalTok{((val}\OperatorTok{,}\NormalTok{ index) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}}\SpecialCharTok{$\{}\NormalTok{index}\SpecialCharTok{\}}\VerbatimStringTok{: }\SpecialCharTok{$\{}\NormalTok{val}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Launching the Node.js process as:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{node}\NormalTok{ process{-}args.js one two=three four}
\end{Highlighting}
\end{Shaded}

Would generate the output:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{0: /usr/local/bin/node}
\NormalTok{1: /Users/mjr/work/node/process{-}args.js}
\NormalTok{2: one}
\NormalTok{3: two=three}
\NormalTok{4: four}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.argv0}}{process.argv0}}\label{process.argv0}

\begin{itemize}
\tightlist
\item
  \{string\}
\end{itemize}

The \texttt{process.argv0} property stores a read-only copy of the
original value of \texttt{argv{[}0{]}} passed when Node.js starts.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ bash {-}c \textquotesingle{}exec {-}a customArgv0 ./node\textquotesingle{}}
\NormalTok{\textgreater{} process.argv[0]}
\NormalTok{\textquotesingle{}/Volumes/code/external/node/out/Release/node\textquotesingle{}}
\NormalTok{\textgreater{} process.argv0}
\NormalTok{\textquotesingle{}customArgv0\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.channel}}{process.channel}}\label{process.channel}

\begin{itemize}
\tightlist
\item
  \{Object\}
\end{itemize}

If the Node.js process was spawned with an IPC channel (see the
\href{child_process.md}{Child Process} documentation), the
\texttt{process.channel} property is a reference to the IPC channel. If
no IPC channel exists, this property is \texttt{undefined}.

\subsubsection{\texorpdfstring{\texttt{process.channel.ref()}}{process.channel.ref()}}\label{process.channel.ref}

This method makes the IPC channel keep the event loop of the process
running if \texttt{.unref()} has been called before.

Typically, this is managed through the number of
\texttt{\textquotesingle{}disconnect\textquotesingle{}} and
\texttt{\textquotesingle{}message\textquotesingle{}} listeners on the
\texttt{process} object. However, this method can be used to explicitly
request a specific behavior.

\subsubsection{\texorpdfstring{\texttt{process.channel.unref()}}{process.channel.unref()}}\label{process.channel.unref}

This method makes the IPC channel not keep the event loop of the process
running, and lets it finish even while the channel is open.

Typically, this is managed through the number of
\texttt{\textquotesingle{}disconnect\textquotesingle{}} and
\texttt{\textquotesingle{}message\textquotesingle{}} listeners on the
\texttt{process} object. However, this method can be used to explicitly
request a specific behavior.

\subsection{\texorpdfstring{\texttt{process.chdir(directory)}}{process.chdir(directory)}}\label{process.chdirdirectory}

\begin{itemize}
\tightlist
\item
  \texttt{directory} \{string\}
\end{itemize}

The \texttt{process.chdir()} method changes the current working
directory of the Node.js process or throws an exception if doing so
fails (for instance, if the specified \texttt{directory} does not
exist).

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ chdir}\OperatorTok{,}\NormalTok{ cwd \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Starting directory: }\SpecialCharTok{$\{}\FunctionTok{cwd}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\ControlFlowTok{try}\NormalTok{ \{}
  \FunctionTok{chdir}\NormalTok{(}\StringTok{\textquotesingle{}/tmp\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}New directory: }\SpecialCharTok{$\{}\FunctionTok{cwd}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}chdir: }\SpecialCharTok{$\{}\NormalTok{err}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ chdir}\OperatorTok{,}\NormalTok{ cwd \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Starting directory: }\SpecialCharTok{$\{}\FunctionTok{cwd}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\ControlFlowTok{try}\NormalTok{ \{}
  \FunctionTok{chdir}\NormalTok{(}\StringTok{\textquotesingle{}/tmp\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}New directory: }\SpecialCharTok{$\{}\FunctionTok{cwd}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}chdir: }\SpecialCharTok{$\{}\NormalTok{err}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This feature is not available in
\href{worker_threads.md\#class-worker}{\texttt{Worker}} threads.

\subsection{\texorpdfstring{\texttt{process.config}}{process.config}}\label{process.config}

\begin{itemize}
\tightlist
\item
  \{Object\}
\end{itemize}

The \texttt{process.config} property returns a frozen \texttt{Object}
containing the JavaScript representation of the configure options used
to compile the current Node.js executable. This is the same as the
\texttt{config.gypi} file that was produced when running the
\texttt{./configure} script.

An example of the possible output looks like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\{}
  \DataTypeTok{target\_defaults}\OperatorTok{:}
\NormalTok{   \{ }\DataTypeTok{cflags}\OperatorTok{:}\NormalTok{ []}\OperatorTok{,}
     \DataTypeTok{default\_configuration}\OperatorTok{:} \StringTok{\textquotesingle{}Release\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{defines}\OperatorTok{:}\NormalTok{ []}\OperatorTok{,}
     \DataTypeTok{include\_dirs}\OperatorTok{:}\NormalTok{ []}\OperatorTok{,}
     \DataTypeTok{libraries}\OperatorTok{:}\NormalTok{ [] \}}\OperatorTok{,}
  \DataTypeTok{variables}\OperatorTok{:}
\NormalTok{   \{}
     \DataTypeTok{host\_arch}\OperatorTok{:} \StringTok{\textquotesingle{}x64\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{napi\_build\_version}\OperatorTok{:} \DecValTok{5}\OperatorTok{,}
     \DataTypeTok{node\_install\_npm}\OperatorTok{:} \StringTok{\textquotesingle{}true\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{node\_prefix}\OperatorTok{:} \StringTok{\textquotesingle{}\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{node\_shared\_cares}\OperatorTok{:} \StringTok{\textquotesingle{}false\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{node\_shared\_http\_parser}\OperatorTok{:} \StringTok{\textquotesingle{}false\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{node\_shared\_libuv}\OperatorTok{:} \StringTok{\textquotesingle{}false\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{node\_shared\_zlib}\OperatorTok{:} \StringTok{\textquotesingle{}false\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{node\_use\_openssl}\OperatorTok{:} \StringTok{\textquotesingle{}true\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{node\_shared\_openssl}\OperatorTok{:} \StringTok{\textquotesingle{}false\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{strict\_aliasing}\OperatorTok{:} \StringTok{\textquotesingle{}true\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{target\_arch}\OperatorTok{:} \StringTok{\textquotesingle{}x64\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{v8\_use\_snapshot}\OperatorTok{:} \DecValTok{1}
\NormalTok{   \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.connected}}{process.connected}}\label{process.connected}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

If the Node.js process is spawned with an IPC channel (see the
\href{child_process.md}{Child Process} and \href{cluster.md}{Cluster}
documentation), the \texttt{process.connected} property will return
\texttt{true} so long as the IPC channel is connected and will return
\texttt{false} after \texttt{process.disconnect()} is called.

Once \texttt{process.connected} is \texttt{false}, it is no longer
possible to send messages over the IPC channel using
\texttt{process.send()}.

\subsection{\texorpdfstring{\texttt{process.constrainedMemory()}}{process.constrainedMemory()}}\label{process.constrainedmemory}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \{number\textbar undefined\}
\end{itemize}

Gets the amount of memory available to the process (in bytes) based on
limits imposed by the OS. If there is no such constraint, or the
constraint is unknown, \texttt{undefined} is returned.

See
\href{https://docs.libuv.org/en/v1.x/misc.html\#c.uv_get_constrained_memory}{\texttt{uv\_get\_constrained\_memory}}
for more information.

\subsection{\texorpdfstring{\texttt{process.cpuUsage({[}previousValue{]})}}{process.cpuUsage({[}previousValue{]})}}\label{process.cpuusagepreviousvalue}

\begin{itemize}
\tightlist
\item
  \texttt{previousValue} \{Object\} A previous return value from calling
  \texttt{process.cpuUsage()}
\item
  Returns: \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{user} \{integer\}
  \item
    \texttt{system} \{integer\}
  \end{itemize}
\end{itemize}

The \texttt{process.cpuUsage()} method returns the user and system CPU
time usage of the current process, in an object with properties
\texttt{user} and \texttt{system}, whose values are microsecond values
(millionth of a second). These values measure time spent in user and
system code respectively, and may end up being greater than actual
elapsed time if multiple CPU cores are performing work for this process.

The result of a previous call to \texttt{process.cpuUsage()} can be
passed as the argument to the function, to get a diff reading.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ cpuUsage \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ startUsage }\OperatorTok{=} \FunctionTok{cpuUsage}\NormalTok{()}\OperatorTok{;}
\CommentTok{// \{ user: 38579, system: 6986 \}}

\CommentTok{// spin the CPU for 500 milliseconds}
\KeywordTok{const}\NormalTok{ now }\OperatorTok{=} \BuiltInTok{Date}\OperatorTok{.}\FunctionTok{now}\NormalTok{()}\OperatorTok{;}
\ControlFlowTok{while}\NormalTok{ (}\BuiltInTok{Date}\OperatorTok{.}\FunctionTok{now}\NormalTok{() }\OperatorTok{{-}}\NormalTok{ now }\OperatorTok{\textless{}} \DecValTok{500}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\FunctionTok{cpuUsage}\NormalTok{(startUsage))}\OperatorTok{;}
\CommentTok{// \{ user: 514883, system: 11226 \}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ cpuUsage \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ startUsage }\OperatorTok{=} \FunctionTok{cpuUsage}\NormalTok{()}\OperatorTok{;}
\CommentTok{// \{ user: 38579, system: 6986 \}}

\CommentTok{// spin the CPU for 500 milliseconds}
\KeywordTok{const}\NormalTok{ now }\OperatorTok{=} \BuiltInTok{Date}\OperatorTok{.}\FunctionTok{now}\NormalTok{()}\OperatorTok{;}
\ControlFlowTok{while}\NormalTok{ (}\BuiltInTok{Date}\OperatorTok{.}\FunctionTok{now}\NormalTok{() }\OperatorTok{{-}}\NormalTok{ now }\OperatorTok{\textless{}} \DecValTok{500}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\FunctionTok{cpuUsage}\NormalTok{(startUsage))}\OperatorTok{;}
\CommentTok{// \{ user: 514883, system: 11226 \}}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.cwd()}}{process.cwd()}}\label{process.cwd}

\begin{itemize}
\tightlist
\item
  Returns: \{string\}
\end{itemize}

The \texttt{process.cwd()} method returns the current working directory
of the Node.js process.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ cwd \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current directory: }\SpecialCharTok{$\{}\FunctionTok{cwd}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ cwd \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current directory: }\SpecialCharTok{$\{}\FunctionTok{cwd}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.debugPort}}{process.debugPort}}\label{process.debugport}

\begin{itemize}
\tightlist
\item
  \{number\}
\end{itemize}

The port used by the Node.js debugger when enabled.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\AttributeTok{debugPort} \OperatorTok{=} \DecValTok{5858}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\AttributeTok{debugPort} \OperatorTok{=} \DecValTok{5858}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.disconnect()}}{process.disconnect()}}\label{process.disconnect}

If the Node.js process is spawned with an IPC channel (see the
\href{child_process.md}{Child Process} and \href{cluster.md}{Cluster}
documentation), the \texttt{process.disconnect()} method will close the
IPC channel to the parent process, allowing the child process to exit
gracefully once there are no other connections keeping it alive.

The effect of calling \texttt{process.disconnect()} is the same as
calling
\href{child_process.md\#subprocessdisconnect}{\texttt{ChildProcess.disconnect()}}
from the parent process.

If the Node.js process was not spawned with an IPC channel,
\texttt{process.disconnect()} will be \texttt{undefined}.

\subsection{\texorpdfstring{\texttt{process.dlopen(module,\ filename{[},\ flags{]})}}{process.dlopen(module, filename{[}, flags{]})}}\label{process.dlopenmodule-filename-flags}

\begin{itemize}
\tightlist
\item
  \texttt{module} \{Object\}
\item
  \texttt{filename} \{string\}
\item
  \texttt{flags} \{os.constants.dlopen\} \textbf{Default:}
  \texttt{os.constants.dlopen.RTLD\_LAZY}
\end{itemize}

The \texttt{process.dlopen()} method allows dynamically loading shared
objects. It is primarily used by \texttt{require()} to load C++ Addons,
and should not be used directly, except in special cases. In other
words, \href{globals.md\#require}{\texttt{require()}} should be
preferred over \texttt{process.dlopen()} unless there are specific
reasons such as custom dlopen flags or loading from ES modules.

The \texttt{flags} argument is an integer that allows to specify dlopen
behavior. See the
\href{os.md\#dlopen-constants}{\texttt{os.constants.dlopen}}
documentation for details.

An important requirement when calling \texttt{process.dlopen()} is that
the \texttt{module} instance must be passed. Functions exported by the
C++ Addon are then accessible via \texttt{module.exports}.

The example below shows how to load a C++ Addon, named
\texttt{local.node}, that exports a \texttt{foo} function. All the
symbols are loaded before the call returns, by passing the
\texttt{RTLD\_NOW} constant. In this example the constant is assumed to
be available.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ dlopen \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ constants \} }\ImportTok{from} \StringTok{\textquotesingle{}node:os\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ fileURLToPath \} }\ImportTok{from} \StringTok{\textquotesingle{}node:url\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ module }\OperatorTok{=}\NormalTok{ \{ }\DataTypeTok{exports}\OperatorTok{:}\NormalTok{ \{\} \}}\OperatorTok{;}
\FunctionTok{dlopen}\NormalTok{(module}\OperatorTok{,} \FunctionTok{fileURLToPath}\NormalTok{(}\KeywordTok{new} \FunctionTok{URL}\NormalTok{(}\StringTok{\textquotesingle{}local.node\textquotesingle{}}\OperatorTok{,} \ImportTok{import}\OperatorTok{.}\AttributeTok{meta}\OperatorTok{.}\AttributeTok{url}\NormalTok{))}\OperatorTok{,}
\NormalTok{       constants}\OperatorTok{.}\AttributeTok{dlopen}\OperatorTok{.}\AttributeTok{RTLD\_NOW}\NormalTok{)}\OperatorTok{;}
\NormalTok{module}\OperatorTok{.}\AttributeTok{exports}\OperatorTok{.}\FunctionTok{foo}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ dlopen \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ \{ constants \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:os\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ \{ join \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:path\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ module }\OperatorTok{=}\NormalTok{ \{ }\DataTypeTok{exports}\OperatorTok{:}\NormalTok{ \{\} \}}\OperatorTok{;}
\FunctionTok{dlopen}\NormalTok{(module}\OperatorTok{,} \FunctionTok{join}\NormalTok{(}\BuiltInTok{\_\_dirname}\OperatorTok{,} \StringTok{\textquotesingle{}local.node\textquotesingle{}}\NormalTok{)}\OperatorTok{,}\NormalTok{ constants}\OperatorTok{.}\AttributeTok{dlopen}\OperatorTok{.}\AttributeTok{RTLD\_NOW}\NormalTok{)}\OperatorTok{;}
\NormalTok{module}\OperatorTok{.}\AttributeTok{exports}\OperatorTok{.}\FunctionTok{foo}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.emitWarning(warning{[},\ options{]})}}{process.emitWarning(warning{[}, options{]})}}\label{process.emitwarningwarning-options}

\begin{itemize}
\tightlist
\item
  \texttt{warning} \{string\textbar Error\} The warning to emit.
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{type} \{string\} When \texttt{warning} is a \texttt{String},
    \texttt{type} is the name to use for the \emph{type} of warning
    being emitted. \textbf{Default:}
    \texttt{\textquotesingle{}Warning\textquotesingle{}}.
  \item
    \texttt{code} \{string\} A unique identifier for the warning
    instance being emitted.
  \item
    \texttt{ctor} \{Function\} When \texttt{warning} is a
    \texttt{String}, \texttt{ctor} is an optional function used to limit
    the generated stack trace. \textbf{Default:}
    \texttt{process.emitWarning}.
  \item
    \texttt{detail} \{string\} Additional text to include with the
    error.
  \end{itemize}
\end{itemize}

The \texttt{process.emitWarning()} method can be used to emit custom or
application specific process warnings. These can be listened for by
adding a handler to the
\hyperref[event-warning]{\texttt{\textquotesingle{}warning\textquotesingle{}}}
event.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ emitWarning \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Emit a warning with a code and additional detail.}
\FunctionTok{emitWarning}\NormalTok{(}\StringTok{\textquotesingle{}Something happened!\textquotesingle{}}\OperatorTok{,}\NormalTok{ \{}
  \DataTypeTok{code}\OperatorTok{:} \StringTok{\textquotesingle{}MY\_WARNING\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{detail}\OperatorTok{:} \StringTok{\textquotesingle{}This is some additional information\textquotesingle{}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}
\CommentTok{// Emits:}
\CommentTok{// (node:56338) [MY\_WARNING] Warning: Something happened!}
\CommentTok{// This is some additional information}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ emitWarning \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Emit a warning with a code and additional detail.}
\FunctionTok{emitWarning}\NormalTok{(}\StringTok{\textquotesingle{}Something happened!\textquotesingle{}}\OperatorTok{,}\NormalTok{ \{}
  \DataTypeTok{code}\OperatorTok{:} \StringTok{\textquotesingle{}MY\_WARNING\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{detail}\OperatorTok{:} \StringTok{\textquotesingle{}This is some additional information\textquotesingle{}}\OperatorTok{,}
\NormalTok{\})}\OperatorTok{;}
\CommentTok{// Emits:}
\CommentTok{// (node:56338) [MY\_WARNING] Warning: Something happened!}
\CommentTok{// This is some additional information}
\end{Highlighting}
\end{Shaded}

In this example, an \texttt{Error} object is generated internally by
\texttt{process.emitWarning()} and passed through to the
\hyperref[event-warning]{\texttt{\textquotesingle{}warning\textquotesingle{}}}
handler.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}warning\textquotesingle{}}\OperatorTok{,}\NormalTok{ (warning) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{name}\NormalTok{)}\OperatorTok{;}    \CommentTok{// \textquotesingle{}Warning\textquotesingle{}}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{message}\NormalTok{)}\OperatorTok{;} \CommentTok{// \textquotesingle{}Something happened!\textquotesingle{}}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{code}\NormalTok{)}\OperatorTok{;}    \CommentTok{// \textquotesingle{}MY\_WARNING\textquotesingle{}}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{stack}\NormalTok{)}\OperatorTok{;}   \CommentTok{// Stack trace}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{detail}\NormalTok{)}\OperatorTok{;}  \CommentTok{// \textquotesingle{}This is some additional information\textquotesingle{}}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}warning\textquotesingle{}}\OperatorTok{,}\NormalTok{ (warning) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{name}\NormalTok{)}\OperatorTok{;}    \CommentTok{// \textquotesingle{}Warning\textquotesingle{}}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{message}\NormalTok{)}\OperatorTok{;} \CommentTok{// \textquotesingle{}Something happened!\textquotesingle{}}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{code}\NormalTok{)}\OperatorTok{;}    \CommentTok{// \textquotesingle{}MY\_WARNING\textquotesingle{}}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{stack}\NormalTok{)}\OperatorTok{;}   \CommentTok{// Stack trace}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{detail}\NormalTok{)}\OperatorTok{;}  \CommentTok{// \textquotesingle{}This is some additional information\textquotesingle{}}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

If \texttt{warning} is passed as an \texttt{Error} object, the
\texttt{options} argument is ignored.

\subsection{\texorpdfstring{\texttt{process.emitWarning(warning{[},\ type{[},\ code{]}{]}{[},\ ctor{]})}}{process.emitWarning(warning{[}, type{[}, code{]}{]}{[}, ctor{]})}}\label{process.emitwarningwarning-type-code-ctor}

\begin{itemize}
\tightlist
\item
  \texttt{warning} \{string\textbar Error\} The warning to emit.
\item
  \texttt{type} \{string\} When \texttt{warning} is a \texttt{String},
  \texttt{type} is the name to use for the \emph{type} of warning being
  emitted. \textbf{Default:}
  \texttt{\textquotesingle{}Warning\textquotesingle{}}.
\item
  \texttt{code} \{string\} A unique identifier for the warning instance
  being emitted.
\item
  \texttt{ctor} \{Function\} When \texttt{warning} is a \texttt{String},
  \texttt{ctor} is an optional function used to limit the generated
  stack trace. \textbf{Default:} \texttt{process.emitWarning}.
\end{itemize}

The \texttt{process.emitWarning()} method can be used to emit custom or
application specific process warnings. These can be listened for by
adding a handler to the
\hyperref[event-warning]{\texttt{\textquotesingle{}warning\textquotesingle{}}}
event.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ emitWarning \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Emit a warning using a string.}
\FunctionTok{emitWarning}\NormalTok{(}\StringTok{\textquotesingle{}Something happened!\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Emits: (node: 56338) Warning: Something happened!}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ emitWarning \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Emit a warning using a string.}
\FunctionTok{emitWarning}\NormalTok{(}\StringTok{\textquotesingle{}Something happened!\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Emits: (node: 56338) Warning: Something happened!}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ emitWarning \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Emit a warning using a string and a type.}
\FunctionTok{emitWarning}\NormalTok{(}\StringTok{\textquotesingle{}Something Happened!\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}CustomWarning\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Emits: (node:56338) CustomWarning: Something Happened!}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ emitWarning \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Emit a warning using a string and a type.}
\FunctionTok{emitWarning}\NormalTok{(}\StringTok{\textquotesingle{}Something Happened!\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}CustomWarning\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Emits: (node:56338) CustomWarning: Something Happened!}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ emitWarning \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\FunctionTok{emitWarning}\NormalTok{(}\StringTok{\textquotesingle{}Something happened!\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}CustomWarning\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}WARN001\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Emits: (node:56338) [WARN001] CustomWarning: Something happened!}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ emitWarning \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{emitWarning}\NormalTok{(}\StringTok{\textquotesingle{}Something happened!\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}CustomWarning\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}WARN001\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Emits: (node:56338) [WARN001] CustomWarning: Something happened!}
\end{Highlighting}
\end{Shaded}

In each of the previous examples, an \texttt{Error} object is generated
internally by \texttt{process.emitWarning()} and passed through to the
\hyperref[event-warning]{\texttt{\textquotesingle{}warning\textquotesingle{}}}
handler.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}warning\textquotesingle{}}\OperatorTok{,}\NormalTok{ (warning) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{name}\NormalTok{)}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{message}\NormalTok{)}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{code}\NormalTok{)}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{stack}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}warning\textquotesingle{}}\OperatorTok{,}\NormalTok{ (warning) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{name}\NormalTok{)}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{message}\NormalTok{)}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{code}\NormalTok{)}\OperatorTok{;}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{warn}\NormalTok{(warning}\OperatorTok{.}\AttributeTok{stack}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

If \texttt{warning} is passed as an \texttt{Error} object, it will be
passed through to the
\texttt{\textquotesingle{}warning\textquotesingle{}} event handler
unmodified (and the optional \texttt{type}, \texttt{code} and
\texttt{ctor} arguments will be ignored):

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ emitWarning \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\CommentTok{// Emit a warning using an Error object.}
\KeywordTok{const}\NormalTok{ myWarning }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Error}\NormalTok{(}\StringTok{\textquotesingle{}Something happened!\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Use the Error name property to specify the type name}
\NormalTok{myWarning}\OperatorTok{.}\AttributeTok{name} \OperatorTok{=} \StringTok{\textquotesingle{}CustomWarning\textquotesingle{}}\OperatorTok{;}
\NormalTok{myWarning}\OperatorTok{.}\AttributeTok{code} \OperatorTok{=} \StringTok{\textquotesingle{}WARN001\textquotesingle{}}\OperatorTok{;}

\FunctionTok{emitWarning}\NormalTok{(myWarning)}\OperatorTok{;}
\CommentTok{// Emits: (node:56338) [WARN001] CustomWarning: Something happened!}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ emitWarning \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Emit a warning using an Error object.}
\KeywordTok{const}\NormalTok{ myWarning }\OperatorTok{=} \KeywordTok{new} \BuiltInTok{Error}\NormalTok{(}\StringTok{\textquotesingle{}Something happened!\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Use the Error name property to specify the type name}
\NormalTok{myWarning}\OperatorTok{.}\AttributeTok{name} \OperatorTok{=} \StringTok{\textquotesingle{}CustomWarning\textquotesingle{}}\OperatorTok{;}
\NormalTok{myWarning}\OperatorTok{.}\AttributeTok{code} \OperatorTok{=} \StringTok{\textquotesingle{}WARN001\textquotesingle{}}\OperatorTok{;}

\FunctionTok{emitWarning}\NormalTok{(myWarning)}\OperatorTok{;}
\CommentTok{// Emits: (node:56338) [WARN001] CustomWarning: Something happened!}
\end{Highlighting}
\end{Shaded}

A \texttt{TypeError} is thrown if \texttt{warning} is anything other
than a string or \texttt{Error} object.

While process warnings use \texttt{Error} objects, the process warning
mechanism is \textbf{not} a replacement for normal error handling
mechanisms.

The following additional handling is implemented if the warning
\texttt{type} is
\texttt{\textquotesingle{}DeprecationWarning\textquotesingle{}}:

\begin{itemize}
\tightlist
\item
  If the \texttt{-\/-throw-deprecation} command-line flag is used, the
  deprecation warning is thrown as an exception rather than being
  emitted as an event.
\item
  If the \texttt{-\/-no-deprecation} command-line flag is used, the
  deprecation warning is suppressed.
\item
  If the \texttt{-\/-trace-deprecation} command-line flag is used, the
  deprecation warning is printed to \texttt{stderr} along with the full
  stack trace.
\end{itemize}

\subsubsection{Avoiding duplicate
warnings}\label{avoiding-duplicate-warnings}

As a best practice, warnings should be emitted only once per process. To
do so, place the \texttt{emitWarning()} behind a boolean.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ emitWarning \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\KeywordTok{function} \FunctionTok{emitMyWarning}\NormalTok{() \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\NormalTok{emitMyWarning}\OperatorTok{.}\AttributeTok{warned}\NormalTok{) \{}
\NormalTok{    emitMyWarning}\OperatorTok{.}\AttributeTok{warned} \OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
    \FunctionTok{emitWarning}\NormalTok{(}\StringTok{\textquotesingle{}Only warn once!\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\FunctionTok{emitMyWarning}\NormalTok{()}\OperatorTok{;}
\CommentTok{// Emits: (node: 56339) Warning: Only warn once!}
\FunctionTok{emitMyWarning}\NormalTok{()}\OperatorTok{;}
\CommentTok{// Emits nothing}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ emitWarning \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{function} \FunctionTok{emitMyWarning}\NormalTok{() \{}
  \ControlFlowTok{if}\NormalTok{ (}\OperatorTok{!}\NormalTok{emitMyWarning}\OperatorTok{.}\AttributeTok{warned}\NormalTok{) \{}
\NormalTok{    emitMyWarning}\OperatorTok{.}\AttributeTok{warned} \OperatorTok{=} \KeywordTok{true}\OperatorTok{;}
    \FunctionTok{emitWarning}\NormalTok{(}\StringTok{\textquotesingle{}Only warn once!\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\FunctionTok{emitMyWarning}\NormalTok{()}\OperatorTok{;}
\CommentTok{// Emits: (node: 56339) Warning: Only warn once!}
\FunctionTok{emitMyWarning}\NormalTok{()}\OperatorTok{;}
\CommentTok{// Emits nothing}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.env}}{process.env}}\label{process.env}

\begin{itemize}
\tightlist
\item
  \{Object\}
\end{itemize}

The \texttt{process.env} property returns an object containing the user
environment. See environ(7).

An example of this object looks like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\{}
  \DataTypeTok{TERM}\OperatorTok{:} \StringTok{\textquotesingle{}xterm{-}256color\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{SHELL}\OperatorTok{:} \StringTok{\textquotesingle{}/usr/local/bin/bash\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{USER}\OperatorTok{:} \StringTok{\textquotesingle{}maciej\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{PATH}\OperatorTok{:} \StringTok{\textquotesingle{}\textasciitilde{}/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{PWD}\OperatorTok{:} \StringTok{\textquotesingle{}/Users/maciej\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{EDITOR}\OperatorTok{:} \StringTok{\textquotesingle{}vim\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{SHLVL}\OperatorTok{:} \StringTok{\textquotesingle{}1\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{HOME}\OperatorTok{:} \StringTok{\textquotesingle{}/Users/maciej\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{LOGNAME}\OperatorTok{:} \StringTok{\textquotesingle{}maciej\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{\_}\OperatorTok{:} \StringTok{\textquotesingle{}/usr/local/bin/node\textquotesingle{}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

It is possible to modify this object, but such modifications will not be
reflected outside the Node.js process, or (unless explicitly requested)
to other \href{worker_threads.md\#class-worker}{\texttt{Worker}}
threads. In other words, the following example would not work:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{node} \AttributeTok{{-}e} \StringTok{\textquotesingle{}process.env.foo = "bar"\textquotesingle{}} \KeywordTok{\&\&} \BuiltInTok{echo} \VariableTok{$foo}
\end{Highlighting}
\end{Shaded}

While the following will:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ env \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\NormalTok{env}\OperatorTok{.}\AttributeTok{foo} \OperatorTok{=} \StringTok{\textquotesingle{}bar\textquotesingle{}}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(env}\OperatorTok{.}\AttributeTok{foo}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ env \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\NormalTok{env}\OperatorTok{.}\AttributeTok{foo} \OperatorTok{=} \StringTok{\textquotesingle{}bar\textquotesingle{}}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(env}\OperatorTok{.}\AttributeTok{foo}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Assigning a property on \texttt{process.env} will implicitly convert the
value to a string. \textbf{This behavior is deprecated.} Future versions
of Node.js may throw an error when the value is not a string, number, or
boolean.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ env \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\NormalTok{env}\OperatorTok{.}\AttributeTok{test} \OperatorTok{=} \KeywordTok{null}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(env}\OperatorTok{.}\AttributeTok{test}\NormalTok{)}\OperatorTok{;}
\CommentTok{// =\textgreater{} \textquotesingle{}null\textquotesingle{}}
\NormalTok{env}\OperatorTok{.}\AttributeTok{test} \OperatorTok{=} \KeywordTok{undefined}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(env}\OperatorTok{.}\AttributeTok{test}\NormalTok{)}\OperatorTok{;}
\CommentTok{// =\textgreater{} \textquotesingle{}undefined\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ env \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\NormalTok{env}\OperatorTok{.}\AttributeTok{test} \OperatorTok{=} \KeywordTok{null}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(env}\OperatorTok{.}\AttributeTok{test}\NormalTok{)}\OperatorTok{;}
\CommentTok{// =\textgreater{} \textquotesingle{}null\textquotesingle{}}
\NormalTok{env}\OperatorTok{.}\AttributeTok{test} \OperatorTok{=} \KeywordTok{undefined}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(env}\OperatorTok{.}\AttributeTok{test}\NormalTok{)}\OperatorTok{;}
\CommentTok{// =\textgreater{} \textquotesingle{}undefined\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

Use \texttt{delete} to delete a property from \texttt{process.env}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ env \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\NormalTok{env}\OperatorTok{.}\AttributeTok{TEST} \OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\KeywordTok{delete}\NormalTok{ env}\OperatorTok{.}\AttributeTok{TEST}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(env}\OperatorTok{.}\AttributeTok{TEST}\NormalTok{)}\OperatorTok{;}
\CommentTok{// =\textgreater{} undefined}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ env \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\NormalTok{env}\OperatorTok{.}\AttributeTok{TEST} \OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\KeywordTok{delete}\NormalTok{ env}\OperatorTok{.}\AttributeTok{TEST}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(env}\OperatorTok{.}\AttributeTok{TEST}\NormalTok{)}\OperatorTok{;}
\CommentTok{// =\textgreater{} undefined}
\end{Highlighting}
\end{Shaded}

On Windows operating systems, environment variables are
case-insensitive.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ env \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\NormalTok{env}\OperatorTok{.}\AttributeTok{TEST} \OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(env}\OperatorTok{.}\AttributeTok{test}\NormalTok{)}\OperatorTok{;}
\CommentTok{// =\textgreater{} 1}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ env \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\NormalTok{env}\OperatorTok{.}\AttributeTok{TEST} \OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(env}\OperatorTok{.}\AttributeTok{test}\NormalTok{)}\OperatorTok{;}
\CommentTok{// =\textgreater{} 1}
\end{Highlighting}
\end{Shaded}

Unless explicitly specified when creating a
\href{worker_threads.md\#class-worker}{\texttt{Worker}} instance, each
\href{worker_threads.md\#class-worker}{\texttt{Worker}} thread has its
own copy of \texttt{process.env}, based on its parent thread's
\texttt{process.env}, or whatever was specified as the \texttt{env}
option to the \href{worker_threads.md\#class-worker}{\texttt{Worker}}
constructor. Changes to \texttt{process.env} will not be visible across
\href{worker_threads.md\#class-worker}{\texttt{Worker}} threads, and
only the main thread can make changes that are visible to the operating
system or to native add-ons. On Windows, a copy of \texttt{process.env}
on a \href{worker_threads.md\#class-worker}{\texttt{Worker}} instance
operates in a case-sensitive manner unlike the main thread.

\subsection{\texorpdfstring{\texttt{process.execArgv}}{process.execArgv}}\label{process.execargv}

\begin{itemize}
\tightlist
\item
  \{string{[}{]}\}
\end{itemize}

The \texttt{process.execArgv} property returns the set of
Node.js-specific command-line options passed when the Node.js process
was launched. These options do not appear in the array returned by the
\hyperref[processargv]{\texttt{process.argv}} property, and do not
include the Node.js executable, the name of the script, or any options
following the script name. These options are useful in order to spawn
child processes with the same execution environment as the parent.

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{node} \AttributeTok{{-}{-}harmony}\NormalTok{ script.js }\AttributeTok{{-}{-}version}
\end{Highlighting}
\end{Shaded}

Results in \texttt{process.execArgv}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\StringTok{\textquotesingle{}{-}{-}harmony\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

And \texttt{process.argv}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\StringTok{\textquotesingle{}/usr/local/bin/node\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}script.js\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}{-}{-}version\textquotesingle{}}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Refer to
\href{worker_threads.md\#new-workerfilename-options}{\texttt{Worker}
constructor} for the detailed behavior of worker threads with this
property.

\subsection{\texorpdfstring{\texttt{process.execPath}}{process.execPath}}\label{process.execpath}

\begin{itemize}
\tightlist
\item
  \{string\}
\end{itemize}

The \texttt{process.execPath} property returns the absolute pathname of
the executable that started the Node.js process. Symbolic links, if any,
are resolved.

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{\textquotesingle{}/usr/local/bin/node\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.exit({[}code{]})}}{process.exit({[}code{]})}}\label{process.exitcode}

\begin{itemize}
\tightlist
\item
  \texttt{code}
  \{integer\textbar string\textbar null\textbar undefined\} The exit
  code. For string type, only integer strings (e.g.,`1') are allowed.
  \textbf{Default:} \texttt{0}.
\end{itemize}

The \texttt{process.exit()} method instructs Node.js to terminate the
process synchronously with an exit status of \texttt{code}. If
\texttt{code} is omitted, exit uses either the `success' code \texttt{0}
or the value of \texttt{process.exitCode} if it has been set. Node.js
will not terminate until all the
\hyperref[event-exit]{\texttt{\textquotesingle{}exit\textquotesingle{}}}
event listeners are called.

To exit with a `failure' code:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ exit \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\FunctionTok{exit}\NormalTok{(}\DecValTok{1}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ exit \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\FunctionTok{exit}\NormalTok{(}\DecValTok{1}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The shell that executed Node.js should see the exit code as \texttt{1}.

Calling \texttt{process.exit()} will force the process to exit as
quickly as possible even if there are still asynchronous operations
pending that have not yet completed fully, including I/O operations to
\texttt{process.stdout} and \texttt{process.stderr}.

In most situations, it is not actually necessary to call
\texttt{process.exit()} explicitly. The Node.js process will exit on its
own \emph{if there is no additional work pending} in the event loop. The
\texttt{process.exitCode} property can be set to tell the process which
exit code to use when the process exits gracefully.

For instance, the following example illustrates a \emph{misuse} of the
\texttt{process.exit()} method that could lead to data printed to stdout
being truncated and lost:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ exit \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\CommentTok{// This is an example of what *not* to do:}
\ControlFlowTok{if}\NormalTok{ (}\FunctionTok{someConditionNotMet}\NormalTok{()) \{}
  \FunctionTok{printUsageToStdout}\NormalTok{()}\OperatorTok{;}
  \FunctionTok{exit}\NormalTok{(}\DecValTok{1}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ exit \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// This is an example of what *not* to do:}
\ControlFlowTok{if}\NormalTok{ (}\FunctionTok{someConditionNotMet}\NormalTok{()) \{}
  \FunctionTok{printUsageToStdout}\NormalTok{()}\OperatorTok{;}
  \FunctionTok{exit}\NormalTok{(}\DecValTok{1}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The reason this is problematic is because writes to
\texttt{process.stdout} in Node.js are sometimes \emph{asynchronous} and
may occur over multiple ticks of the Node.js event loop. Calling
\texttt{process.exit()}, however, forces the process to exit
\emph{before} those additional writes to \texttt{stdout} can be
performed.

Rather than calling \texttt{process.exit()} directly, the code
\emph{should} set the \texttt{process.exitCode} and allow the process to
exit naturally by avoiding scheduling any additional work for the event
loop:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\CommentTok{// How to properly set the exit code while letting}
\CommentTok{// the process exit gracefully.}
\ControlFlowTok{if}\NormalTok{ (}\FunctionTok{someConditionNotMet}\NormalTok{()) \{}
  \FunctionTok{printUsageToStdout}\NormalTok{()}\OperatorTok{;}
  \BuiltInTok{process}\OperatorTok{.}\AttributeTok{exitCode} \OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{// How to properly set the exit code while letting}
\CommentTok{// the process exit gracefully.}
\ControlFlowTok{if}\NormalTok{ (}\FunctionTok{someConditionNotMet}\NormalTok{()) \{}
  \FunctionTok{printUsageToStdout}\NormalTok{()}\OperatorTok{;}
  \BuiltInTok{process}\OperatorTok{.}\AttributeTok{exitCode} \OperatorTok{=} \DecValTok{1}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If it is necessary to terminate the Node.js process due to an error
condition, throwing an \emph{uncaught} error and allowing the process to
terminate accordingly is safer than calling \texttt{process.exit()}.

In \href{worker_threads.md\#class-worker}{\texttt{Worker}} threads, this
function stops the current thread rather than the current process.

\subsection{\texorpdfstring{\texttt{process.exitCode}}{process.exitCode}}\label{process.exitcode-1}

\begin{itemize}
\tightlist
\item
  \{integer\textbar string\textbar null\textbar undefined\} The exit
  code. For string type, only integer strings (e.g.,`1') are allowed.
  \textbf{Default:} \texttt{undefined}.
\end{itemize}

A number which will be the process exit code, when the process either
exits gracefully, or is exited via
\hyperref[processexitcode]{\texttt{process.exit()}} without specifying a
code.

Specifying a code to
\hyperref[processexitcode]{\texttt{process.exit(code)}} will override
any previous setting of \texttt{process.exitCode}.

\subsection{\texorpdfstring{\texttt{process.getActiveResourcesInfo()}}{process.getActiveResourcesInfo()}}\label{process.getactiveresourcesinfo}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  Returns: \{string{[}{]}\}
\end{itemize}

The \texttt{process.getActiveResourcesInfo()} method returns an array of
strings containing the types of the active resources that are currently
keeping the event loop alive.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ getActiveResourcesInfo \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ \{ setTimeout \} }\ImportTok{from} \StringTok{\textquotesingle{}node:timers\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Before:\textquotesingle{}}\OperatorTok{,} \FunctionTok{getActiveResourcesInfo}\NormalTok{())}\OperatorTok{;}
\PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{\}}\OperatorTok{,} \DecValTok{1000}\NormalTok{)}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}After:\textquotesingle{}}\OperatorTok{,} \FunctionTok{getActiveResourcesInfo}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints:}
\CommentTok{//   Before: [ \textquotesingle{}CloseReq\textquotesingle{}, \textquotesingle{}TTYWrap\textquotesingle{}, \textquotesingle{}TTYWrap\textquotesingle{}, \textquotesingle{}TTYWrap\textquotesingle{} ]}
\CommentTok{//   After: [ \textquotesingle{}CloseReq\textquotesingle{}, \textquotesingle{}TTYWrap\textquotesingle{}, \textquotesingle{}TTYWrap\textquotesingle{}, \textquotesingle{}TTYWrap\textquotesingle{}, \textquotesingle{}Timeout\textquotesingle{} ]}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ getActiveResourcesInfo \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ \{ setTimeout \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:timers\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Before:\textquotesingle{}}\OperatorTok{,} \FunctionTok{getActiveResourcesInfo}\NormalTok{())}\OperatorTok{;}
\PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{\}}\OperatorTok{,} \DecValTok{1000}\NormalTok{)}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}After:\textquotesingle{}}\OperatorTok{,} \FunctionTok{getActiveResourcesInfo}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints:}
\CommentTok{//   Before: [ \textquotesingle{}TTYWrap\textquotesingle{}, \textquotesingle{}TTYWrap\textquotesingle{}, \textquotesingle{}TTYWrap\textquotesingle{} ]}
\CommentTok{//   After: [ \textquotesingle{}TTYWrap\textquotesingle{}, \textquotesingle{}TTYWrap\textquotesingle{}, \textquotesingle{}TTYWrap\textquotesingle{}, \textquotesingle{}Timeout\textquotesingle{} ]}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.getegid()}}{process.getegid()}}\label{process.getegid}

The \texttt{process.getegid()} method returns the numerical effective
group identity of the Node.js process. (See getegid(2).)

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getegid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current gid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getegid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getegid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current gid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getegid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This function is only available on POSIX platforms (i.e.~not Windows or
Android).

\subsection{\texorpdfstring{\texttt{process.geteuid()}}{process.geteuid()}}\label{process.geteuid}

\begin{itemize}
\tightlist
\item
  Returns: \{Object\}
\end{itemize}

The \texttt{process.geteuid()} method returns the numerical effective
user identity of the process. (See geteuid(2).)

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{geteuid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current uid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{geteuid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{geteuid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current uid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{geteuid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This function is only available on POSIX platforms (i.e.~not Windows or
Android).

\subsection{\texorpdfstring{\texttt{process.getgid()}}{process.getgid()}}\label{process.getgid}

\begin{itemize}
\tightlist
\item
  Returns: \{Object\}
\end{itemize}

The \texttt{process.getgid()} method returns the numerical group
identity of the process. (See getgid(2).)

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current gid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current gid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This function is only available on POSIX platforms (i.e.~not Windows or
Android).

\subsection{\texorpdfstring{\texttt{process.getgroups()}}{process.getgroups()}}\label{process.getgroups}

\begin{itemize}
\tightlist
\item
  Returns: \{integer{[}{]}\}
\end{itemize}

The \texttt{process.getgroups()} method returns an array with the
supplementary group IDs. POSIX leaves it unspecified if the effective
group ID is included but Node.js ensures it always is.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgroups}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgroups}\NormalTok{())}\OperatorTok{;} \CommentTok{// [ 16, 21, 297 ]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgroups}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgroups}\NormalTok{())}\OperatorTok{;} \CommentTok{// [ 16, 21, 297 ]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This function is only available on POSIX platforms (i.e.~not Windows or
Android).

\subsection{\texorpdfstring{\texttt{process.getuid()}}{process.getuid()}}\label{process.getuid}

\begin{itemize}
\tightlist
\item
  Returns: \{integer\}
\end{itemize}

The \texttt{process.getuid()} method returns the numeric user identity
of the process. (See getuid(2).)

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getuid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current uid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getuid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getuid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current uid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getuid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This function is only available on POSIX platforms (i.e.~not Windows or
Android).

\subsection{\texorpdfstring{\texttt{process.hasUncaughtExceptionCaptureCallback()}}{process.hasUncaughtExceptionCaptureCallback()}}\label{process.hasuncaughtexceptioncapturecallback}

\begin{itemize}
\tightlist
\item
  Returns: \{boolean\}
\end{itemize}

Indicates whether a callback has been set using
\hyperref[processsetuncaughtexceptioncapturecallbackfn]{\texttt{process.setUncaughtExceptionCaptureCallback()}}.

\subsection{\texorpdfstring{\texttt{process.hrtime({[}time{]})}}{process.hrtime({[}time{]})}}\label{process.hrtimetime}

\begin{quote}
Stability: 3 - Legacy. Use
\hyperref[processhrtimebigint]{\texttt{process.hrtime.bigint()}}
instead.
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{time} \{integer{[}{]}\} The result of a previous call to
  \texttt{process.hrtime()}
\item
  Returns: \{integer{[}{]}\}
\end{itemize}

This is the legacy version of
\hyperref[processhrtimebigint]{\texttt{process.hrtime.bigint()}} before
\texttt{bigint} was introduced in JavaScript.

The \texttt{process.hrtime()} method returns the current high-resolution
real time in a \texttt{{[}seconds,\ nanoseconds{]}} tuple
\texttt{Array}, where \texttt{nanoseconds} is the remaining part of the
real time that can't be represented in second precision.

\texttt{time} is an optional parameter that must be the result of a
previous \texttt{process.hrtime()} call to diff with the current time.
If the parameter passed in is not a tuple \texttt{Array}, a
\texttt{TypeError} will be thrown. Passing in a user-defined array
instead of the result of a previous call to \texttt{process.hrtime()}
will lead to undefined behavior.

These times are relative to an arbitrary time in the past, and not
related to the time of day and therefore not subject to clock drift. The
primary use is for measuring performance between intervals:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ hrtime \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ NS\_PER\_SEC }\OperatorTok{=} \FloatTok{1e9}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ time }\OperatorTok{=} \FunctionTok{hrtime}\NormalTok{()}\OperatorTok{;}
\CommentTok{// [ 1800216, 25 ]}

\PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{const}\NormalTok{ diff }\OperatorTok{=} \FunctionTok{hrtime}\NormalTok{(time)}\OperatorTok{;}
  \CommentTok{// [ 1, 552 ]}

  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Benchmark took }\SpecialCharTok{$\{}\NormalTok{diff[}\DecValTok{0}\NormalTok{] }\OperatorTok{*}\NormalTok{ NS\_PER\_SEC }\OperatorTok{+}\NormalTok{ diff[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{\}}\VerbatimStringTok{ nanoseconds\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
  \CommentTok{// Benchmark took 1000000552 nanoseconds}
\NormalTok{\}}\OperatorTok{,} \DecValTok{1000}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ hrtime \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ NS\_PER\_SEC }\OperatorTok{=} \FloatTok{1e9}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ time }\OperatorTok{=} \FunctionTok{hrtime}\NormalTok{()}\OperatorTok{;}
\CommentTok{// [ 1800216, 25 ]}

\PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{const}\NormalTok{ diff }\OperatorTok{=} \FunctionTok{hrtime}\NormalTok{(time)}\OperatorTok{;}
  \CommentTok{// [ 1, 552 ]}

  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Benchmark took }\SpecialCharTok{$\{}\NormalTok{diff[}\DecValTok{0}\NormalTok{] }\OperatorTok{*}\NormalTok{ NS\_PER\_SEC }\OperatorTok{+}\NormalTok{ diff[}\DecValTok{1}\NormalTok{]}\SpecialCharTok{\}}\VerbatimStringTok{ nanoseconds\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
  \CommentTok{// Benchmark took 1000000552 nanoseconds}
\NormalTok{\}}\OperatorTok{,} \DecValTok{1000}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.hrtime.bigint()}}{process.hrtime.bigint()}}\label{process.hrtime.bigint}

\begin{itemize}
\tightlist
\item
  Returns: \{bigint\}
\end{itemize}

The \texttt{bigint} version of the
\hyperref[processhrtimetime]{\texttt{process.hrtime()}} method returning
the current high-resolution real time in nanoseconds as a
\texttt{bigint}.

Unlike \hyperref[processhrtimetime]{\texttt{process.hrtime()}}, it does
not support an additional \texttt{time} argument since the difference
can just be computed directly by subtraction of the two
\texttt{bigint}s.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ hrtime \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ start }\OperatorTok{=}\NormalTok{ hrtime}\OperatorTok{.}\FunctionTok{bigint}\NormalTok{()}\OperatorTok{;}
\CommentTok{// 191051479007711n}

\PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{const}\NormalTok{ end }\OperatorTok{=}\NormalTok{ hrtime}\OperatorTok{.}\FunctionTok{bigint}\NormalTok{()}\OperatorTok{;}
  \CommentTok{// 191052633396993n}

  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Benchmark took }\SpecialCharTok{$\{}\NormalTok{end }\OperatorTok{{-}}\NormalTok{ start}\SpecialCharTok{\}}\VerbatimStringTok{ nanoseconds\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
  \CommentTok{// Benchmark took 1154389282 nanoseconds}
\NormalTok{\}}\OperatorTok{,} \DecValTok{1000}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ hrtime \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ start }\OperatorTok{=}\NormalTok{ hrtime}\OperatorTok{.}\FunctionTok{bigint}\NormalTok{()}\OperatorTok{;}
\CommentTok{// 191051479007711n}

\PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \KeywordTok{const}\NormalTok{ end }\OperatorTok{=}\NormalTok{ hrtime}\OperatorTok{.}\FunctionTok{bigint}\NormalTok{()}\OperatorTok{;}
  \CommentTok{// 191052633396993n}

  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Benchmark took }\SpecialCharTok{$\{}\NormalTok{end }\OperatorTok{{-}}\NormalTok{ start}\SpecialCharTok{\}}\VerbatimStringTok{ nanoseconds\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
  \CommentTok{// Benchmark took 1154389282 nanoseconds}
\NormalTok{\}}\OperatorTok{,} \DecValTok{1000}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.initgroups(user,\ extraGroup)}}{process.initgroups(user, extraGroup)}}\label{process.initgroupsuser-extragroup}

\begin{itemize}
\tightlist
\item
  \texttt{user} \{string\textbar number\} The user name or numeric
  identifier.
\item
  \texttt{extraGroup} \{string\textbar number\} A group name or numeric
  identifier.
\end{itemize}

The \texttt{process.initgroups()} method reads the \texttt{/etc/group}
file and initializes the group access list, using all groups of which
the user is a member. This is a privileged operation that requires that
the Node.js process either have \texttt{root} access or the
\texttt{CAP\_SETGID} capability.

Use care when dropping privileges:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ getgroups}\OperatorTok{,}\NormalTok{ initgroups}\OperatorTok{,}\NormalTok{ setgid \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\FunctionTok{getgroups}\NormalTok{())}\OperatorTok{;}         \CommentTok{// [ 0 ]}
\FunctionTok{initgroups}\NormalTok{(}\StringTok{\textquotesingle{}nodeuser\textquotesingle{}}\OperatorTok{,} \DecValTok{1000}\NormalTok{)}\OperatorTok{;}     \CommentTok{// switch user}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\FunctionTok{getgroups}\NormalTok{())}\OperatorTok{;}         \CommentTok{// [ 27, 30, 46, 1000, 0 ]}
\FunctionTok{setgid}\NormalTok{(}\DecValTok{1000}\NormalTok{)}\OperatorTok{;}                     \CommentTok{// drop root gid}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\FunctionTok{getgroups}\NormalTok{())}\OperatorTok{;}         \CommentTok{// [ 27, 30, 46, 1000 ]}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ getgroups}\OperatorTok{,}\NormalTok{ initgroups}\OperatorTok{,}\NormalTok{ setgid \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\FunctionTok{getgroups}\NormalTok{())}\OperatorTok{;}         \CommentTok{// [ 0 ]}
\FunctionTok{initgroups}\NormalTok{(}\StringTok{\textquotesingle{}nodeuser\textquotesingle{}}\OperatorTok{,} \DecValTok{1000}\NormalTok{)}\OperatorTok{;}     \CommentTok{// switch user}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\FunctionTok{getgroups}\NormalTok{())}\OperatorTok{;}         \CommentTok{// [ 27, 30, 46, 1000, 0 ]}
\FunctionTok{setgid}\NormalTok{(}\DecValTok{1000}\NormalTok{)}\OperatorTok{;}                     \CommentTok{// drop root gid}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\FunctionTok{getgroups}\NormalTok{())}\OperatorTok{;}         \CommentTok{// [ 27, 30, 46, 1000 ]}
\end{Highlighting}
\end{Shaded}

This function is only available on POSIX platforms (i.e.~not Windows or
Android). This feature is not available in
\href{worker_threads.md\#class-worker}{\texttt{Worker}} threads.

\subsection{\texorpdfstring{\texttt{process.kill(pid{[},\ signal{]})}}{process.kill(pid{[}, signal{]})}}\label{process.killpid-signal}

\begin{itemize}
\tightlist
\item
  \texttt{pid} \{number\} A process ID
\item
  \texttt{signal} \{string\textbar number\} The signal to send, either
  as a string or number. \textbf{Default:}
  \texttt{\textquotesingle{}SIGTERM\textquotesingle{}}.
\end{itemize}

The \texttt{process.kill()} method sends the \texttt{signal} to the
process identified by \texttt{pid}.

Signal names are strings such as
\texttt{\textquotesingle{}SIGINT\textquotesingle{}} or
\texttt{\textquotesingle{}SIGHUP\textquotesingle{}}. See
\hyperref[signal-events]{Signal Events} and kill(2) for more
information.

This method will throw an error if the target \texttt{pid} does not
exist. As a special case, a signal of \texttt{0} can be used to test for
the existence of a process. Windows platforms will throw an error if the
\texttt{pid} is used to kill a process group.

Even though the name of this function is \texttt{process.kill()}, it is
really just a signal sender, like the \texttt{kill} system call. The
signal sent may do something other than kill the target process.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process}\OperatorTok{,}\NormalTok{ \{ kill \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}SIGHUP\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Got SIGHUP signal.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Exiting.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
  \BuiltInTok{process}\OperatorTok{.}\FunctionTok{exit}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{,} \DecValTok{100}\NormalTok{)}\OperatorTok{;}

\FunctionTok{kill}\NormalTok{(}\BuiltInTok{process}\OperatorTok{.}\AttributeTok{pid}\OperatorTok{,} \StringTok{\textquotesingle{}SIGHUP\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}SIGHUP\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Got SIGHUP signal.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\PreprocessorTok{setTimeout}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}Exiting.\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
  \BuiltInTok{process}\OperatorTok{.}\FunctionTok{exit}\NormalTok{(}\DecValTok{0}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}\OperatorTok{,} \DecValTok{100}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{process}\OperatorTok{.}\FunctionTok{kill}\NormalTok{(}\BuiltInTok{process}\OperatorTok{.}\AttributeTok{pid}\OperatorTok{,} \StringTok{\textquotesingle{}SIGHUP\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

When \texttt{SIGUSR1} is received by a Node.js process, Node.js will
start the debugger. See \hyperref[signal-events]{Signal Events}.

\subsection{\texorpdfstring{\texttt{process.mainModule}}{process.mainModule}}\label{process.mainmodule}

\begin{quote}
Stability: 0 - Deprecated: Use
\href{modules.md\#accessing-the-main-module}{\texttt{require.main}}
instead.
\end{quote}

\begin{itemize}
\tightlist
\item
  \{Object\}
\end{itemize}

The \texttt{process.mainModule} property provides an alternative way of
retrieving
\href{modules.md\#accessing-the-main-module}{\texttt{require.main}}. The
difference is that if the main module changes at runtime,
\href{modules.md\#accessing-the-main-module}{\texttt{require.main}} may
still refer to the original main module in modules that were required
before the change occurred. Generally, it's safe to assume that the two
refer to the same module.

As with
\href{modules.md\#accessing-the-main-module}{\texttt{require.main}},
\texttt{process.mainModule} will be \texttt{undefined} if there is no
entry script.

\subsection{\texorpdfstring{\texttt{process.memoryUsage()}}{process.memoryUsage()}}\label{process.memoryusage}

\begin{itemize}
\tightlist
\item
  Returns: \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{rss} \{integer\}
  \item
    \texttt{heapTotal} \{integer\}
  \item
    \texttt{heapUsed} \{integer\}
  \item
    \texttt{external} \{integer\}
  \item
    \texttt{arrayBuffers} \{integer\}
  \end{itemize}
\end{itemize}

Returns an object describing the memory usage of the Node.js process
measured in bytes.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ memoryUsage \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\FunctionTok{memoryUsage}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints:}
\CommentTok{// \{}
\CommentTok{//  rss: 4935680,}
\CommentTok{//  heapTotal: 1826816,}
\CommentTok{//  heapUsed: 650472,}
\CommentTok{//  external: 49879,}
\CommentTok{//  arrayBuffers: 9386}
\CommentTok{// \}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ memoryUsage \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\FunctionTok{memoryUsage}\NormalTok{())}\OperatorTok{;}
\CommentTok{// Prints:}
\CommentTok{// \{}
\CommentTok{//  rss: 4935680,}
\CommentTok{//  heapTotal: 1826816,}
\CommentTok{//  heapUsed: 650472,}
\CommentTok{//  external: 49879,}
\CommentTok{//  arrayBuffers: 9386}
\CommentTok{// \}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{heapTotal} and \texttt{heapUsed} refer to V8's memory usage.
\item
  \texttt{external} refers to the memory usage of C++ objects bound to
  JavaScript objects managed by V8.
\item
  \texttt{rss}, Resident Set Size, is the amount of space occupied in
  the main memory device (that is a subset of the total allocated
  memory) for the process, including all C++ and JavaScript objects and
  code.
\item
  \texttt{arrayBuffers} refers to memory allocated for
  \texttt{ArrayBuffer}s and \texttt{SharedArrayBuffer}s, including all
  Node.js \href{buffer.md}{\texttt{Buffer}}s. This is also included in
  the \texttt{external} value. When Node.js is used as an embedded
  library, this value may be \texttt{0} because allocations for
  \texttt{ArrayBuffer}s may not be tracked in that case.
\end{itemize}

When using \href{worker_threads.md\#class-worker}{\texttt{Worker}}
threads, \texttt{rss} will be a value that is valid for the entire
process, while the other fields will only refer to the current thread.

The \texttt{process.memoryUsage()} method iterates over each page to
gather information about memory usage which might be slow depending on
the program memory allocations.

\subsection{\texorpdfstring{\texttt{process.memoryUsage.rss()}}{process.memoryUsage.rss()}}\label{process.memoryusage.rss}

\begin{itemize}
\tightlist
\item
  Returns: \{integer\}
\end{itemize}

The \texttt{process.memoryUsage.rss()} method returns an integer
representing the Resident Set Size (RSS) in bytes.

The Resident Set Size, is the amount of space occupied in the main
memory device (that is a subset of the total allocated memory) for the
process, including all C++ and JavaScript objects and code.

This is the same value as the \texttt{rss} property provided by
\texttt{process.memoryUsage()} but \texttt{process.memoryUsage.rss()} is
faster.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ memoryUsage \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(memoryUsage}\OperatorTok{.}\FunctionTok{rss}\NormalTok{())}\OperatorTok{;}
\CommentTok{// 35655680}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ memoryUsage \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(memoryUsage}\OperatorTok{.}\FunctionTok{rss}\NormalTok{())}\OperatorTok{;}
\CommentTok{// 35655680}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.nextTick(callback{[},\ ...args{]})}}{process.nextTick(callback{[}, ...args{]})}}\label{process.nexttickcallback-...args}

\begin{itemize}
\tightlist
\item
  \texttt{callback} \{Function\}
\item
  \texttt{...args} \{any\} Additional arguments to pass when invoking
  the \texttt{callback}
\end{itemize}

\texttt{process.nextTick()} adds \texttt{callback} to the ``next tick
queue''. This queue is fully drained after the current operation on the
JavaScript stack runs to completion and before the event loop is allowed
to continue. It's possible to create an infinite loop if one were to
recursively call \texttt{process.nextTick()}. See the
\href{https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\#process-nexttick}{Event
Loop} guide for more background.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ nextTick \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}start\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\FunctionTok{nextTick}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}nextTick callback\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}scheduled\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Output:}
\CommentTok{// start}
\CommentTok{// scheduled}
\CommentTok{// nextTick callback}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ nextTick \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}start\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\FunctionTok{nextTick}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}nextTick callback\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}scheduled\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Output:}
\CommentTok{// start}
\CommentTok{// scheduled}
\CommentTok{// nextTick callback}
\end{Highlighting}
\end{Shaded}

This is important when developing APIs in order to give users the
opportunity to assign event handlers \emph{after} an object has been
constructed but before any I/O has occurred:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ nextTick \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\KeywordTok{function} \FunctionTok{MyThing}\NormalTok{(options) \{}
  \KeywordTok{this}\OperatorTok{.}\FunctionTok{setupOptions}\NormalTok{(options)}\OperatorTok{;}

  \FunctionTok{nextTick}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
    \KeywordTok{this}\OperatorTok{.}\FunctionTok{startDoingStuff}\NormalTok{()}\OperatorTok{;}
\NormalTok{  \})}\OperatorTok{;}
\NormalTok{\}}

\KeywordTok{const}\NormalTok{ thing }\OperatorTok{=} \KeywordTok{new} \FunctionTok{MyThing}\NormalTok{()}\OperatorTok{;}
\NormalTok{thing}\OperatorTok{.}\FunctionTok{getReadyForStuff}\NormalTok{()}\OperatorTok{;}

\CommentTok{// thing.startDoingStuff() gets called now, not before.}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ nextTick \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{function} \FunctionTok{MyThing}\NormalTok{(options) \{}
  \KeywordTok{this}\OperatorTok{.}\FunctionTok{setupOptions}\NormalTok{(options)}\OperatorTok{;}

  \FunctionTok{nextTick}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
    \KeywordTok{this}\OperatorTok{.}\FunctionTok{startDoingStuff}\NormalTok{()}\OperatorTok{;}
\NormalTok{  \})}\OperatorTok{;}
\NormalTok{\}}

\KeywordTok{const}\NormalTok{ thing }\OperatorTok{=} \KeywordTok{new} \FunctionTok{MyThing}\NormalTok{()}\OperatorTok{;}
\NormalTok{thing}\OperatorTok{.}\FunctionTok{getReadyForStuff}\NormalTok{()}\OperatorTok{;}

\CommentTok{// thing.startDoingStuff() gets called now, not before.}
\end{Highlighting}
\end{Shaded}

It is very important for APIs to be either 100\% synchronous or 100\%
asynchronous. Consider this example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// }\AlertTok{WARNING}\CommentTok{!  DO NOT USE!  BAD UNSAFE HAZARD!}
\KeywordTok{function} \FunctionTok{maybeSync}\NormalTok{(arg}\OperatorTok{,}\NormalTok{ cb) \{}
  \ControlFlowTok{if}\NormalTok{ (arg) \{}
    \FunctionTok{cb}\NormalTok{()}\OperatorTok{;}
    \ControlFlowTok{return}\OperatorTok{;}
\NormalTok{  \}}

\NormalTok{  fs}\OperatorTok{.}\FunctionTok{stat}\NormalTok{(}\StringTok{\textquotesingle{}file\textquotesingle{}}\OperatorTok{,}\NormalTok{ cb)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This API is hazardous because in the following case:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ maybeTrue }\OperatorTok{=} \BuiltInTok{Math}\OperatorTok{.}\FunctionTok{random}\NormalTok{() }\OperatorTok{\textgreater{}} \FloatTok{0.5}\OperatorTok{;}

\FunctionTok{maybeSync}\NormalTok{(maybeTrue}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \FunctionTok{foo}\NormalTok{()}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}

\FunctionTok{bar}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

It is not clear whether \texttt{foo()} or \texttt{bar()} will be called
first.

The following approach is much better:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ nextTick \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\KeywordTok{function} \FunctionTok{definitelyAsync}\NormalTok{(arg}\OperatorTok{,}\NormalTok{ cb) \{}
  \ControlFlowTok{if}\NormalTok{ (arg) \{}
    \FunctionTok{nextTick}\NormalTok{(cb)}\OperatorTok{;}
    \ControlFlowTok{return}\OperatorTok{;}
\NormalTok{  \}}

\NormalTok{  fs}\OperatorTok{.}\FunctionTok{stat}\NormalTok{(}\StringTok{\textquotesingle{}file\textquotesingle{}}\OperatorTok{,}\NormalTok{ cb)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ nextTick \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{function} \FunctionTok{definitelyAsync}\NormalTok{(arg}\OperatorTok{,}\NormalTok{ cb) \{}
  \ControlFlowTok{if}\NormalTok{ (arg) \{}
    \FunctionTok{nextTick}\NormalTok{(cb)}\OperatorTok{;}
    \ControlFlowTok{return}\OperatorTok{;}
\NormalTok{  \}}

\NormalTok{  fs}\OperatorTok{.}\FunctionTok{stat}\NormalTok{(}\StringTok{\textquotesingle{}file\textquotesingle{}}\OperatorTok{,}\NormalTok{ cb)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{When to use \texttt{queueMicrotask()}
vs.~\texttt{process.nextTick()}}{When to use queueMicrotask() vs.~process.nextTick()}}\label{when-to-use-queuemicrotask-vs.-process.nexttick}

The \href{globals.md\#queuemicrotaskcallback}{\texttt{queueMicrotask()}}
API is an alternative to \texttt{process.nextTick()} that also defers
execution of a function using the same microtask queue used to execute
the then, catch, and finally handlers of resolved promises. Within
Node.js, every time the ``next tick queue'' is drained, the microtask
queue is drained immediately after.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ nextTick \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{Promise}\OperatorTok{.}\FunctionTok{resolve}\NormalTok{()}\OperatorTok{.}\FunctionTok{then}\NormalTok{(() }\KeywordTok{=\textgreater{}} \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\DecValTok{2}\NormalTok{))}\OperatorTok{;}
\FunctionTok{queueMicrotask}\NormalTok{(() }\KeywordTok{=\textgreater{}} \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\DecValTok{3}\NormalTok{))}\OperatorTok{;}
\FunctionTok{nextTick}\NormalTok{(() }\KeywordTok{=\textgreater{}} \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Output:}
\CommentTok{// 1}
\CommentTok{// 2}
\CommentTok{// 3}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ nextTick \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{Promise}\OperatorTok{.}\FunctionTok{resolve}\NormalTok{()}\OperatorTok{.}\FunctionTok{then}\NormalTok{(() }\KeywordTok{=\textgreater{}} \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\DecValTok{2}\NormalTok{))}\OperatorTok{;}
\FunctionTok{queueMicrotask}\NormalTok{(() }\KeywordTok{=\textgreater{}} \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\DecValTok{3}\NormalTok{))}\OperatorTok{;}
\FunctionTok{nextTick}\NormalTok{(() }\KeywordTok{=\textgreater{}} \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\DecValTok{1}\NormalTok{))}\OperatorTok{;}
\CommentTok{// Output:}
\CommentTok{// 1}
\CommentTok{// 2}
\CommentTok{// 3}
\end{Highlighting}
\end{Shaded}

For \emph{most} userland use cases, the \texttt{queueMicrotask()} API
provides a portable and reliable mechanism for deferring execution that
works across multiple JavaScript platform environments and should be
favored over \texttt{process.nextTick()}. In simple scenarios,
\texttt{queueMicrotask()} can be a drop-in replacement for
\texttt{process.nextTick()}.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}start\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\FunctionTok{queueMicrotask}\NormalTok{(() }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}microtask callback\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}scheduled\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Output:}
\CommentTok{// start}
\CommentTok{// scheduled}
\CommentTok{// microtask callback}
\end{Highlighting}
\end{Shaded}

One note-worthy difference between the two APIs is that
\texttt{process.nextTick()} allows specifying additional values that
will be passed as arguments to the deferred function when it is called.
Achieving the same result with \texttt{queueMicrotask()} requires using
either a closure or a bound function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{deferred}\NormalTok{(a}\OperatorTok{,}\NormalTok{ b) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}microtask\textquotesingle{}}\OperatorTok{,}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b)}\OperatorTok{;}
\NormalTok{\}}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}start\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\FunctionTok{queueMicrotask}\NormalTok{(deferred}\OperatorTok{.}\FunctionTok{bind}\NormalTok{(}\KeywordTok{undefined}\OperatorTok{,} \DecValTok{1}\OperatorTok{,} \DecValTok{2}\NormalTok{))}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}scheduled\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Output:}
\CommentTok{// start}
\CommentTok{// scheduled}
\CommentTok{// microtask 3}
\end{Highlighting}
\end{Shaded}

There are minor differences in the way errors raised from within the
next tick queue and microtask queue are handled. Errors thrown within a
queued microtask callback should be handled within the queued callback
when possible. If they are not, the
\texttt{process.on(\textquotesingle{}uncaughtException\textquotesingle{})}
event handler can be used to capture and handle the errors.

When in doubt, unless the specific capabilities of
\texttt{process.nextTick()} are needed, use \texttt{queueMicrotask()}.

\subsection{\texorpdfstring{\texttt{process.noDeprecation}}{process.noDeprecation}}\label{process.nodeprecation}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

The \texttt{process.noDeprecation} property indicates whether the
\texttt{-\/-no-deprecation} flag is set on the current Node.js process.
See the documentation for the
\hyperref[event-warning]{\texttt{\textquotesingle{}warning\textquotesingle{}}
event} and the
\hyperref[processemitwarningwarning-type-code-ctor]{\texttt{emitWarning()}
method} for more information about this flag's behavior.

\subsection{\texorpdfstring{\texttt{process.permission}}{process.permission}}\label{process.permission}

\begin{itemize}
\tightlist
\item
  \{Object\}
\end{itemize}

This API is available through the
\href{cli.md\#--experimental-permission}{\texttt{-\/-experimental-permission}}
flag.

\texttt{process.permission} is an object whose methods are used to
manage permissions for the current process. Additional documentation is
available in the \href{permissions.md\#permission-model}{Permission
Model}.

\subsubsection{\texorpdfstring{\texttt{process.permission.has(scope{[},\ reference{]})}}{process.permission.has(scope{[}, reference{]})}}\label{process.permission.hasscope-reference}

\begin{itemize}
\tightlist
\item
  \texttt{scope} \{string\}
\item
  \texttt{reference} \{string\}
\item
  Returns: \{boolean\}
\end{itemize}

Verifies that the process is able to access the given scope and
reference. If no reference is provided, a global scope is assumed, for
instance,
\texttt{process.permission.has(\textquotesingle{}fs.read\textquotesingle{})}
will check if the process has ALL file system read permissions.

The reference has a meaning based on the provided scope. For example,
the reference when the scope is File System means files and folders.

The available scopes are:

\begin{itemize}
\tightlist
\item
  \texttt{fs} - All File System
\item
  \texttt{fs.read} - File System read operations
\item
  \texttt{fs.write} - File System write operations
\item
  \texttt{child} - Child process spawning operations
\item
  \texttt{worker} - Worker thread spawning operation
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Check if the process has permission to read the README file}
\BuiltInTok{process}\OperatorTok{.}\AttributeTok{permission}\OperatorTok{.}\FunctionTok{has}\NormalTok{(}\StringTok{\textquotesingle{}fs.read\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}./README.md\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Check if the process has read permission operations}
\BuiltInTok{process}\OperatorTok{.}\AttributeTok{permission}\OperatorTok{.}\FunctionTok{has}\NormalTok{(}\StringTok{\textquotesingle{}fs.read\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.pid}}{process.pid}}\label{process.pid}

\begin{itemize}
\tightlist
\item
  \{integer\}
\end{itemize}

The \texttt{process.pid} property returns the PID of the process.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ pid \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}This process is pid }\SpecialCharTok{$\{}\NormalTok{pid}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ pid \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}This process is pid }\SpecialCharTok{$\{}\NormalTok{pid}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.platform}}{process.platform}}\label{process.platform}

\begin{itemize}
\tightlist
\item
  \{string\}
\end{itemize}

The \texttt{process.platform} property returns a string identifying the
operating system platform for which the Node.js binary was compiled.

Currently possible values are:

\begin{itemize}
\tightlist
\item
  \texttt{\textquotesingle{}aix\textquotesingle{}}
\item
  \texttt{\textquotesingle{}darwin\textquotesingle{}}
\item
  \texttt{\textquotesingle{}freebsd\textquotesingle{}}
\item
  \texttt{\textquotesingle{}linux\textquotesingle{}}
\item
  \texttt{\textquotesingle{}openbsd\textquotesingle{}}
\item
  \texttt{\textquotesingle{}sunos\textquotesingle{}}
\item
  \texttt{\textquotesingle{}win32\textquotesingle{}}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ platform \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}This platform is }\SpecialCharTok{$\{}\NormalTok{platform}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ platform \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}This platform is }\SpecialCharTok{$\{}\NormalTok{platform}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The value \texttt{\textquotesingle{}android\textquotesingle{}} may also
be returned if the Node.js is built on the Android operating system.
However, Android support in Node.js
\href{https://github.com/nodejs/node/blob/HEAD/BUILDING.md\#androidandroid-based-devices-eg-firefox-os}{is
experimental}.

\subsection{\texorpdfstring{\texttt{process.ppid}}{process.ppid}}\label{process.ppid}

\begin{itemize}
\tightlist
\item
  \{integer\}
\end{itemize}

The \texttt{process.ppid} property returns the PID of the parent of the
current process.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ ppid \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}The parent process is pid }\SpecialCharTok{$\{}\NormalTok{ppid}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ ppid \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}The parent process is pid }\SpecialCharTok{$\{}\NormalTok{ppid}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.release}}{process.release}}\label{process.release}

\begin{itemize}
\tightlist
\item
  \{Object\}
\end{itemize}

The \texttt{process.release} property returns an \texttt{Object}
containing metadata related to the current release, including URLs for
the source tarball and headers-only tarball.

\texttt{process.release} contains the following properties:

\begin{itemize}
\tightlist
\item
  \texttt{name} \{string\} A value that will always be
  \texttt{\textquotesingle{}node\textquotesingle{}}.
\item
  \texttt{sourceUrl} \{string\} an absolute URL pointing to a
  \emph{\texttt{.tar.gz}} file containing the source code of the current
  release.
\item
  \texttt{headersUrl}\{string\} an absolute URL pointing to a
  \emph{\texttt{.tar.gz}} file containing only the source header files
  for the current release. This file is significantly smaller than the
  full source file and can be used for compiling Node.js native add-ons.
\item
  \texttt{libUrl} \{string\textbar undefined\} an absolute URL pointing
  to a \emph{\texttt{node.lib}} file matching the architecture and
  version of the current release. This file is used for compiling
  Node.js native add-ons. \emph{This property is only present on Windows
  builds of Node.js and will be missing on all other platforms.}
\item
  \texttt{lts} \{string\textbar undefined\} a string label identifying
  the \href{https://github.com/nodejs/Release}{LTS} label for this
  release. This property only exists for LTS releases and is
  \texttt{undefined} for all other release types, including
  \emph{Current} releases. Valid values include the LTS Release code
  names (including those that are no longer supported).

  \begin{itemize}
  \tightlist
  \item
    \texttt{\textquotesingle{}Fermium\textquotesingle{}} for the 14.x
    LTS line beginning with 14.15.0.
  \item
    \texttt{\textquotesingle{}Gallium\textquotesingle{}} for the 16.x
    LTS line beginning with 16.13.0.
  \item
    \texttt{\textquotesingle{}Hydrogen\textquotesingle{}} for the 18.x
    LTS line beginning with 18.12.0. For other LTS Release code names,
    see
    \href{https://github.com/nodejs/node/blob/HEAD/doc/changelogs/CHANGELOG_ARCHIVE.md}{Node.js
    Changelog Archive}
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\{}
  \DataTypeTok{name}\OperatorTok{:} \StringTok{\textquotesingle{}node\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{lts}\OperatorTok{:} \StringTok{\textquotesingle{}Hydrogen\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{sourceUrl}\OperatorTok{:} \StringTok{\textquotesingle{}https://nodejs.org/download/release/v18.12.0/node{-}v18.12.0.tar.gz\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{headersUrl}\OperatorTok{:} \StringTok{\textquotesingle{}https://nodejs.org/download/release/v18.12.0/node{-}v18.12.0{-}headers.tar.gz\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{libUrl}\OperatorTok{:} \StringTok{\textquotesingle{}https://nodejs.org/download/release/v18.12.0/win{-}x64/node.lib\textquotesingle{}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In custom builds from non-release versions of the source tree, only the
\texttt{name} property may be present. The additional properties should
not be relied upon to exist.

\subsection{\texorpdfstring{\texttt{process.report}}{process.report}}\label{process.report}

\begin{itemize}
\tightlist
\item
  \{Object\}
\end{itemize}

\texttt{process.report} is an object whose methods are used to generate
diagnostic reports for the current process. Additional documentation is
available in the \href{report.md}{report documentation}.

\subsubsection{\texorpdfstring{\texttt{process.report.compact}}{process.report.compact}}\label{process.report.compact}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

Write reports in a compact format, single-line JSON, more easily
consumable by log processing systems than the default multi-line format
designed for human consumption.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ report \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Reports are compact? }\SpecialCharTok{$\{}\NormalTok{report}\OperatorTok{.}\AttributeTok{compact}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ report \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Reports are compact? }\SpecialCharTok{$\{}\NormalTok{report}\OperatorTok{.}\AttributeTok{compact}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{process.report.directory}}{process.report.directory}}\label{process.report.directory}

\begin{itemize}
\tightlist
\item
  \{string\}
\end{itemize}

Directory where the report is written. The default value is the empty
string, indicating that reports are written to the current working
directory of the Node.js process.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ report \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Report directory is }\SpecialCharTok{$\{}\NormalTok{report}\OperatorTok{.}\AttributeTok{directory}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ report \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Report directory is }\SpecialCharTok{$\{}\NormalTok{report}\OperatorTok{.}\AttributeTok{directory}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{process.report.filename}}{process.report.filename}}\label{process.report.filename}

\begin{itemize}
\tightlist
\item
  \{string\}
\end{itemize}

Filename where the report is written. If set to the empty string, the
output filename will be comprised of a timestamp, PID, and sequence
number. The default value is the empty string.

If the value of \texttt{process.report.filename} is set to
\texttt{\textquotesingle{}stdout\textquotesingle{}} or
\texttt{\textquotesingle{}stderr\textquotesingle{}}, the report is
written to the stdout or stderr of the process respectively.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ report \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Report filename is }\SpecialCharTok{$\{}\NormalTok{report}\OperatorTok{.}\AttributeTok{filename}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ report \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Report filename is }\SpecialCharTok{$\{}\NormalTok{report}\OperatorTok{.}\AttributeTok{filename}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{process.report.getReport({[}err{]})}}{process.report.getReport({[}err{]})}}\label{process.report.getreporterr}

\begin{itemize}
\tightlist
\item
  \texttt{err} \{Error\} A custom error used for reporting the
  JavaScript stack.
\item
  Returns: \{Object\}
\end{itemize}

Returns a JavaScript Object representation of a diagnostic report for
the running process. The report's JavaScript stack trace is taken from
\texttt{err}, if present.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ report \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}
\ImportTok{import}\NormalTok{ util }\ImportTok{from} \StringTok{\textquotesingle{}node:util\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ data }\OperatorTok{=}\NormalTok{ report}\OperatorTok{.}\FunctionTok{getReport}\NormalTok{()}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(data}\OperatorTok{.}\AttributeTok{header}\OperatorTok{.}\AttributeTok{nodejsVersion}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Similar to process.report.writeReport()}
\ImportTok{import}\NormalTok{ fs }\ImportTok{from} \StringTok{\textquotesingle{}node:fs\textquotesingle{}}\OperatorTok{;}
\NormalTok{fs}\OperatorTok{.}\FunctionTok{writeFileSync}\NormalTok{(}\StringTok{\textquotesingle{}my{-}report.log\textquotesingle{}}\OperatorTok{,}\NormalTok{ util}\OperatorTok{.}\FunctionTok{inspect}\NormalTok{(data)}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ report \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ util }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:util\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ data }\OperatorTok{=}\NormalTok{ report}\OperatorTok{.}\FunctionTok{getReport}\NormalTok{()}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(data}\OperatorTok{.}\AttributeTok{header}\OperatorTok{.}\AttributeTok{nodejsVersion}\NormalTok{)}\OperatorTok{;}

\CommentTok{// Similar to process.report.writeReport()}
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{fs}\OperatorTok{.}\FunctionTok{writeFileSync}\NormalTok{(}\StringTok{\textquotesingle{}my{-}report.log\textquotesingle{}}\OperatorTok{,}\NormalTok{ util}\OperatorTok{.}\FunctionTok{inspect}\NormalTok{(data)}\OperatorTok{,} \StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Additional documentation is available in the \href{report.md}{report
documentation}.

\subsubsection{\texorpdfstring{\texttt{process.report.reportOnFatalError}}{process.report.reportOnFatalError}}\label{process.report.reportonfatalerror}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

If \texttt{true}, a diagnostic report is generated on fatal errors, such
as out of memory errors or failed C++ assertions.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ report \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Report on fatal error: }\SpecialCharTok{$\{}\NormalTok{report}\OperatorTok{.}\AttributeTok{reportOnFatalError}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ report \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Report on fatal error: }\SpecialCharTok{$\{}\NormalTok{report}\OperatorTok{.}\AttributeTok{reportOnFatalError}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{process.report.reportOnSignal}}{process.report.reportOnSignal}}\label{process.report.reportonsignal}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

If \texttt{true}, a diagnostic report is generated when the process
receives the signal specified by \texttt{process.report.signal}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ report \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Report on signal: }\SpecialCharTok{$\{}\NormalTok{report}\OperatorTok{.}\AttributeTok{reportOnSignal}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ report \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Report on signal: }\SpecialCharTok{$\{}\NormalTok{report}\OperatorTok{.}\AttributeTok{reportOnSignal}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{process.report.reportOnUncaughtException}}{process.report.reportOnUncaughtException}}\label{process.report.reportonuncaughtexception}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

If \texttt{true}, a diagnostic report is generated on uncaught
exception.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ report \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Report on exception: }\SpecialCharTok{$\{}\NormalTok{report}\OperatorTok{.}\AttributeTok{reportOnUncaughtException}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ report \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Report on exception: }\SpecialCharTok{$\{}\NormalTok{report}\OperatorTok{.}\AttributeTok{reportOnUncaughtException}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{process.report.signal}}{process.report.signal}}\label{process.report.signal}

\begin{itemize}
\tightlist
\item
  \{string\}
\end{itemize}

The signal used to trigger the creation of a diagnostic report. Defaults
to \texttt{\textquotesingle{}SIGUSR2\textquotesingle{}}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ report \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Report signal: }\SpecialCharTok{$\{}\NormalTok{report}\OperatorTok{.}\AttributeTok{signal}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ report \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Report signal: }\SpecialCharTok{$\{}\NormalTok{report}\OperatorTok{.}\AttributeTok{signal}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{process.report.writeReport({[}filename{]}{[},\ err{]})}}{process.report.writeReport({[}filename{]}{[}, err{]})}}\label{process.report.writereportfilename-err}

\begin{itemize}
\item
  \texttt{filename} \{string\} Name of the file where the report is
  written. This should be a relative path, that will be appended to the
  directory specified in \texttt{process.report.directory}, or the
  current working directory of the Node.js process, if unspecified.
\item
  \texttt{err} \{Error\} A custom error used for reporting the
  JavaScript stack.
\item
  Returns: \{string\} Returns the filename of the generated report.
\end{itemize}

Writes a diagnostic report to a file. If \texttt{filename} is not
provided, the default filename includes the date, time, PID, and a
sequence number. The report's JavaScript stack trace is taken from
\texttt{err}, if present.

If the value of \texttt{filename} is set to
\texttt{\textquotesingle{}stdout\textquotesingle{}} or
\texttt{\textquotesingle{}stderr\textquotesingle{}}, the report is
written to the stdout or stderr of the process respectively.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ report \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\NormalTok{report}\OperatorTok{.}\FunctionTok{writeReport}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ report \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\NormalTok{report}\OperatorTok{.}\FunctionTok{writeReport}\NormalTok{()}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Additional documentation is available in the \href{report.md}{report
documentation}.

\subsection{\texorpdfstring{\texttt{process.resourceUsage()}}{process.resourceUsage()}}\label{process.resourceusage}

\begin{itemize}
\tightlist
\item
  Returns: \{Object\} the resource usage for the current process. All of
  these values come from the \texttt{uv\_getrusage} call which returns a
  \href{https://docs.libuv.org/en/v1.x/misc.html\#c.uv_rusage_t}{\texttt{uv\_rusage\_t}
  struct}.

  \begin{itemize}
  \tightlist
  \item
    \texttt{userCPUTime} \{integer\} maps to \texttt{ru\_utime} computed
    in microseconds. It is the same value as
    \hyperref[processcpuusagepreviousvalue]{\texttt{process.cpuUsage().user}}.
  \item
    \texttt{systemCPUTime} \{integer\} maps to \texttt{ru\_stime}
    computed in microseconds. It is the same value as
    \hyperref[processcpuusagepreviousvalue]{\texttt{process.cpuUsage().system}}.
  \item
    \texttt{maxRSS} \{integer\} maps to \texttt{ru\_maxrss} which is the
    maximum resident set size used in kilobytes.
  \item
    \texttt{sharedMemorySize} \{integer\} maps to \texttt{ru\_ixrss} but
    is not supported by any platform.
  \item
    \texttt{unsharedDataSize} \{integer\} maps to \texttt{ru\_idrss} but
    is not supported by any platform.
  \item
    \texttt{unsharedStackSize} \{integer\} maps to \texttt{ru\_isrss}
    but is not supported by any platform.
  \item
    \texttt{minorPageFault} \{integer\} maps to \texttt{ru\_minflt}
    which is the number of minor page faults for the process, see
    \href{https://en.wikipedia.org/wiki/Page_fault\#Minor}{this article
    for more details}.
  \item
    \texttt{majorPageFault} \{integer\} maps to \texttt{ru\_majflt}
    which is the number of major page faults for the process, see
    \href{https://en.wikipedia.org/wiki/Page_fault\#Major}{this article
    for more details}. This field is not supported on Windows.
  \item
    \texttt{swappedOut} \{integer\} maps to \texttt{ru\_nswap} but is
    not supported by any platform.
  \item
    \texttt{fsRead} \{integer\} maps to \texttt{ru\_inblock} which is
    the number of times the file system had to perform input.
  \item
    \texttt{fsWrite} \{integer\} maps to \texttt{ru\_oublock} which is
    the number of times the file system had to perform output.
  \item
    \texttt{ipcSent} \{integer\} maps to \texttt{ru\_msgsnd} but is not
    supported by any platform.
  \item
    \texttt{ipcReceived} \{integer\} maps to \texttt{ru\_msgrcv} but is
    not supported by any platform.
  \item
    \texttt{signalsCount} \{integer\} maps to \texttt{ru\_nsignals} but
    is not supported by any platform.
  \item
    \texttt{voluntaryContextSwitches} \{integer\} maps to
    \texttt{ru\_nvcsw} which is the number of times a CPU context switch
    resulted due to a process voluntarily giving up the processor before
    its time slice was completed (usually to await availability of a
    resource). This field is not supported on Windows.
  \item
    \texttt{involuntaryContextSwitches} \{integer\} maps to
    \texttt{ru\_nivcsw} which is the number of times a CPU context
    switch resulted due to a higher priority process becoming runnable
    or because the current process exceeded its time slice. This field
    is not supported on Windows.
  \end{itemize}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ resourceUsage \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\FunctionTok{resourceUsage}\NormalTok{())}\OperatorTok{;}
\CommentTok{/*}
\CommentTok{  Will output:}
\CommentTok{  \{}
\CommentTok{    userCPUTime: 82872,}
\CommentTok{    systemCPUTime: 4143,}
\CommentTok{    maxRSS: 33164,}
\CommentTok{    sharedMemorySize: 0,}
\CommentTok{    unsharedDataSize: 0,}
\CommentTok{    unsharedStackSize: 0,}
\CommentTok{    minorPageFault: 2469,}
\CommentTok{    majorPageFault: 0,}
\CommentTok{    swappedOut: 0,}
\CommentTok{    fsRead: 0,}
\CommentTok{    fsWrite: 8,}
\CommentTok{    ipcSent: 0,}
\CommentTok{    ipcReceived: 0,}
\CommentTok{    signalsCount: 0,}
\CommentTok{    voluntaryContextSwitches: 79,}
\CommentTok{    involuntaryContextSwitches: 1}
\CommentTok{  \}}
\CommentTok{*/}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ resourceUsage \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\FunctionTok{resourceUsage}\NormalTok{())}\OperatorTok{;}
\CommentTok{/*}
\CommentTok{  Will output:}
\CommentTok{  \{}
\CommentTok{    userCPUTime: 82872,}
\CommentTok{    systemCPUTime: 4143,}
\CommentTok{    maxRSS: 33164,}
\CommentTok{    sharedMemorySize: 0,}
\CommentTok{    unsharedDataSize: 0,}
\CommentTok{    unsharedStackSize: 0,}
\CommentTok{    minorPageFault: 2469,}
\CommentTok{    majorPageFault: 0,}
\CommentTok{    swappedOut: 0,}
\CommentTok{    fsRead: 0,}
\CommentTok{    fsWrite: 8,}
\CommentTok{    ipcSent: 0,}
\CommentTok{    ipcReceived: 0,}
\CommentTok{    signalsCount: 0,}
\CommentTok{    voluntaryContextSwitches: 79,}
\CommentTok{    involuntaryContextSwitches: 1}
\CommentTok{  \}}
\CommentTok{*/}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.send(message{[},\ sendHandle{[},\ options{]}{]}{[},\ callback{]})}}{process.send(message{[}, sendHandle{[}, options{]}{]}{[}, callback{]})}}\label{process.sendmessage-sendhandle-options-callback}

\begin{itemize}
\tightlist
\item
  \texttt{message} \{Object\}
\item
  \texttt{sendHandle} \{net.Server\textbar net.Socket\}
\item
  \texttt{options} \{Object\} used to parameterize the sending of
  certain types of handles.\texttt{options} supports the following
  properties:

  \begin{itemize}
  \tightlist
  \item
    \texttt{keepOpen} \{boolean\} A value that can be used when passing
    instances of \texttt{net.Socket}. When \texttt{true}, the socket is
    kept open in the sending process. \textbf{Default:} \texttt{false}.
  \end{itemize}
\item
  \texttt{callback} \{Function\}
\item
  Returns: \{boolean\}
\end{itemize}

If Node.js is spawned with an IPC channel, the \texttt{process.send()}
method can be used to send messages to the parent process. Messages will
be received as a
\href{child_process.md\#event-message}{\texttt{\textquotesingle{}message\textquotesingle{}}}
event on the parent's
\href{child_process.md\#class-childprocess}{\texttt{ChildProcess}}
object.

If Node.js was not spawned with an IPC channel, \texttt{process.send}
will be \texttt{undefined}.

The message goes through serialization and parsing. The resulting
message might not be the same as what is originally sent.

\subsection{\texorpdfstring{\texttt{process.setegid(id)}}{process.setegid(id)}}\label{process.setegidid}

\begin{itemize}
\tightlist
\item
  \texttt{id} \{string\textbar number\} A group name or ID
\end{itemize}

The \texttt{process.setegid()} method sets the effective group identity
of the process. (See setegid(2).) The \texttt{id} can be passed as
either a numeric ID or a group name string. If a group name is
specified, this method blocks while resolving the associated a numeric
ID.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getegid} \OperatorTok{\&\&} \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setegid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current gid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getegid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{try}\NormalTok{ \{}
    \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setegid}\NormalTok{(}\DecValTok{501}\NormalTok{)}\OperatorTok{;}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}New gid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getegid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Failed to set gid: }\SpecialCharTok{$\{}\NormalTok{err}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getegid} \OperatorTok{\&\&} \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setegid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current gid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getegid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{try}\NormalTok{ \{}
    \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setegid}\NormalTok{(}\DecValTok{501}\NormalTok{)}\OperatorTok{;}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}New gid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getegid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Failed to set gid: }\SpecialCharTok{$\{}\NormalTok{err}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This function is only available on POSIX platforms (i.e.~not Windows or
Android). This feature is not available in
\href{worker_threads.md\#class-worker}{\texttt{Worker}} threads.

\subsection{\texorpdfstring{\texttt{process.seteuid(id)}}{process.seteuid(id)}}\label{process.seteuidid}

\begin{itemize}
\tightlist
\item
  \texttt{id} \{string\textbar number\} A user name or ID
\end{itemize}

The \texttt{process.seteuid()} method sets the effective user identity
of the process. (See seteuid(2).) The \texttt{id} can be passed as
either a numeric ID or a username string. If a username is specified,
the method blocks while resolving the associated numeric ID.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{geteuid} \OperatorTok{\&\&} \BuiltInTok{process}\OperatorTok{.}\FunctionTok{seteuid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current uid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{geteuid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{try}\NormalTok{ \{}
    \BuiltInTok{process}\OperatorTok{.}\FunctionTok{seteuid}\NormalTok{(}\DecValTok{501}\NormalTok{)}\OperatorTok{;}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}New uid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{geteuid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Failed to set uid: }\SpecialCharTok{$\{}\NormalTok{err}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{geteuid} \OperatorTok{\&\&} \BuiltInTok{process}\OperatorTok{.}\FunctionTok{seteuid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current uid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{geteuid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{try}\NormalTok{ \{}
    \BuiltInTok{process}\OperatorTok{.}\FunctionTok{seteuid}\NormalTok{(}\DecValTok{501}\NormalTok{)}\OperatorTok{;}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}New uid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{geteuid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Failed to set uid: }\SpecialCharTok{$\{}\NormalTok{err}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This function is only available on POSIX platforms (i.e.~not Windows or
Android). This feature is not available in
\href{worker_threads.md\#class-worker}{\texttt{Worker}} threads.

\subsection{\texorpdfstring{\texttt{process.setgid(id)}}{process.setgid(id)}}\label{process.setgidid}

\begin{itemize}
\tightlist
\item
  \texttt{id} \{string\textbar number\} The group name or ID
\end{itemize}

The \texttt{process.setgid()} method sets the group identity of the
process. (See setgid(2).) The \texttt{id} can be passed as either a
numeric ID or a group name string. If a group name is specified, this
method blocks while resolving the associated numeric ID.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgid} \OperatorTok{\&\&} \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setgid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current gid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{try}\NormalTok{ \{}
    \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setgid}\NormalTok{(}\DecValTok{501}\NormalTok{)}\OperatorTok{;}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}New gid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Failed to set gid: }\SpecialCharTok{$\{}\NormalTok{err}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgid} \OperatorTok{\&\&} \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setgid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current gid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{try}\NormalTok{ \{}
    \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setgid}\NormalTok{(}\DecValTok{501}\NormalTok{)}\OperatorTok{;}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}New gid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Failed to set gid: }\SpecialCharTok{$\{}\NormalTok{err}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This function is only available on POSIX platforms (i.e.~not Windows or
Android). This feature is not available in
\href{worker_threads.md\#class-worker}{\texttt{Worker}} threads.

\subsection{\texorpdfstring{\texttt{process.setgroups(groups)}}{process.setgroups(groups)}}\label{process.setgroupsgroups}

\begin{itemize}
\tightlist
\item
  \texttt{groups} \{integer{[}{]}\}
\end{itemize}

The \texttt{process.setgroups()} method sets the supplementary group IDs
for the Node.js process. This is a privileged operation that requires
the Node.js process to have \texttt{root} or the \texttt{CAP\_SETGID}
capability.

The \texttt{groups} array can contain numeric group IDs, group names, or
both.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgroups} \OperatorTok{\&\&} \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setgroups}\NormalTok{) \{}
  \ControlFlowTok{try}\NormalTok{ \{}
    \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setgroups}\NormalTok{([}\DecValTok{501}\NormalTok{])}\OperatorTok{;}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgroups}\NormalTok{())}\OperatorTok{;} \CommentTok{// new groups}
\NormalTok{  \} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Failed to set groups: }\SpecialCharTok{$\{}\NormalTok{err}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgroups} \OperatorTok{\&\&} \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setgroups}\NormalTok{) \{}
  \ControlFlowTok{try}\NormalTok{ \{}
    \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setgroups}\NormalTok{([}\DecValTok{501}\NormalTok{])}\OperatorTok{;}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getgroups}\NormalTok{())}\OperatorTok{;} \CommentTok{// new groups}
\NormalTok{  \} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Failed to set groups: }\SpecialCharTok{$\{}\NormalTok{err}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This function is only available on POSIX platforms (i.e.~not Windows or
Android). This feature is not available in
\href{worker_threads.md\#class-worker}{\texttt{Worker}} threads.

\subsection{\texorpdfstring{\texttt{process.setuid(id)}}{process.setuid(id)}}\label{process.setuidid}

\begin{itemize}
\tightlist
\item
  \texttt{id} \{integer \textbar{} string\}
\end{itemize}

The \texttt{process.setuid(id)} method sets the user identity of the
process. (See setuid(2).) The \texttt{id} can be passed as either a
numeric ID or a username string. If a username is specified, the method
blocks while resolving the associated numeric ID.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import} \BuiltInTok{process} \ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getuid} \OperatorTok{\&\&} \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setuid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current uid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getuid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{try}\NormalTok{ \{}
    \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setuid}\NormalTok{(}\DecValTok{501}\NormalTok{)}\OperatorTok{;}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}New uid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getuid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Failed to set uid: }\SpecialCharTok{$\{}\NormalTok{err}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const} \BuiltInTok{process} \OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\ControlFlowTok{if}\NormalTok{ (}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getuid} \OperatorTok{\&\&} \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setuid}\NormalTok{) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Current uid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getuid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
  \ControlFlowTok{try}\NormalTok{ \{}
    \BuiltInTok{process}\OperatorTok{.}\FunctionTok{setuid}\NormalTok{(}\DecValTok{501}\NormalTok{)}\OperatorTok{;}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}New uid: }\SpecialCharTok{$\{}\BuiltInTok{process}\OperatorTok{.}\FunctionTok{getuid}\NormalTok{()}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
    \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Failed to set uid: }\SpecialCharTok{$\{}\NormalTok{err}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This function is only available on POSIX platforms (i.e.~not Windows or
Android). This feature is not available in
\href{worker_threads.md\#class-worker}{\texttt{Worker}} threads.

\subsection{\texorpdfstring{\texttt{process.setSourceMapsEnabled(val)}}{process.setSourceMapsEnabled(val)}}\label{process.setsourcemapsenabledval}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{val} \{boolean\}
\end{itemize}

This function enables or disables the
\href{https://sourcemaps.info/spec.html}{Source Map v3} support for
stack traces.

It provides same features as launching Node.js process with commandline
options \texttt{-\/-enable-source-maps}.

Only source maps in JavaScript files that are loaded after source maps
has been enabled will be parsed and loaded.

\subsection{\texorpdfstring{\texttt{process.setUncaughtExceptionCaptureCallback(fn)}}{process.setUncaughtExceptionCaptureCallback(fn)}}\label{process.setuncaughtexceptioncapturecallbackfn}

\begin{itemize}
\tightlist
\item
  \texttt{fn} \{Function\textbar null\}
\end{itemize}

The \texttt{process.setUncaughtExceptionCaptureCallback()} function sets
a function that will be invoked when an uncaught exception occurs, which
will receive the exception value itself as its first argument.

If such a function is set, the
\hyperref[event-uncaughtexception]{\texttt{\textquotesingle{}uncaughtException\textquotesingle{}}}
event will not be emitted. If \texttt{-\/-abort-on-uncaught-exception}
was passed from the command line or set through
\href{v8.md\#v8setflagsfromstringflags}{\texttt{v8.setFlagsFromString()}},
the process will not abort. Actions configured to take place on
exceptions such as report generations will be affected too

To unset the capture function,
\texttt{process.setUncaughtExceptionCaptureCallback(null)} may be used.
Calling this method with a non-\texttt{null} argument while another
capture function is set will throw an error.

Using this function is mutually exclusive with using the deprecated
\href{domain.md}{\texttt{domain}} built-in module.

\subsection{\texorpdfstring{\texttt{process.sourceMapsEnabled}}{process.sourceMapsEnabled}}\label{process.sourcemapsenabled}

\begin{quote}
Stability: 1 - Experimental
\end{quote}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

The \texttt{process.sourceMapsEnabled} property returns whether the
\href{https://sourcemaps.info/spec.html}{Source Map v3} support for
stack traces is enabled.

\subsection{\texorpdfstring{\texttt{process.stderr}}{process.stderr}}\label{process.stderr}

\begin{itemize}
\tightlist
\item
  \{Stream\}
\end{itemize}

The \texttt{process.stderr} property returns a stream connected to
\texttt{stderr} (fd \texttt{2}). It is a
\href{net.md\#class-netsocket}{\texttt{net.Socket}} (which is a
\href{stream.md\#duplex-and-transform-streams}{Duplex} stream) unless fd
\texttt{2} refers to a file, in which case it is a
\href{stream.md\#writable-streams}{Writable} stream.

\texttt{process.stderr} differs from other Node.js streams in important
ways. See \hyperref[a-note-on-process-io]{note on process I/O} for more
information.

\subsubsection{\texorpdfstring{\texttt{process.stderr.fd}}{process.stderr.fd}}\label{process.stderr.fd}

\begin{itemize}
\tightlist
\item
  \{number\}
\end{itemize}

This property refers to the value of underlying file descriptor of
\texttt{process.stderr}. The value is fixed at \texttt{2}. In
\href{worker_threads.md\#class-worker}{\texttt{Worker}} threads, this
field does not exist.

\subsection{\texorpdfstring{\texttt{process.stdin}}{process.stdin}}\label{process.stdin}

\begin{itemize}
\tightlist
\item
  \{Stream\}
\end{itemize}

The \texttt{process.stdin} property returns a stream connected to
\texttt{stdin} (fd \texttt{0}). It is a
\href{net.md\#class-netsocket}{\texttt{net.Socket}} (which is a
\href{stream.md\#duplex-and-transform-streams}{Duplex} stream) unless fd
\texttt{0} refers to a file, in which case it is a
\href{stream.md\#readable-streams}{Readable} stream.

For details of how to read from \texttt{stdin} see
\href{stream.md\#readablereadsize}{\texttt{readable.read()}}.

As a \href{stream.md\#duplex-and-transform-streams}{Duplex} stream,
\texttt{process.stdin} can also be used in ``old'' mode that is
compatible with scripts written for Node.js prior to v0.10. For more
information see
\href{stream.md\#compatibility-with-older-nodejs-versions}{Stream
compatibility}.

In ``old'' streams mode the \texttt{stdin} stream is paused by default,
so one must call \texttt{process.stdin.resume()} to read from it. Note
also that calling \texttt{process.stdin.resume()} itself would switch
stream to ``old'' mode.

\subsubsection{\texorpdfstring{\texttt{process.stdin.fd}}{process.stdin.fd}}\label{process.stdin.fd}

\begin{itemize}
\tightlist
\item
  \{number\}
\end{itemize}

This property refers to the value of underlying file descriptor of
\texttt{process.stdin}. The value is fixed at \texttt{0}. In
\href{worker_threads.md\#class-worker}{\texttt{Worker}} threads, this
field does not exist.

\subsection{\texorpdfstring{\texttt{process.stdout}}{process.stdout}}\label{process.stdout}

\begin{itemize}
\tightlist
\item
  \{Stream\}
\end{itemize}

The \texttt{process.stdout} property returns a stream connected to
\texttt{stdout} (fd \texttt{1}). It is a
\href{net.md\#class-netsocket}{\texttt{net.Socket}} (which is a
\href{stream.md\#duplex-and-transform-streams}{Duplex} stream) unless fd
\texttt{1} refers to a file, in which case it is a
\href{stream.md\#writable-streams}{Writable} stream.

For example, to copy \texttt{process.stdin} to \texttt{process.stdout}:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ stdin}\OperatorTok{,}\NormalTok{ stdout \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\NormalTok{stdin}\OperatorTok{.}\FunctionTok{pipe}\NormalTok{(stdout)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ stdin}\OperatorTok{,}\NormalTok{ stdout \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\NormalTok{stdin}\OperatorTok{.}\FunctionTok{pipe}\NormalTok{(stdout)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\texttt{process.stdout} differs from other Node.js streams in important
ways. See \hyperref[a-note-on-process-io]{note on process I/O} for more
information.

\subsubsection{\texorpdfstring{\texttt{process.stdout.fd}}{process.stdout.fd}}\label{process.stdout.fd}

\begin{itemize}
\tightlist
\item
  \{number\}
\end{itemize}

This property refers to the value of underlying file descriptor of
\texttt{process.stdout}. The value is fixed at \texttt{1}. In
\href{worker_threads.md\#class-worker}{\texttt{Worker}} threads, this
field does not exist.

\subsubsection{A note on process I/O}\label{a-note-on-process-io}

\texttt{process.stdout} and \texttt{process.stderr} differ from other
Node.js streams in important ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  They are used internally by
  \href{console.md\#consolelogdata-args}{\texttt{console.log()}} and
  \href{console.md\#consoleerrordata-args}{\texttt{console.error()}},
  respectively.
\item
  Writes may be synchronous depending on what the stream is connected to
  and whether the system is Windows or POSIX:

  \begin{itemize}
  \tightlist
  \item
    Files: \emph{synchronous} on Windows and POSIX
  \item
    TTYs (Terminals): \emph{asynchronous} on Windows, \emph{synchronous}
    on POSIX
  \item
    Pipes (and sockets): \emph{synchronous} on Windows,
    \emph{asynchronous} on POSIX
  \end{itemize}
\end{enumerate}

These behaviors are partly for historical reasons, as changing them
would create backward incompatibility, but they are also expected by
some users.

Synchronous writes avoid problems such as output written with
\texttt{console.log()} or \texttt{console.error()} being unexpectedly
interleaved, or not written at all if \texttt{process.exit()} is called
before an asynchronous write completes. See
\hyperref[processexitcode]{\texttt{process.exit()}} for more
information.

\emph{\textbf{Warning}}: Synchronous writes block the event loop until
the write has completed. This can be near instantaneous in the case of
output to a file, but under high system load, pipes that are not being
read at the receiving end, or with slow terminals or file systems, it's
possible for the event loop to be blocked often enough and long enough
to have severe negative performance impacts. This may not be a problem
when writing to an interactive terminal session, but consider this
particularly careful when doing production logging to the process output
streams.

To check if a stream is connected to a \href{tty.md\#tty}{TTY} context,
check the \texttt{isTTY} property.

For instance:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ node {-}p "Boolean(process.stdin.isTTY)"}
\NormalTok{true}
\NormalTok{$ echo "foo" | node {-}p "Boolean(process.stdin.isTTY)"}
\NormalTok{false}
\NormalTok{$ node {-}p "Boolean(process.stdout.isTTY)"}
\NormalTok{true}
\NormalTok{$ node {-}p "Boolean(process.stdout.isTTY)" | cat}
\NormalTok{false}
\end{Highlighting}
\end{Shaded}

See the \href{tty.md\#tty}{TTY} documentation for more information.

\subsection{\texorpdfstring{\texttt{process.throwDeprecation}}{process.throwDeprecation}}\label{process.throwdeprecation}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

The initial value of \texttt{process.throwDeprecation} indicates whether
the \texttt{-\/-throw-deprecation} flag is set on the current Node.js
process. \texttt{process.throwDeprecation} is mutable, so whether or not
deprecation warnings result in errors may be altered at runtime. See the
documentation for the
\hyperref[event-warning]{\texttt{\textquotesingle{}warning\textquotesingle{}}
event} and the
\hyperref[processemitwarningwarning-type-code-ctor]{\texttt{emitWarning()}
method} for more information.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$ node {-}{-}throw{-}deprecation {-}p "process.throwDeprecation"}
\NormalTok{true}
\NormalTok{$ node {-}p "process.throwDeprecation"}
\NormalTok{undefined}
\NormalTok{$ node}
\NormalTok{\textgreater{} process.emitWarning(\textquotesingle{}test\textquotesingle{}, \textquotesingle{}DeprecationWarning\textquotesingle{});}
\NormalTok{undefined}
\NormalTok{\textgreater{} (node:26598) DeprecationWarning: test}
\NormalTok{\textgreater{} process.throwDeprecation = true;}
\NormalTok{true}
\NormalTok{\textgreater{} process.emitWarning(\textquotesingle{}test\textquotesingle{}, \textquotesingle{}DeprecationWarning\textquotesingle{});}
\NormalTok{Thrown:}
\NormalTok{[DeprecationWarning: test] \{ name: \textquotesingle{}DeprecationWarning\textquotesingle{} \}}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{process.title}}{process.title}}\label{process.title}

\begin{itemize}
\tightlist
\item
  \{string\}
\end{itemize}

The \texttt{process.title} property returns the current process title
(i.e.~returns the current value of \texttt{ps}). Assigning a new value
to \texttt{process.title} modifies the current value of \texttt{ps}.

When a new value is assigned, different platforms will impose different
maximum length restrictions on the title. Usually such restrictions are
quite limited. For instance, on Linux and macOS, \texttt{process.title}
is limited to the size of the binary name plus the length of the
command-line arguments because setting the \texttt{process.title}
overwrites the \texttt{argv} memory of the process. Node.js v0.8 allowed
for longer process title strings by also overwriting the
\texttt{environ} memory but that was potentially insecure and confusing
in some (rather obscure) cases.

Assigning a value to \texttt{process.title} might not result in an
accurate label within process manager applications such as macOS
Activity Monitor or Windows Services Manager.

\subsection{\texorpdfstring{\texttt{process.traceDeprecation}}{process.traceDeprecation}}\label{process.tracedeprecation}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

The \texttt{process.traceDeprecation} property indicates whether the
\texttt{-\/-trace-deprecation} flag is set on the current Node.js
process. See the documentation for the
\hyperref[event-warning]{\texttt{\textquotesingle{}warning\textquotesingle{}}
event} and the
\hyperref[processemitwarningwarning-type-code-ctor]{\texttt{emitWarning()}
method} for more information about this flag's behavior.

\subsection{\texorpdfstring{\texttt{process.umask()}}{process.umask()}}\label{process.umask}

\begin{quote}
Stability: 0 - Deprecated. Calling \texttt{process.umask()} with no
argument causes the process-wide umask to be written twice. This
introduces a race condition between threads, and is a potential security
vulnerability. There is no safe, cross-platform alternative API.
\end{quote}

\texttt{process.umask()} returns the Node.js process's file mode
creation mask. Child processes inherit the mask from the parent process.

\subsection{\texorpdfstring{\texttt{process.umask(mask)}}{process.umask(mask)}}\label{process.umaskmask}

\begin{itemize}
\tightlist
\item
  \texttt{mask} \{string\textbar integer\}
\end{itemize}

\texttt{process.umask(mask)} sets the Node.js process's file mode
creation mask. Child processes inherit the mask from the parent process.
Returns the previous mask.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ umask \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ newmask }\OperatorTok{=} \BaseNTok{0o022}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ oldmask }\OperatorTok{=} \FunctionTok{umask}\NormalTok{(newmask)}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}
  \VerbatimStringTok{\textasciigrave{}Changed umask from }\SpecialCharTok{$\{}\NormalTok{oldmask}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{8}\NormalTok{)}\SpecialCharTok{\}}\VerbatimStringTok{ to }\SpecialCharTok{$\{}\NormalTok{newmask}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{8}\NormalTok{)}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\OperatorTok{,}
\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ umask \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ newmask }\OperatorTok{=} \BaseNTok{0o022}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ oldmask }\OperatorTok{=} \FunctionTok{umask}\NormalTok{(newmask)}\OperatorTok{;}
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}
  \VerbatimStringTok{\textasciigrave{}Changed umask from }\SpecialCharTok{$\{}\NormalTok{oldmask}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{8}\NormalTok{)}\SpecialCharTok{\}}\VerbatimStringTok{ to }\SpecialCharTok{$\{}\NormalTok{newmask}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\DecValTok{8}\NormalTok{)}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\OperatorTok{,}
\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

In \href{worker_threads.md\#class-worker}{\texttt{Worker}} threads,
\texttt{process.umask(mask)} will throw an exception.

\subsection{\texorpdfstring{\texttt{process.uptime()}}{process.uptime()}}\label{process.uptime}

\begin{itemize}
\tightlist
\item
  Returns: \{number\}
\end{itemize}

The \texttt{process.uptime()} method returns the number of seconds the
current Node.js process has been running.

The return value includes fractions of a second. Use
\texttt{Math.floor()} to get whole seconds.

\subsection{\texorpdfstring{\texttt{process.version}}{process.version}}\label{process.version}

\begin{itemize}
\tightlist
\item
  \{string\}
\end{itemize}

The \texttt{process.version} property contains the Node.js version
string.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ version \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Version: }\SpecialCharTok{$\{}\NormalTok{version}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Version: v14.8.0}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ version \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\VerbatimStringTok{\textasciigrave{}Version: }\SpecialCharTok{$\{}\NormalTok{version}\SpecialCharTok{\}}\VerbatimStringTok{\textasciigrave{}}\NormalTok{)}\OperatorTok{;}
\CommentTok{// Version: v14.8.0}
\end{Highlighting}
\end{Shaded}

To get the version string without the prepended \emph{v}, use
\texttt{process.versions.node}.

\subsection{\texorpdfstring{\texttt{process.versions}}{process.versions}}\label{process.versions}

\begin{itemize}
\tightlist
\item
  \{Object\}
\end{itemize}

The \texttt{process.versions} property returns an object listing the
version strings of Node.js and its dependencies.
\texttt{process.versions.modules} indicates the current ABI version,
which is increased whenever a C++ API changes. Node.js will refuse to
load modules that were compiled against a different module ABI version.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ \{ versions \} }\ImportTok{from} \StringTok{\textquotesingle{}node:process\textquotesingle{}}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(versions)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ \{ versions \} }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:process\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(versions)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

Will generate an object similar to:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\{ node: \textquotesingle{}20.2.0\textquotesingle{},}
\NormalTok{  acorn: \textquotesingle{}8.8.2\textquotesingle{},}
\NormalTok{  ada: \textquotesingle{}2.4.0\textquotesingle{},}
\NormalTok{  ares: \textquotesingle{}1.19.0\textquotesingle{},}
\NormalTok{  base64: \textquotesingle{}0.5.0\textquotesingle{},}
\NormalTok{  brotli: \textquotesingle{}1.0.9\textquotesingle{},}
\NormalTok{  cjs\_module\_lexer: \textquotesingle{}1.2.2\textquotesingle{},}
\NormalTok{  cldr: \textquotesingle{}43.0\textquotesingle{},}
\NormalTok{  icu: \textquotesingle{}73.1\textquotesingle{},}
\NormalTok{  llhttp: \textquotesingle{}8.1.0\textquotesingle{},}
\NormalTok{  modules: \textquotesingle{}115\textquotesingle{},}
\NormalTok{  napi: \textquotesingle{}8\textquotesingle{},}
\NormalTok{  nghttp2: \textquotesingle{}1.52.0\textquotesingle{},}
\NormalTok{  nghttp3: \textquotesingle{}0.7.0\textquotesingle{},}
\NormalTok{  ngtcp2: \textquotesingle{}0.8.1\textquotesingle{},}
\NormalTok{  openssl: \textquotesingle{}3.0.8+quic\textquotesingle{},}
\NormalTok{  simdutf: \textquotesingle{}3.2.9\textquotesingle{},}
\NormalTok{  tz: \textquotesingle{}2023c\textquotesingle{},}
\NormalTok{  undici: \textquotesingle{}5.22.0\textquotesingle{},}
\NormalTok{  unicode: \textquotesingle{}15.0\textquotesingle{},}
\NormalTok{  uv: \textquotesingle{}1.44.2\textquotesingle{},}
\NormalTok{  uvwasi: \textquotesingle{}0.0.16\textquotesingle{},}
\NormalTok{  v8: \textquotesingle{}11.3.244.8{-}node.9\textquotesingle{},}
\NormalTok{  zlib: \textquotesingle{}1.2.13\textquotesingle{} \}}
\end{Highlighting}
\end{Shaded}

\subsection{Exit codes}\label{exit-codes}

Node.js will normally exit with a \texttt{0} status code when no more
async operations are pending. The following status codes are used in
other cases:

\begin{itemize}
\tightlist
\item
  \texttt{1} \textbf{Uncaught Fatal Exception}: There was an uncaught
  exception, and it was not handled by a domain or an
  \hyperref[event-uncaughtexception]{\texttt{\textquotesingle{}uncaughtException\textquotesingle{}}}
  event handler.
\item
  \texttt{2}: Unused (reserved by Bash for builtin misuse)
\item
  \texttt{3} \textbf{Internal JavaScript Parse Error}: The JavaScript
  source code internal in the Node.js bootstrapping process caused a
  parse error. This is extremely rare, and generally can only happen
  during development of Node.js itself.
\item
  \texttt{4} \textbf{Internal JavaScript Evaluation Failure}: The
  JavaScript source code internal in the Node.js bootstrapping process
  failed to return a function value when evaluated. This is extremely
  rare, and generally can only happen during development of Node.js
  itself.
\item
  \texttt{5} \textbf{Fatal Error}: There was a fatal unrecoverable error
  in V8. Typically a message will be printed to stderr with the prefix
  \texttt{FATAL\ \ \ ERROR}.
\item
  \texttt{6} \textbf{Non-function Internal Exception Handler}: There was
  an uncaught exception, but the internal fatal exception handler
  function was somehow set to a non-function, and could not be called.
\item
  \texttt{7} \textbf{Internal Exception Handler Run-Time Failure}: There
  was an uncaught exception, and the internal fatal exception handler
  function itself threw an error while attempting to handle it. This can
  happen, for example, if an
  \hyperref[event-uncaughtexception]{\texttt{\textquotesingle{}uncaughtException\textquotesingle{}}}
  or \texttt{domain.on(\textquotesingle{}error\textquotesingle{})}
  handler throws an error.
\item
  \texttt{8}: Unused. In previous versions of Node.js, exit code 8
  sometimes indicated an uncaught exception.
\item
  \texttt{9} \textbf{Invalid Argument}: Either an unknown option was
  specified, or an option requiring a value was provided without a
  value.
\item
  \texttt{10} \textbf{Internal JavaScript Run-Time Failure}: The
  JavaScript source code internal in the Node.js bootstrapping process
  threw an error when the bootstrapping function was called. This is
  extremely rare, and generally can only happen during development of
  Node.js itself.
\item
  \texttt{12} \textbf{Invalid Debug Argument}: The \texttt{-\/-inspect}
  and/or \texttt{-\/-inspect-brk} options were set, but the port number
  chosen was invalid or unavailable.
\item
  \texttt{13} \textbf{Unfinished Top-Level Await}: \texttt{await} was
  used outside of a function in the top-level code, but the passed
  \texttt{Promise} never resolved.
\item
  \texttt{14} \textbf{Snapshot Failure}: Node.js was started to build a
  V8 startup snapshot and it failed because certain requirements of the
  state of the application were not met.
\item
  \texttt{\textgreater{}128} \textbf{Signal Exits}: If Node.js receives
  a fatal signal such as \texttt{SIGKILL} or \texttt{SIGHUP}, then its
  exit code will be \texttt{128} plus the value of the signal code. This
  is a standard POSIX practice, since exit codes are defined to be 7-bit
  integers, and signal exits set the high-order bit, and then contain
  the value of the signal code. For example, signal \texttt{SIGABRT} has
  value \texttt{6}, so the expected exit code will be \texttt{128} +
  \texttt{6}, or \texttt{134}.
\end{itemize}
