\section{TLS (SSL)}\label{tls-ssl}

\begin{quote}
Stability: 2 - Stable
\end{quote}

The \texttt{node:tls} module provides an implementation of the Transport
Layer Security (TLS) and Secure Socket Layer (SSL) protocols that is
built on top of OpenSSL. The module can be accessed using:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ tls }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:tls\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{Determining if crypto support is
unavailable}\label{determining-if-crypto-support-is-unavailable}

It is possible for Node.js to be built without including support for the
\texttt{node:crypto} module. In such cases, attempting to
\texttt{import} from \texttt{tls} or calling
\texttt{require(\textquotesingle{}node:tls\textquotesingle{})} will
result in an error being thrown.

When using CommonJS, the error thrown can be caught using try/catch:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ tls}\OperatorTok{;}
\ControlFlowTok{try}\NormalTok{ \{}
\NormalTok{  tls }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:tls\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\StringTok{\textquotesingle{}tls support is disabled!\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

When using the lexical ESM \texttt{import} keyword, the error can only
be caught if a handler for
\texttt{process.on(\textquotesingle{}uncaughtException\textquotesingle{})}
is registered \emph{before} any attempt to load the module is made
(using, for instance, a preload module).

When using ESM, if there is a chance that the code may be run on a build
of Node.js where crypto support is not enabled, consider using the
\href{https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import}{\texttt{import()}}
function instead of the lexical \texttt{import} keyword:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{let}\NormalTok{ tls}\OperatorTok{;}
\ControlFlowTok{try}\NormalTok{ \{}
\NormalTok{  tls }\OperatorTok{=} \ControlFlowTok{await} \ImportTok{import}\NormalTok{(}\StringTok{\textquotesingle{}node:tls\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\} }\ControlFlowTok{catch}\NormalTok{ (err) \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{error}\NormalTok{(}\StringTok{\textquotesingle{}tls support is disabled!\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{TLS/SSL concepts}\label{tlsssl-concepts}

TLS/SSL is a set of protocols that rely on a public key infrastructure
(PKI) to enable secure communication between a client and a server. For
most common cases, each server must have a private key.

Private keys can be generated in multiple ways. The example below
illustrates use of the OpenSSL command-line interface to generate a
2048-bit RSA private key:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{openssl}\NormalTok{ genrsa }\AttributeTok{{-}out}\NormalTok{ ryans{-}key.pem 2048}
\end{Highlighting}
\end{Shaded}

With TLS/SSL, all servers (and some clients) must have a
\emph{certificate}. Certificates are \emph{public keys} that correspond
to a private key, and that are digitally signed either by a Certificate
Authority or by the owner of the private key (such certificates are
referred to as ``self-signed''). The first step to obtaining a
certificate is to create a \emph{Certificate Signing Request} (CSR)
file.

The OpenSSL command-line interface can be used to generate a CSR for a
private key:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{openssl}\NormalTok{ req }\AttributeTok{{-}new} \AttributeTok{{-}sha256} \AttributeTok{{-}key}\NormalTok{ ryans{-}key.pem }\AttributeTok{{-}out}\NormalTok{ ryans{-}csr.pem}
\end{Highlighting}
\end{Shaded}

Once the CSR file is generated, it can either be sent to a Certificate
Authority for signing or used to generate a self-signed certificate.

Creating a self-signed certificate using the OpenSSL command-line
interface is illustrated in the example below:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{openssl}\NormalTok{ x509 }\AttributeTok{{-}req} \AttributeTok{{-}in}\NormalTok{ ryans{-}csr.pem }\AttributeTok{{-}signkey}\NormalTok{ ryans{-}key.pem }\AttributeTok{{-}out}\NormalTok{ ryans{-}cert.pem}
\end{Highlighting}
\end{Shaded}

Once the certificate is generated, it can be used to generate a
\texttt{.pfx} or \texttt{.p12} file:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{openssl}\NormalTok{ pkcs12 }\AttributeTok{{-}export} \AttributeTok{{-}in}\NormalTok{ ryans{-}cert.pem }\AttributeTok{{-}inkey}\NormalTok{ ryans{-}key.pem }\DataTypeTok{\textbackslash{}}
      \AttributeTok{{-}certfile}\NormalTok{ ca{-}cert.pem }\AttributeTok{{-}out}\NormalTok{ ryans.pfx}
\end{Highlighting}
\end{Shaded}

Where:

\begin{itemize}
\tightlist
\item
  \texttt{in}: is the signed certificate
\item
  \texttt{inkey}: is the associated private key
\item
  \texttt{certfile}: is a concatenation of all Certificate Authority
  (CA) certs into a single file,
  e.g.~\texttt{cat\ ca1-cert.pem\ ca2-cert.pem\ \textgreater{}\ ca-cert.pem}
\end{itemize}

\subsubsection{Perfect forward secrecy}\label{perfect-forward-secrecy}

The term
\emph{\href{https://en.wikipedia.org/wiki/Perfect_forward_secrecy}{forward
secrecy}} or \emph{perfect forward secrecy} describes a feature of
key-agreement (i.e., key-exchange) methods. That is, the server and
client keys are used to negotiate new temporary keys that are used
specifically and only for the current communication session.
Practically, this means that even if the server's private key is
compromised, communication can only be decrypted by eavesdroppers if the
attacker manages to obtain the key-pair specifically generated for the
session.

Perfect forward secrecy is achieved by randomly generating a key pair
for key-agreement on every TLS/SSL handshake (in contrast to using the
same key for all sessions). Methods implementing this technique are
called ``ephemeral''.

Currently two methods are commonly used to achieve perfect forward
secrecy (note the character ``E'' appended to the traditional
abbreviations):

\begin{itemize}
\tightlist
\item
  \href{https://en.wikipedia.org/wiki/Elliptic_curve_Diffie\%E2\%80\%93Hellman}{ECDHE}:
  An ephemeral version of the Elliptic Curve Diffie-Hellman
  key-agreement protocol.
\item
  \href{https://en.wikipedia.org/wiki/Diffie\%E2\%80\%93Hellman_key_exchange}{DHE}:
  An ephemeral version of the Diffie-Hellman key-agreement protocol.
\end{itemize}

Perfect forward secrecy using ECDHE is enabled by default. The
\texttt{ecdhCurve} option can be used when creating a TLS server to
customize the list of supported ECDH curves to use. See
\hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}
for more info.

DHE is disabled by default but can be enabled alongside ECDHE by setting
the \texttt{dhparam} option to
\texttt{\textquotesingle{}auto\textquotesingle{}}. Custom DHE parameters
are also supported but discouraged in favor of automatically selected,
well-known parameters.

Perfect forward secrecy was optional up to TLSv1.2. As of TLSv1.3,
(EC)DHE is always used (with the exception of PSK-only connections).

\subsubsection{ALPN and SNI}\label{alpn-and-sni}

ALPN (Application-Layer Protocol Negotiation Extension) and SNI (Server
Name Indication) are TLS handshake extensions:

\begin{itemize}
\tightlist
\item
  ALPN: Allows the use of one TLS server for multiple protocols (HTTP,
  HTTP/2)
\item
  SNI: Allows the use of one TLS server for multiple hostnames with
  different certificates.
\end{itemize}

\subsubsection{Pre-shared keys}\label{pre-shared-keys}

TLS-PSK support is available as an alternative to normal
certificate-based authentication. It uses a pre-shared key instead of
certificates to authenticate a TLS connection, providing mutual
authentication. TLS-PSK and public key infrastructure are not mutually
exclusive. Clients and servers can accommodate both, choosing either of
them during the normal cipher negotiation step.

TLS-PSK is only a good choice where means exist to securely share a key
with every connecting machine, so it does not replace the public key
infrastructure (PKI) for the majority of TLS uses. The TLS-PSK
implementation in OpenSSL has seen many security flaws in recent years,
mostly because it is used only by a minority of applications. Please
consider all alternative solutions before switching to PSK ciphers. Upon
generating PSK it is of critical importance to use sufficient entropy as
discussed in \href{https://tools.ietf.org/html/rfc4086}{RFC 4086}.
Deriving a shared secret from a password or other low-entropy sources is
not secure.

PSK ciphers are disabled by default, and using TLS-PSK thus requires
explicitly specifying a cipher suite with the \texttt{ciphers} option.
The list of available ciphers can be retrieved via
\texttt{openssl\ ciphers\ -v\ \textquotesingle{}PSK\textquotesingle{}}.
All TLS 1.3 ciphers are eligible for PSK and can be retrieved via
\texttt{openssl\ ciphers\ -v\ -s\ -tls1\_3\ -psk}.

According to the \href{https://tools.ietf.org/html/rfc4279}{RFC 4279},
PSK identities up to 128 bytes in length and PSKs up to 64 bytes in
length must be supported. As of OpenSSL 1.1.0 maximum identity size is
128 bytes, and maximum PSK length is 256 bytes.

The current implementation doesn't support asynchronous PSK callbacks
due to the limitations of the underlying OpenSSL API.

\subsubsection{Client-initiated renegotiation attack
mitigation}\label{client-initiated-renegotiation-attack-mitigation}

The TLS protocol allows clients to renegotiate certain aspects of the
TLS session. Unfortunately, session renegotiation requires a
disproportionate amount of server-side resources, making it a potential
vector for denial-of-service attacks.

To mitigate the risk, renegotiation is limited to three times every ten
minutes. An \texttt{\textquotesingle{}error\textquotesingle{}} event is
emitted on the \hyperref[class-tlstlssocket]{\texttt{tls.TLSSocket}}
instance when this threshold is exceeded. The limits are configurable:

\begin{itemize}
\tightlist
\item
  \texttt{tls.CLIENT\_RENEG\_LIMIT} \{number\} Specifies the number of
  renegotiation requests. \textbf{Default:} \texttt{3}.
\item
  \texttt{tls.CLIENT\_RENEG\_WINDOW} \{number\} Specifies the time
  renegotiation window in seconds. \textbf{Default:} \texttt{600} (10
  minutes).
\end{itemize}

The default renegotiation limits should not be modified without a full
understanding of the implications and risks.

TLSv1.3 does not support renegotiation.

\subsubsection{Session resumption}\label{session-resumption}

Establishing a TLS session can be relatively slow. The process can be
sped up by saving and later reusing the session state. There are several
mechanisms to do so, discussed here from oldest to newest (and
preferred).

\paragraph{Session identifiers}\label{session-identifiers}

Servers generate a unique ID for new connections and send it to the
client. Clients and servers save the session state. When reconnecting,
clients send the ID of their saved session state and if the server also
has the state for that ID, it can agree to use it. Otherwise, the server
will create a new session. See
\href{https://www.ietf.org/rfc/rfc2246.txt}{RFC 2246} for more
information, page 23 and 30.

Resumption using session identifiers is supported by most web browsers
when making HTTPS requests.

For Node.js, clients wait for the
\hyperref[event-session]{\texttt{\textquotesingle{}session\textquotesingle{}}}
event to get the session data, and provide the data to the
\texttt{session} option of a subsequent
\hyperref[tlsconnectoptions-callback]{\texttt{tls.connect()}} to reuse
the session. Servers must implement handlers for the
\hyperref[event-newsession]{\texttt{\textquotesingle{}newSession\textquotesingle{}}}
and
\hyperref[event-resumesession]{\texttt{\textquotesingle{}resumeSession\textquotesingle{}}}
events to save and restore the session data using the session ID as the
lookup key to reuse sessions. To reuse sessions across load balancers or
cluster workers, servers must use a shared session cache (such as Redis)
in their session handlers.

\paragraph{Session tickets}\label{session-tickets}

The servers encrypt the entire session state and send it to the client
as a ``ticket''. When reconnecting, the state is sent to the server in
the initial connection. This mechanism avoids the need for a server-side
session cache. If the server doesn't use the ticket, for any reason
(failure to decrypt it, it's too old, etc.), it will create a new
session and send a new ticket. See
\href{https://tools.ietf.org/html/rfc5077}{RFC 5077} for more
information.

Resumption using session tickets is becoming commonly supported by many
web browsers when making HTTPS requests.

For Node.js, clients use the same APIs for resumption with session
identifiers as for resumption with session tickets. For debugging, if
\hyperref[tlssocketgettlsticket]{\texttt{tls.TLSSocket.getTLSTicket()}}
returns a value, the session data contains a ticket, otherwise it
contains client-side session state.

With TLSv1.3, be aware that multiple tickets may be sent by the server,
resulting in multiple
\texttt{\textquotesingle{}session\textquotesingle{}} events, see
\hyperref[event-session]{\texttt{\textquotesingle{}session\textquotesingle{}}}
for more information.

Single process servers need no specific implementation to use session
tickets. To use session tickets across server restarts or load
balancers, servers must all have the same ticket keys. There are three
16-byte keys internally, but the tls API exposes them as a single
48-byte buffer for convenience.

It's possible to get the ticket keys by calling
\hyperref[servergetticketkeys]{\texttt{server.getTicketKeys()}} on one
server instance and then distribute them, but it is more reasonable to
securely generate 48 bytes of secure random data and set them with the
\texttt{ticketKeys} option of
\hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}.
The keys should be regularly regenerated and server's keys can be reset
with
\hyperref[serversetticketkeyskeys]{\texttt{server.setTicketKeys()}}.

Session ticket keys are cryptographic keys, and they \emph{\textbf{must
be stored securely}}. With TLS 1.2 and below, if they are compromised
all sessions that used tickets encrypted with them can be decrypted.
They should not be stored on disk, and they should be regenerated
regularly.

If clients advertise support for tickets, the server will send them. The
server can disable tickets by supplying
\texttt{require(\textquotesingle{}node:constants\textquotesingle{}).SSL\_OP\_NO\_TICKET}
in \texttt{secureOptions}.

Both session identifiers and session tickets timeout, causing the server
to create new sessions. The timeout can be configured with the
\texttt{sessionTimeout} option of
\hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}.

For all the mechanisms, when resumption fails, servers will create new
sessions. Since failing to resume the session does not cause TLS/HTTPS
connection failures, it is easy to not notice unnecessarily poor TLS
performance. The OpenSSL CLI can be used to verify that servers are
resuming sessions. Use the \texttt{-reconnect} option to
\texttt{openssl\ s\_client}, for example:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{openssl}\NormalTok{ s\_client }\AttributeTok{{-}connect}\NormalTok{ localhost:443 }\AttributeTok{{-}reconnect}
\end{Highlighting}
\end{Shaded}

Read through the debug output. The first connection should say ``New'',
for example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{New, TLSv1.2, Cipher is ECDHE{-}RSA{-}AES128{-}GCM{-}SHA256}
\end{Highlighting}
\end{Shaded}

Subsequent connections should say ``Reused'', for example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Reused, TLSv1.2, Cipher is ECDHE{-}RSA{-}AES128{-}GCM{-}SHA256}
\end{Highlighting}
\end{Shaded}

\subsection{Modifying the default TLS cipher
suite}\label{modifying-the-default-tls-cipher-suite}

Node.js is built with a default suite of enabled and disabled TLS
ciphers. This default cipher list can be configured when building
Node.js to allow distributions to provide their own default list.

The following command can be used to show the default cipher suite:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{node {-}p crypto.constants.defaultCoreCipherList | tr \textquotesingle{}:\textquotesingle{} \textquotesingle{}\textbackslash{}n\textquotesingle{}}
\NormalTok{TLS\_AES\_256\_GCM\_SHA384}
\NormalTok{TLS\_CHACHA20\_POLY1305\_SHA256}
\NormalTok{TLS\_AES\_128\_GCM\_SHA256}
\NormalTok{ECDHE{-}RSA{-}AES128{-}GCM{-}SHA256}
\NormalTok{ECDHE{-}ECDSA{-}AES128{-}GCM{-}SHA256}
\NormalTok{ECDHE{-}RSA{-}AES256{-}GCM{-}SHA384}
\NormalTok{ECDHE{-}ECDSA{-}AES256{-}GCM{-}SHA384}
\NormalTok{DHE{-}RSA{-}AES128{-}GCM{-}SHA256}
\NormalTok{ECDHE{-}RSA{-}AES128{-}SHA256}
\NormalTok{DHE{-}RSA{-}AES128{-}SHA256}
\NormalTok{ECDHE{-}RSA{-}AES256{-}SHA384}
\NormalTok{DHE{-}RSA{-}AES256{-}SHA384}
\NormalTok{ECDHE{-}RSA{-}AES256{-}SHA256}
\NormalTok{DHE{-}RSA{-}AES256{-}SHA256}
\NormalTok{HIGH}
\NormalTok{!aNULL}
\NormalTok{!eNULL}
\NormalTok{!EXPORT}
\NormalTok{!DES}
\NormalTok{!RC4}
\NormalTok{!MD5}
\NormalTok{!PSK}
\NormalTok{!SRP}
\NormalTok{!CAMELLIA}
\end{Highlighting}
\end{Shaded}

This default can be replaced entirely using the
\href{cli.md\#--tls-cipher-listlist}{\texttt{-\/-tls-cipher-list}}
command-line switch (directly, or via the
\href{cli.md\#node_optionsoptions}{\texttt{NODE\_OPTIONS}} environment
variable). For instance, the following makes
\texttt{ECDHE-RSA-AES128-GCM-SHA256:!RC4} the default TLS cipher suite:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{node} \AttributeTok{{-}{-}tls{-}cipher{-}list}\OperatorTok{=}\StringTok{\textquotesingle{}ECDHE{-}RSA{-}AES128{-}GCM{-}SHA256:!RC4\textquotesingle{}}\NormalTok{ server.js}

\BuiltInTok{export} \VariableTok{NODE\_OPTIONS}\OperatorTok{=}\NormalTok{{-}{-}tls{-}cipher{-}list=}\StringTok{\textquotesingle{}ECDHE{-}RSA{-}AES128{-}GCM{-}SHA256:!RC4\textquotesingle{}}
\ExtensionTok{node}\NormalTok{ server.js}
\end{Highlighting}
\end{Shaded}

To verify, use the following command to show the set cipher list, note
the difference between \texttt{defaultCoreCipherList} and
\texttt{defaultCipherList}:

\begin{Shaded}
\begin{Highlighting}[]
\ExtensionTok{node} \AttributeTok{{-}{-}tls{-}cipher{-}list}\OperatorTok{=}\StringTok{\textquotesingle{}ECDHE{-}RSA{-}AES128{-}GCM{-}SHA256:!RC4\textquotesingle{}} \AttributeTok{{-}p}\NormalTok{ crypto.constants.defaultCipherList }\KeywordTok{|} \FunctionTok{tr} \StringTok{\textquotesingle{}:\textquotesingle{}} \StringTok{\textquotesingle{}\textbackslash{}n\textquotesingle{}}
\ExtensionTok{ECDHE{-}RSA{-}AES128{-}GCM{-}SHA256}
\ExtensionTok{!RC4}
\end{Highlighting}
\end{Shaded}

i.e.~the \texttt{defaultCoreCipherList} list is set at compilation time
and the \texttt{defaultCipherList} is set at runtime.

To modify the default cipher suites from within the runtime, modify the
\texttt{tls.DEFAULT\_CIPHERS} variable, this must be performed before
listening on any sockets, it will not affect sockets already opened. For
example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Remove Obsolete CBC Ciphers and RSA Key Exchange based Ciphers as they don\textquotesingle{}t provide Forward Secrecy}
\NormalTok{tls}\OperatorTok{.}\AttributeTok{DEFAULT\_CIPHERS} \OperatorTok{+=}
  \StringTok{\textquotesingle{}:!ECDHE{-}RSA{-}AES128{-}SHA:!ECDHE{-}RSA{-}AES128{-}SHA256:!ECDHE{-}RSA{-}AES256{-}SHA:!ECDHE{-}RSA{-}AES256{-}SHA384\textquotesingle{}} \OperatorTok{+}
  \StringTok{\textquotesingle{}:!ECDHE{-}ECDSA{-}AES128{-}SHA:!ECDHE{-}ECDSA{-}AES128{-}SHA256:!ECDHE{-}ECDSA{-}AES256{-}SHA:!ECDHE{-}ECDSA{-}AES256{-}SHA384\textquotesingle{}} \OperatorTok{+}
  \StringTok{\textquotesingle{}:!kRSA\textquotesingle{}}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The default can also be replaced on a per client or server basis using
the \texttt{ciphers} option from
\hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}},
which is also available in
\hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}},
\hyperref[tlsconnectoptions-callback]{\texttt{tls.connect()}}, and when
creating new \hyperref[class-tlstlssocket]{\texttt{tls.TLSSocket}}s.

The ciphers list can contain a mixture of TLSv1.3 cipher suite names,
the ones that start with
\texttt{\textquotesingle{}TLS\_\textquotesingle{}}, and specifications
for TLSv1.2 and below cipher suites. The TLSv1.2 ciphers support a
legacy specification format, consult the OpenSSL
\href{https://www.openssl.org/docs/man1.1.1/man1/ciphers.html\#CIPHER-LIST-FORMAT}{cipher
list format} documentation for details, but those specifications do
\emph{not} apply to TLSv1.3 ciphers. The TLSv1.3 suites can only be
enabled by including their full name in the cipher list. They cannot,
for example, be enabled or disabled by using the legacy TLSv1.2
\texttt{\textquotesingle{}EECDH\textquotesingle{}} or
\texttt{\textquotesingle{}!EECDH\textquotesingle{}} specification.

Despite the relative order of TLSv1.3 and TLSv1.2 cipher suites, the
TLSv1.3 protocol is significantly more secure than TLSv1.2, and will
always be chosen over TLSv1.2 if the handshake indicates it is
supported, and if any TLSv1.3 cipher suites are enabled.

The default cipher suite included within Node.js has been carefully
selected to reflect current security best practices and risk mitigation.
Changing the default cipher suite can have a significant impact on the
security of an application. The \texttt{-\/-tls-cipher-list} switch and
\texttt{ciphers} option should by used only if absolutely necessary.

The default cipher suite prefers GCM ciphers for
\href{https://www.chromium.org/Home/chromium-security/education/tls\#TOC-Cipher-Suites}{Chrome's
`modern cryptography' setting} and also prefers ECDHE and DHE ciphers
for perfect forward secrecy, while offering \emph{some} backward
compatibility.

Old clients that rely on insecure and deprecated RC4 or DES-based
ciphers (like Internet Explorer 6) cannot complete the handshaking
process with the default configuration. If these clients \emph{must} be
supported, the
\href{https://wiki.mozilla.org/Security/Server_Side_TLS}{TLS
recommendations} may offer a compatible cipher suite. For more details
on the format, see the OpenSSL
\href{https://www.openssl.org/docs/man1.1.1/man1/ciphers.html\#CIPHER-LIST-FORMAT}{cipher
list format} documentation.

There are only five TLSv1.3 cipher suites:

\begin{itemize}
\tightlist
\item
  \texttt{\textquotesingle{}TLS\_AES\_256\_GCM\_SHA384\textquotesingle{}}
\item
  \texttt{\textquotesingle{}TLS\_CHACHA20\_POLY1305\_SHA256\textquotesingle{}}
\item
  \texttt{\textquotesingle{}TLS\_AES\_128\_GCM\_SHA256\textquotesingle{}}
\item
  \texttt{\textquotesingle{}TLS\_AES\_128\_CCM\_SHA256\textquotesingle{}}
\item
  \texttt{\textquotesingle{}TLS\_AES\_128\_CCM\_8\_SHA256\textquotesingle{}}
\end{itemize}

The first three are enabled by default. The two \texttt{CCM}-based
suites are supported by TLSv1.3 because they may be more performant on
constrained systems, but they are not enabled by default since they
offer less security.

\subsection{X509 certificate error
codes}\label{x509-certificate-error-codes}

Multiple functions can fail due to certificate errors that are reported
by OpenSSL. In such a case, the function provides an \{Error\} via its
callback that has the property \texttt{code} which can take one of the
following values:

\begin{itemize}
\tightlist
\item
  \texttt{\textquotesingle{}UNABLE\_TO\_GET\_ISSUER\_CERT\textquotesingle{}}:
  Unable to get issuer certificate.
\item
  \texttt{\textquotesingle{}UNABLE\_TO\_GET\_CRL\textquotesingle{}}:
  Unable to get certificate CRL.
\item
  \texttt{\textquotesingle{}UNABLE\_TO\_DECRYPT\_CERT\_SIGNATURE\textquotesingle{}}:
  Unable to decrypt certificate's signature.
\item
  \texttt{\textquotesingle{}UNABLE\_TO\_DECRYPT\_CRL\_SIGNATURE\textquotesingle{}}:
  Unable to decrypt CRL's signature.
\item
  \texttt{\textquotesingle{}UNABLE\_TO\_DECODE\_ISSUER\_PUBLIC\_KEY\textquotesingle{}}:
  Unable to decode issuer public key.
\item
  \texttt{\textquotesingle{}CERT\_SIGNATURE\_FAILURE\textquotesingle{}}:
  Certificate signature failure.
\item
  \texttt{\textquotesingle{}CRL\_SIGNATURE\_FAILURE\textquotesingle{}}:
  CRL signature failure.
\item
  \texttt{\textquotesingle{}CERT\_NOT\_YET\_VALID\textquotesingle{}}:
  Certificate is not yet valid.
\item
  \texttt{\textquotesingle{}CERT\_HAS\_EXPIRED\textquotesingle{}}:
  Certificate has expired.
\item
  \texttt{\textquotesingle{}CRL\_NOT\_YET\_VALID\textquotesingle{}}: CRL
  is not yet valid.
\item
  \texttt{\textquotesingle{}CRL\_HAS\_EXPIRED\textquotesingle{}}: CRL
  has expired.
\item
  \texttt{\textquotesingle{}ERROR\_IN\_CERT\_NOT\_BEFORE\_FIELD\textquotesingle{}}:
  Format error in certificate's notBefore field.
\item
  \texttt{\textquotesingle{}ERROR\_IN\_CERT\_NOT\_AFTER\_FIELD\textquotesingle{}}:
  Format error in certificate's notAfter field.
\item
  \texttt{\textquotesingle{}ERROR\_IN\_CRL\_LAST\_UPDATE\_FIELD\textquotesingle{}}:
  Format error in CRL's lastUpdate field.
\item
  \texttt{\textquotesingle{}ERROR\_IN\_CRL\_NEXT\_UPDATE\_FIELD\textquotesingle{}}:
  Format error in CRL's nextUpdate field.
\item
  \texttt{\textquotesingle{}OUT\_OF\_MEM\textquotesingle{}}: Out of
  memory.
\item
  \texttt{\textquotesingle{}DEPTH\_ZERO\_SELF\_SIGNED\_CERT\textquotesingle{}}:
  Self signed certificate.
\item
  \texttt{\textquotesingle{}SELF\_SIGNED\_CERT\_IN\_CHAIN\textquotesingle{}}:
  Self signed certificate in certificate chain.
\item
  \texttt{\textquotesingle{}UNABLE\_TO\_GET\_ISSUER\_CERT\_LOCALLY\textquotesingle{}}:
  Unable to get local issuer certificate.
\item
  \texttt{\textquotesingle{}UNABLE\_TO\_VERIFY\_LEAF\_SIGNATURE\textquotesingle{}}:
  Unable to verify the first certificate.
\item
  \texttt{\textquotesingle{}CERT\_CHAIN\_TOO\_LONG\textquotesingle{}}:
  Certificate chain too long.
\item
  \texttt{\textquotesingle{}CERT\_REVOKED\textquotesingle{}}:
  Certificate revoked.
\item
  \texttt{\textquotesingle{}INVALID\_CA\textquotesingle{}}: Invalid CA
  certificate.
\item
  \texttt{\textquotesingle{}PATH\_LENGTH\_EXCEEDED\textquotesingle{}}:
  Path length constraint exceeded.
\item
  \texttt{\textquotesingle{}INVALID\_PURPOSE\textquotesingle{}}:
  Unsupported certificate purpose.
\item
  \texttt{\textquotesingle{}CERT\_UNTRUSTED\textquotesingle{}}:
  Certificate not trusted.
\item
  \texttt{\textquotesingle{}CERT\_REJECTED\textquotesingle{}}:
  Certificate rejected.
\item
  \texttt{\textquotesingle{}HOSTNAME\_MISMATCH\textquotesingle{}}:
  Hostname mismatch.
\end{itemize}

\subsection{\texorpdfstring{Class:
\texttt{tls.CryptoStream}}{Class: tls.CryptoStream}}\label{class-tls.cryptostream}

\begin{quote}
Stability: 0 - Deprecated: Use
\hyperref[class-tlstlssocket]{\texttt{tls.TLSSocket}} instead.
\end{quote}

The \texttt{tls.CryptoStream} class represents a stream of encrypted
data. This class is deprecated and should no longer be used.

\subsubsection{\texorpdfstring{\texttt{cryptoStream.bytesWritten}}{cryptoStream.bytesWritten}}\label{cryptostream.byteswritten}

The \texttt{cryptoStream.bytesWritten} property returns the total number
of bytes written to the underlying socket \emph{including} the bytes
required for the implementation of the TLS protocol.

\subsection{\texorpdfstring{Class:
\texttt{tls.SecurePair}}{Class: tls.SecurePair}}\label{class-tls.securepair}

\begin{quote}
Stability: 0 - Deprecated: Use
\hyperref[class-tlstlssocket]{\texttt{tls.TLSSocket}} instead.
\end{quote}

Returned by
\hyperref[tlscreatesecurepaircontext-isserver-requestcert-rejectunauthorized-options]{\texttt{tls.createSecurePair()}}.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}secure\textquotesingle{}}}{Event: \textquotesingle secure\textquotesingle{}}}\label{event-secure}

The \texttt{\textquotesingle{}secure\textquotesingle{}} event is emitted
by the \texttt{SecurePair} object once a secure connection has been
established.

As with checking for the server
\hyperref[event-secureconnection]{\texttt{\textquotesingle{}secureConnection\textquotesingle{}}}
event, \texttt{pair.cleartext.authorized} should be inspected to confirm
whether the certificate used is properly authorized.

\subsection{\texorpdfstring{Class:
\texttt{tls.Server}}{Class: tls.Server}}\label{class-tls.server}

\begin{itemize}
\tightlist
\item
  Extends: \{net.Server\}
\end{itemize}

Accepts encrypted connections using TLS or SSL.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}connection\textquotesingle{}}}{Event: \textquotesingle connection\textquotesingle{}}}\label{event-connection}

\begin{itemize}
\tightlist
\item
  \texttt{socket} \{stream.Duplex\}
\end{itemize}

This event is emitted when a new TCP stream is established, before the
TLS handshake begins. \texttt{socket} is typically an object of type
\href{net.md\#class-netsocket}{\texttt{net.Socket}} but will not receive
events unlike the socket created from the
\href{net.md\#class-netserver}{\texttt{net.Server}}
\texttt{\textquotesingle{}connection\textquotesingle{}} event. Usually
users will not want to access this event.

This event can also be explicitly emitted by users to inject connections
into the TLS server. In that case, any
\href{stream.md\#class-streamduplex}{\texttt{Duplex}} stream can be
passed.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}keylog\textquotesingle{}}}{Event: \textquotesingle keylog\textquotesingle{}}}\label{event-keylog}

\begin{itemize}
\tightlist
\item
  \texttt{line} \{Buffer\} Line of ASCII text, in NSS
  \texttt{SSLKEYLOGFILE} format.
\item
  \texttt{tlsSocket} \{tls.TLSSocket\} The \texttt{tls.TLSSocket}
  instance on which it was generated.
\end{itemize}

The \texttt{keylog} event is emitted when key material is generated or
received by a connection to this server (typically before handshake has
completed, but not necessarily). This keying material can be stored for
debugging, as it allows captured TLS traffic to be decrypted. It may be
emitted multiple times for each socket.

A typical use case is to append received lines to a common text file,
which is later used by software (such as Wireshark) to decrypt the
traffic:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ logFile }\OperatorTok{=}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}/tmp/ssl{-}keys.log\textquotesingle{}}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{flags}\OperatorTok{:} \StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{ \})}\OperatorTok{;}
\CommentTok{// ...}
\NormalTok{server}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}keylog\textquotesingle{}}\OperatorTok{,}\NormalTok{ (line}\OperatorTok{,}\NormalTok{ tlsSocket) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \ControlFlowTok{if}\NormalTok{ (tlsSocket}\OperatorTok{.}\AttributeTok{remoteAddress} \OperatorTok{!==} \StringTok{\textquotesingle{}...\textquotesingle{}}\NormalTok{)}
    \ControlFlowTok{return}\OperatorTok{;} \CommentTok{// Only log keys for a particular IP}
\NormalTok{  logFile}\OperatorTok{.}\FunctionTok{write}\NormalTok{(line)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}newSession\textquotesingle{}}}{Event: \textquotesingle newSession\textquotesingle{}}}\label{event-newsession}

The \texttt{\textquotesingle{}newSession\textquotesingle{}} event is
emitted upon creation of a new TLS session. This may be used to store
sessions in external storage. The data should be provided to the
\hyperref[event-resumesession]{\texttt{\textquotesingle{}resumeSession\textquotesingle{}}}
callback.

The listener callback is passed three arguments when called:

\begin{itemize}
\tightlist
\item
  \texttt{sessionId} \{Buffer\} The TLS session identifier
\item
  \texttt{sessionData} \{Buffer\} The TLS session data
\item
  \texttt{callback} \{Function\} A callback function taking no arguments
  that must be invoked in order for data to be sent or received over the
  secure connection.
\end{itemize}

Listening for this event will have an effect only on connections
established after the addition of the event listener.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}OCSPRequest\textquotesingle{}}}{Event: \textquotesingle OCSPRequest\textquotesingle{}}}\label{event-ocsprequest}

The \texttt{\textquotesingle{}OCSPRequest\textquotesingle{}} event is
emitted when the client sends a certificate status request. The listener
callback is passed three arguments when called:

\begin{itemize}
\tightlist
\item
  \texttt{certificate} \{Buffer\} The server certificate
\item
  \texttt{issuer} \{Buffer\} The issuer's certificate
\item
  \texttt{callback} \{Function\} A callback function that must be
  invoked to provide the results of the OCSP request.
\end{itemize}

The server's current certificate can be parsed to obtain the OCSP URL
and certificate ID; after obtaining an OCSP response,
\texttt{callback(null,\ resp)} is then invoked, where \texttt{resp} is a
\texttt{Buffer} instance containing the OCSP response. Both
\texttt{certificate} and \texttt{issuer} are \texttt{Buffer}
DER-representations of the primary and issuer's certificates. These can
be used to obtain the OCSP certificate ID and OCSP endpoint URL.

Alternatively, \texttt{callback(null,\ null)} may be called, indicating
that there was no OCSP response.

Calling \texttt{callback(err)} will result in a
\texttt{socket.destroy(err)} call.

The typical flow of an OCSP request is as follows:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Client connects to the server and sends an
  \texttt{\textquotesingle{}OCSPRequest\textquotesingle{}} (via the
  status info extension in ClientHello).
\item
  Server receives the request and emits the
  \texttt{\textquotesingle{}OCSPRequest\textquotesingle{}} event,
  calling the listener if registered.
\item
  Server extracts the OCSP URL from either the \texttt{certificate} or
  \texttt{issuer} and performs an
  \href{https://en.wikipedia.org/wiki/OCSP_stapling}{OCSP request} to
  the CA.
\item
  Server receives
  \texttt{\textquotesingle{}OCSPResponse\textquotesingle{}} from the CA
  and sends it back to the client via the \texttt{callback} argument
\item
  Client validates the response and either destroys the socket or
  performs a handshake.
\end{enumerate}

The \texttt{issuer} can be \texttt{null} if the certificate is either
self-signed or the issuer is not in the root certificates list. (An
issuer may be provided via the \texttt{ca} option when establishing the
TLS connection.)

Listening for this event will have an effect only on connections
established after the addition of the event listener.

An npm module like \href{https://www.npmjs.com/package/asn1.js}{asn1.js}
may be used to parse the certificates.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}resumeSession\textquotesingle{}}}{Event: \textquotesingle resumeSession\textquotesingle{}}}\label{event-resumesession}

The \texttt{\textquotesingle{}resumeSession\textquotesingle{}} event is
emitted when the client requests to resume a previous TLS session. The
listener callback is passed two arguments when called:

\begin{itemize}
\tightlist
\item
  \texttt{sessionId} \{Buffer\} The TLS session identifier
\item
  \texttt{callback} \{Function\} A callback function to be called when
  the prior session has been recovered:
  \texttt{callback({[}err{[},\ sessionData{]}{]})}

  \begin{itemize}
  \tightlist
  \item
    \texttt{err} \{Error\}
  \item
    \texttt{sessionData} \{Buffer\}
  \end{itemize}
\end{itemize}

The event listener should perform a lookup in external storage for the
\texttt{sessionData} saved by the
\hyperref[event-newsession]{\texttt{\textquotesingle{}newSession\textquotesingle{}}}
event handler using the given \texttt{sessionId}. If found, call
\texttt{callback(null,\ sessionData)} to resume the session. If not
found, the session cannot be resumed. \texttt{callback()} must be called
without \texttt{sessionData} so that the handshake can continue and a
new session can be created. It is possible to call
\texttt{callback(err)} to terminate the incoming connection and destroy
the socket.

Listening for this event will have an effect only on connections
established after the addition of the event listener.

The following illustrates resuming a TLS session:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ tlsSessionStore }\OperatorTok{=}\NormalTok{ \{\}}\OperatorTok{;}
\NormalTok{server}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}newSession\textquotesingle{}}\OperatorTok{,}\NormalTok{ (id}\OperatorTok{,}\NormalTok{ data}\OperatorTok{,}\NormalTok{ cb) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
\NormalTok{  tlsSessionStore[id}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{)] }\OperatorTok{=}\NormalTok{ data}\OperatorTok{;}
  \FunctionTok{cb}\NormalTok{()}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\NormalTok{server}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}resumeSession\textquotesingle{}}\OperatorTok{,}\NormalTok{ (id}\OperatorTok{,}\NormalTok{ cb) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \FunctionTok{cb}\NormalTok{(}\KeywordTok{null}\OperatorTok{,}\NormalTok{ tlsSessionStore[id}\OperatorTok{.}\FunctionTok{toString}\NormalTok{(}\StringTok{\textquotesingle{}hex\textquotesingle{}}\NormalTok{)] }\OperatorTok{||} \KeywordTok{null}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}secureConnection\textquotesingle{}}}{Event: \textquotesingle secureConnection\textquotesingle{}}}\label{event-secureconnection}

The \texttt{\textquotesingle{}secureConnection\textquotesingle{}} event
is emitted after the handshaking process for a new connection has
successfully completed. The listener callback is passed a single
argument when called:

\begin{itemize}
\tightlist
\item
  \texttt{tlsSocket} \{tls.TLSSocket\} The established TLS socket.
\end{itemize}

The \texttt{tlsSocket.authorized} property is a \texttt{boolean}
indicating whether the client has been verified by one of the supplied
Certificate Authorities for the server. If \texttt{tlsSocket.authorized}
is \texttt{false}, then \texttt{socket.authorizationError} is set to
describe how authorization failed. Depending on the settings of the TLS
server, unauthorized connections may still be accepted.

The \texttt{tlsSocket.alpnProtocol} property is a string that contains
the selected ALPN protocol. When ALPN has no selected protocol because
the client or the server did not send an ALPN extension,
\texttt{tlsSocket.alpnProtocol} equals \texttt{false}.

The \texttt{tlsSocket.servername} property is a string containing the
server name requested via SNI.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}tlsClientError\textquotesingle{}}}{Event: \textquotesingle tlsClientError\textquotesingle{}}}\label{event-tlsclienterror}

The \texttt{\textquotesingle{}tlsClientError\textquotesingle{}} event is
emitted when an error occurs before a secure connection is established.
The listener callback is passed two arguments when called:

\begin{itemize}
\tightlist
\item
  \texttt{exception} \{Error\} The \texttt{Error} object describing the
  error
\item
  \texttt{tlsSocket} \{tls.TLSSocket\} The \texttt{tls.TLSSocket}
  instance from which the error originated.
\end{itemize}

\subsubsection{\texorpdfstring{\texttt{server.addContext(hostname,\ context)}}{server.addContext(hostname, context)}}\label{server.addcontexthostname-context}

\begin{itemize}
\tightlist
\item
  \texttt{hostname} \{string\} A SNI host name or wildcard
  (e.g.~\texttt{\textquotesingle{}*\textquotesingle{}})
\item
  \texttt{context} \{Object\textbar tls.SecureContext\} An object
  containing any of the possible properties from the
  \hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}
  \texttt{options} arguments (e.g.~\texttt{key}, \texttt{cert},
  \texttt{ca}, etc), or a TLS context object created with
  \hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}
  itself.
\end{itemize}

The \texttt{server.addContext()} method adds a secure context that will
be used if the client request's SNI name matches the supplied
\texttt{hostname} (or wildcard).

When there are multiple matching contexts, the most recently added one
is used.

\subsubsection{\texorpdfstring{\texttt{server.address()}}{server.address()}}\label{server.address}

\begin{itemize}
\tightlist
\item
  Returns: \{Object\}
\end{itemize}

Returns the bound address, the address family name, and port of the
server as reported by the operating system. See
\href{net.md\#serveraddress}{\texttt{net.Server.address()}} for more
information.

\subsubsection{\texorpdfstring{\texttt{server.close({[}callback{]})}}{server.close({[}callback{]})}}\label{server.closecallback}

\begin{itemize}
\tightlist
\item
  \texttt{callback} \{Function\} A listener callback that will be
  registered to listen for the server instance's
  \texttt{\textquotesingle{}close\textquotesingle{}} event.
\item
  Returns: \{tls.Server\}
\end{itemize}

The \texttt{server.close()} method stops the server from accepting new
connections.

This function operates asynchronously. The
\texttt{\textquotesingle{}close\textquotesingle{}} event will be emitted
when the server has no more open connections.

\subsubsection{\texorpdfstring{\texttt{server.getTicketKeys()}}{server.getTicketKeys()}}\label{server.getticketkeys}

\begin{itemize}
\tightlist
\item
  Returns: \{Buffer\} A 48-byte buffer containing the session ticket
  keys.
\end{itemize}

Returns the session ticket keys.

See \hyperref[session-resumption]{Session Resumption} for more
information.

\subsubsection{\texorpdfstring{\texttt{server.listen()}}{server.listen()}}\label{server.listen}

Starts the server listening for encrypted connections. This method is
identical to \href{net.md\#serverlisten}{\texttt{server.listen()}} from
\href{net.md\#class-netserver}{\texttt{net.Server}}.

\subsubsection{\texorpdfstring{\texttt{server.setSecureContext(options)}}{server.setSecureContext(options)}}\label{server.setsecurecontextoptions}

\begin{itemize}
\tightlist
\item
  \texttt{options} \{Object\} An object containing any of the possible
  properties from the
  \hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}
  \texttt{options} arguments (e.g.~\texttt{key}, \texttt{cert},
  \texttt{ca}, etc).
\end{itemize}

The \texttt{server.setSecureContext()} method replaces the secure
context of an existing server. Existing connections to the server are
not interrupted.

\subsubsection{\texorpdfstring{\texttt{server.setTicketKeys(keys)}}{server.setTicketKeys(keys)}}\label{server.setticketkeyskeys}

\begin{itemize}
\tightlist
\item
  \texttt{keys} \{Buffer\textbar TypedArray\textbar DataView\} A 48-byte
  buffer containing the session ticket keys.
\end{itemize}

Sets the session ticket keys.

Changes to the ticket keys are effective only for future server
connections. Existing or currently pending server connections will use
the previous keys.

See \hyperref[session-resumption]{Session Resumption} for more
information.

\subsection{\texorpdfstring{Class:
\texttt{tls.TLSSocket}}{Class: tls.TLSSocket}}\label{class-tls.tlssocket}

\begin{itemize}
\tightlist
\item
  Extends: \{net.Socket\}
\end{itemize}

Performs transparent encryption of written data and all required TLS
negotiation.

Instances of \texttt{tls.TLSSocket} implement the duplex
\href{stream.md\#stream}{Stream} interface.

Methods that return TLS connection metadata (e.g.
\hyperref[tlssocketgetpeercertificatedetailed]{\texttt{tls.TLSSocket.getPeerCertificate()}})
will only return data while the connection is open.

\subsubsection{\texorpdfstring{\texttt{new\ tls.TLSSocket(socket{[},\ options{]})}}{new tls.TLSSocket(socket{[}, options{]})}}\label{new-tls.tlssocketsocket-options}

\begin{itemize}
\tightlist
\item
  \texttt{socket} \{net.Socket\textbar stream.Duplex\} On the server
  side, any \texttt{Duplex} stream. On the client side, any instance of
  \href{net.md\#class-netsocket}{\texttt{net.Socket}} (for generic
  \texttt{Duplex} stream support on the client side,
  \hyperref[tlsconnectoptions-callback]{\texttt{tls.connect()}} must be
  used).
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{enableTrace}: See
    \hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}
  \item
    \texttt{isServer}: The SSL/TLS protocol is asymmetrical, TLSSockets
    must know if they are to behave as a server or a client. If
    \texttt{true} the TLS socket will be instantiated as a server.
    \textbf{Default:} \texttt{false}.
  \item
    \texttt{server} \{net.Server\} A
    \href{net.md\#class-netserver}{\texttt{net.Server}} instance.
  \item
    \texttt{requestCert}: Whether to authenticate the remote peer by
    requesting a certificate. Clients always request a server
    certificate. Servers (\texttt{isServer} is true) may set
    \texttt{requestCert} to true to request a client certificate.
  \item
    \texttt{rejectUnauthorized}: See
    \hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}
  \item
    \texttt{ALPNProtocols}: See
    \hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}
  \item
    \texttt{SNICallback}: See
    \hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}
  \item
    \texttt{session} \{Buffer\} A \texttt{Buffer} instance containing a
    TLS session.
  \item
    \texttt{requestOCSP} \{boolean\} If \texttt{true}, specifies that
    the OCSP status request extension will be added to the client hello
    and an \texttt{\textquotesingle{}OCSPResponse\textquotesingle{}}
    event will be emitted on the socket before establishing a secure
    communication
  \item
    \texttt{secureContext}: TLS context object created with
    \hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}.
    If a \texttt{secureContext} is \emph{not} provided, one will be
    created by passing the entire \texttt{options} object to
    \texttt{tls.createSecureContext()}.
  \item
    \ldots:
    \hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}
    options that are used if the \texttt{secureContext} option is
    missing. Otherwise, they are ignored.
  \end{itemize}
\end{itemize}

Construct a new \texttt{tls.TLSSocket} object from an existing TCP
socket.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}keylog\textquotesingle{}}}{Event: \textquotesingle keylog\textquotesingle{}}}\label{event-keylog-1}

\begin{itemize}
\tightlist
\item
  \texttt{line} \{Buffer\} Line of ASCII text, in NSS
  \texttt{SSLKEYLOGFILE} format.
\end{itemize}

The \texttt{keylog} event is emitted on a \texttt{tls.TLSSocket} when
key material is generated or received by the socket. This keying
material can be stored for debugging, as it allows captured TLS traffic
to be decrypted. It may be emitted multiple times, before or after the
handshake completes.

A typical use case is to append received lines to a common text file,
which is later used by software (such as Wireshark) to decrypt the
traffic:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ logFile }\OperatorTok{=}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{createWriteStream}\NormalTok{(}\StringTok{\textquotesingle{}/tmp/ssl{-}keys.log\textquotesingle{}}\OperatorTok{,}\NormalTok{ \{ }\DataTypeTok{flags}\OperatorTok{:} \StringTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{ \})}\OperatorTok{;}
\CommentTok{// ...}
\NormalTok{tlsSocket}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}keylog\textquotesingle{}}\OperatorTok{,}\NormalTok{ (line) }\KeywordTok{=\textgreater{}}\NormalTok{ logFile}\OperatorTok{.}\FunctionTok{write}\NormalTok{(line))}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}OCSPResponse\textquotesingle{}}}{Event: \textquotesingle OCSPResponse\textquotesingle{}}}\label{event-ocspresponse}

The \texttt{\textquotesingle{}OCSPResponse\textquotesingle{}} event is
emitted if the \texttt{requestOCSP} option was set when the
\texttt{tls.TLSSocket} was created and an OCSP response has been
received. The listener callback is passed a single argument when called:

\begin{itemize}
\tightlist
\item
  \texttt{response} \{Buffer\} The server's OCSP response
\end{itemize}

Typically, the \texttt{response} is a digitally signed object from the
server's CA that contains information about server's certificate
revocation status.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}secureConnect\textquotesingle{}}}{Event: \textquotesingle secureConnect\textquotesingle{}}}\label{event-secureconnect}

The \texttt{\textquotesingle{}secureConnect\textquotesingle{}} event is
emitted after the handshaking process for a new connection has
successfully completed. The listener callback will be called regardless
of whether or not the server's certificate has been authorized. It is
the client's responsibility to check the \texttt{tlsSocket.authorized}
property to determine if the server certificate was signed by one of the
specified CAs. If \texttt{tlsSocket.authorized\ ===\ false}, then the
error can be found by examining the
\texttt{tlsSocket.authorizationError} property. If ALPN was used, the
\texttt{tlsSocket.alpnProtocol} property can be checked to determine the
negotiated protocol.

The \texttt{\textquotesingle{}secureConnect\textquotesingle{}} event is
not emitted when a \{tls.TLSSocket\} is created using the
\texttt{new\ tls.TLSSocket()} constructor.

\subsubsection{\texorpdfstring{Event:
\texttt{\textquotesingle{}session\textquotesingle{}}}{Event: \textquotesingle session\textquotesingle{}}}\label{event-session}

\begin{itemize}
\tightlist
\item
  \texttt{session} \{Buffer\}
\end{itemize}

The \texttt{\textquotesingle{}session\textquotesingle{}} event is
emitted on a client \texttt{tls.TLSSocket} when a new session or TLS
ticket is available. This may or may not be before the handshake is
complete, depending on the TLS protocol version that was negotiated. The
event is not emitted on the server, or if a new session was not created,
for example, when the connection was resumed. For some TLS protocol
versions the event may be emitted multiple times, in which case all the
sessions can be used for resumption.

On the client, the \texttt{session} can be provided to the
\texttt{session} option of
\hyperref[tlsconnectoptions-callback]{\texttt{tls.connect()}} to resume
the connection.

See \hyperref[session-resumption]{Session Resumption} for more
information.

For TLSv1.2 and below,
\hyperref[tlssocketgetsession]{\texttt{tls.TLSSocket.getSession()}} can
be called once the handshake is complete. For TLSv1.3, only ticket-based
resumption is allowed by the protocol, multiple tickets are sent, and
the tickets aren't sent until after the handshake completes. So it is
necessary to wait for the
\texttt{\textquotesingle{}session\textquotesingle{}} event to get a
resumable session. Applications should use the
\texttt{\textquotesingle{}session\textquotesingle{}} event instead of
\texttt{getSession()} to ensure they will work for all TLS versions.
Applications that only expect to get or use one session should listen
for this event only once:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tlsSocket}\OperatorTok{.}\FunctionTok{once}\NormalTok{(}\StringTok{\textquotesingle{}session\textquotesingle{}}\OperatorTok{,}\NormalTok{ (session) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \CommentTok{// The session can be used immediately or later.}
\NormalTok{  tls}\OperatorTok{.}\FunctionTok{connect}\NormalTok{(\{}
    \DataTypeTok{session}\OperatorTok{:}\NormalTok{ session}\OperatorTok{,}
    \CommentTok{// Other connect options...}
\NormalTok{  \})}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{tlsSocket.address()}}{tlsSocket.address()}}\label{tlssocket.address}

\begin{itemize}
\tightlist
\item
  Returns: \{Object\}
\end{itemize}

Returns the bound \texttt{address}, the address \texttt{family} name,
and \texttt{port} of the underlying socket as reported by the operating
system:
\texttt{\{\ port:\ 12346,\ family:\ \textquotesingle{}IPv4\textquotesingle{},\ address:\ \textquotesingle{}127.0.0.1\textquotesingle{}\ \}}.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.authorizationError}}{tlsSocket.authorizationError}}\label{tlssocket.authorizationerror}

Returns the reason why the peer's certificate was not been verified.
This property is set only when
\texttt{tlsSocket.authorized\ ===\ false}.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.authorized}}{tlsSocket.authorized}}\label{tlssocket.authorized}

\begin{itemize}
\tightlist
\item
  \{boolean\}
\end{itemize}

This property is \texttt{true} if the peer certificate was signed by one
of the CAs specified when creating the \texttt{tls.TLSSocket} instance,
otherwise \texttt{false}.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.disableRenegotiation()}}{tlsSocket.disableRenegotiation()}}\label{tlssocket.disablerenegotiation}

Disables TLS renegotiation for this \texttt{TLSSocket} instance. Once
called, attempts to renegotiate will trigger an
\texttt{\textquotesingle{}error\textquotesingle{}} event on the
\texttt{TLSSocket}.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.enableTrace()}}{tlsSocket.enableTrace()}}\label{tlssocket.enabletrace}

When enabled, TLS packet trace information is written to
\texttt{stderr}. This can be used to debug TLS connection problems.

The format of the output is identical to the output of
\texttt{openssl\ s\_client\ -trace} or
\texttt{openssl\ s\_server\ -trace}. While it is produced by OpenSSL's
\texttt{SSL\_trace()} function, the format is undocumented, can change
without notice, and should not be relied on.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.encrypted}}{tlsSocket.encrypted}}\label{tlssocket.encrypted}

Always returns \texttt{true}. This may be used to distinguish TLS
sockets from regular \texttt{net.Socket} instances.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.exportKeyingMaterial(length,\ label{[},\ context{]})}}{tlsSocket.exportKeyingMaterial(length, label{[}, context{]})}}\label{tlssocket.exportkeyingmateriallength-label-context}

\begin{itemize}
\item
  \texttt{length} \{number\} number of bytes to retrieve from keying
  material
\item
  \texttt{label} \{string\} an application specific label, typically
  this will be a value from the
  \href{https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml\#exporter-labels}{IANA
  Exporter Label Registry}.
\item
  \texttt{context} \{Buffer\} Optionally provide a context.
\item
  Returns: \{Buffer\} requested bytes of the keying material
\end{itemize}

Keying material is used for validations to prevent different kind of
attacks in network protocols, for example in the specifications of IEEE
802.1X.

Example

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ keyingMaterial }\OperatorTok{=}\NormalTok{ tlsSocket}\OperatorTok{.}\FunctionTok{exportKeyingMaterial}\NormalTok{(}
  \DecValTok{128}\OperatorTok{,}
  \StringTok{\textquotesingle{}client finished\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\CommentTok{/*}
\CommentTok{ Example return value of keyingMaterial:}
\CommentTok{ \textless{}Buffer 76 26 af 99 c5 56 8e 42 09 91 ef 9f 93 cb ad 6c 7b 65 f8 53 f1 d8 d9}
\CommentTok{    12 5a 33 b8 b5 25 df 7b 37 9f e0 e2 4f b8 67 83 a3 2f cd 5d 41 42 4c 91}
\CommentTok{    74 ef 2c ... 78 more bytes\textgreater{}}
\CommentTok{*/}
\end{Highlighting}
\end{Shaded}

See the OpenSSL
\href{https://www.openssl.org/docs/man1.1.1/man3/SSL_export_keying_material.html}{\texttt{SSL\_export\_keying\_material}}
documentation for more information.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.getCertificate()}}{tlsSocket.getCertificate()}}\label{tlssocket.getcertificate}

\begin{itemize}
\tightlist
\item
  Returns: \{Object\}
\end{itemize}

Returns an object representing the local certificate. The returned
object has some properties corresponding to the fields of the
certificate.

See
\hyperref[tlssocketgetpeercertificatedetailed]{\texttt{tls.TLSSocket.getPeerCertificate()}}
for an example of the certificate structure.

If there is no local certificate, an empty object will be returned. If
the socket has been destroyed, \texttt{null} will be returned.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.getCipher()}}{tlsSocket.getCipher()}}\label{tlssocket.getcipher}

\begin{itemize}
\tightlist
\item
  Returns: \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{name} \{string\} OpenSSL name for the cipher suite.
  \item
    \texttt{standardName} \{string\} IETF name for the cipher suite.
  \item
    \texttt{version} \{string\} The minimum TLS protocol version
    supported by this cipher suite. For the actual negotiated protocol,
    see
    \hyperref[tlssocketgetprotocol]{\texttt{tls.TLSSocket.getProtocol()}}.
  \end{itemize}
\end{itemize}

Returns an object containing information on the negotiated cipher suite.

For example, a TLSv1.2 protocol with AES256-SHA cipher:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{}
    \DataTypeTok{"name"}\FunctionTok{:} \StringTok{"AES256{-}SHA"}\FunctionTok{,}
    \DataTypeTok{"standardName"}\FunctionTok{:} \StringTok{"TLS\_RSA\_WITH\_AES\_256\_CBC\_SHA"}\FunctionTok{,}
    \DataTypeTok{"version"}\FunctionTok{:} \StringTok{"SSLv3"}
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

See
\href{https://www.openssl.org/docs/man1.1.1/man3/SSL_CIPHER_get_name.html}{SSL\_CIPHER\_get\_name}
for more information.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.getEphemeralKeyInfo()}}{tlsSocket.getEphemeralKeyInfo()}}\label{tlssocket.getephemeralkeyinfo}

\begin{itemize}
\tightlist
\item
  Returns: \{Object\}
\end{itemize}

Returns an object representing the type, name, and size of parameter of
an ephemeral key exchange in \hyperref[perfect-forward-secrecy]{perfect
forward secrecy} on a client connection. It returns an empty object when
the key exchange is not ephemeral. As this is only supported on a client
socket; \texttt{null} is returned if called on a server socket. The
supported types are \texttt{\textquotesingle{}DH\textquotesingle{}} and
\texttt{\textquotesingle{}ECDH\textquotesingle{}}. The \texttt{name}
property is available only when type is
\texttt{\textquotesingle{}ECDH\textquotesingle{}}.

For example:
\texttt{\{\ type:\ \textquotesingle{}ECDH\textquotesingle{},\ name:\ \textquotesingle{}prime256v1\textquotesingle{},\ size:\ 256\ \}}.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.getFinished()}}{tlsSocket.getFinished()}}\label{tlssocket.getfinished}

\begin{itemize}
\tightlist
\item
  Returns: \{Buffer\textbar undefined\} The latest \texttt{Finished}
  message that has been sent to the socket as part of a SSL/TLS
  handshake, or \texttt{undefined} if no \texttt{Finished} message has
  been sent yet.
\end{itemize}

As the \texttt{Finished} messages are message digests of the complete
handshake (with a total of 192 bits for TLS 1.0 and more for SSL 3.0),
they can be used for external authentication procedures when the
authentication provided by SSL/TLS is not desired or is not enough.

Corresponds to the \texttt{SSL\_get\_finished} routine in OpenSSL and
may be used to implement the \texttt{tls-unique} channel binding from
\href{https://tools.ietf.org/html/rfc5929}{RFC 5929}.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.getPeerCertificate({[}detailed{]})}}{tlsSocket.getPeerCertificate({[}detailed{]})}}\label{tlssocket.getpeercertificatedetailed}

\begin{itemize}
\tightlist
\item
  \texttt{detailed} \{boolean\} Include the full certificate chain if
  \texttt{true}, otherwise include just the peer's certificate.
\item
  Returns: \{Object\} A certificate object.
\end{itemize}

Returns an object representing the peer's certificate. If the peer does
not provide a certificate, an empty object will be returned. If the
socket has been destroyed, \texttt{null} will be returned.

If the full certificate chain was requested, each certificate will
include an \texttt{issuerCertificate} property containing an object
representing its issuer's certificate.

\paragraph{Certificate object}\label{certificate-object}

A certificate object has properties corresponding to the fields of the
certificate.

\begin{itemize}
\tightlist
\item
  \texttt{ca} \{boolean\} \texttt{true} if a Certificate Authority (CA),
  \texttt{false} otherwise.
\item
  \texttt{raw} \{Buffer\} The DER encoded X.509 certificate data.
\item
  \texttt{subject} \{Object\} The certificate subject, described in
  terms of Country (\texttt{C}), StateOrProvince (\texttt{ST}), Locality
  (\texttt{L}), Organization (\texttt{O}), OrganizationalUnit
  (\texttt{OU}), and CommonName (\texttt{CN}). The CommonName is
  typically a DNS name with TLS certificates. Example:
  \texttt{\{C:\ \textquotesingle{}UK\textquotesingle{},\ ST:\ \textquotesingle{}BC\textquotesingle{},\ L:\ \textquotesingle{}Metro\textquotesingle{},\ O:\ \textquotesingle{}Node\ Fans\textquotesingle{},\ OU:\ \textquotesingle{}Docs\textquotesingle{},\ CN:\ \textquotesingle{}example.com\textquotesingle{}\}}.
\item
  \texttt{issuer} \{Object\} The certificate issuer, described in the
  same terms as the \texttt{subject}.
\item
  \texttt{valid\_from} \{string\} The date-time the certificate is valid
  from.
\item
  \texttt{valid\_to} \{string\} The date-time the certificate is valid
  to.
\item
  \texttt{serialNumber} \{string\} The certificate serial number, as a
  hex string. Example:
  \texttt{\textquotesingle{}B9B0D332A1AA5635\textquotesingle{}}.
\item
  \texttt{fingerprint} \{string\} The SHA-1 digest of the DER encoded
  certificate. It is returned as a \texttt{:} separated hexadecimal
  string. Example:
  \texttt{\textquotesingle{}2A:7A:C2:DD:...\textquotesingle{}}.
\item
  \texttt{fingerprint256} \{string\} The SHA-256 digest of the DER
  encoded certificate. It is returned as a \texttt{:} separated
  hexadecimal string. Example:
  \texttt{\textquotesingle{}2A:7A:C2:DD:...\textquotesingle{}}.
\item
  \texttt{fingerprint512} \{string\} The SHA-512 digest of the DER
  encoded certificate. It is returned as a \texttt{:} separated
  hexadecimal string. Example:
  \texttt{\textquotesingle{}2A:7A:C2:DD:...\textquotesingle{}}.
\item
  \texttt{ext\_key\_usage} \{Array\} (Optional) The extended key usage,
  a set of OIDs.
\item
  \texttt{subjectaltname} \{string\} (Optional) A string containing
  concatenated names for the subject, an alternative to the
  \texttt{subject} names.
\item
  \texttt{infoAccess} \{Array\} (Optional) An array describing the
  AuthorityInfoAccess, used with OCSP.
\item
  \texttt{issuerCertificate} \{Object\} (Optional) The issuer
  certificate object. For self-signed certificates, this may be a
  circular reference.
\end{itemize}

The certificate may contain information about the public key, depending
on the key type.

For RSA keys, the following properties may be defined:

\begin{itemize}
\tightlist
\item
  \texttt{bits} \{number\} The RSA bit size. Example: \texttt{1024}.
\item
  \texttt{exponent} \{string\} The RSA exponent, as a string in
  hexadecimal number notation. Example:
  \texttt{\textquotesingle{}0x010001\textquotesingle{}}.
\item
  \texttt{modulus} \{string\} The RSA modulus, as a hexadecimal string.
  Example: \texttt{\textquotesingle{}B56CE45CB7...\textquotesingle{}}.
\item
  \texttt{pubkey} \{Buffer\} The public key.
\end{itemize}

For EC keys, the following properties may be defined:

\begin{itemize}
\tightlist
\item
  \texttt{pubkey} \{Buffer\} The public key.
\item
  \texttt{bits} \{number\} The key size in bits. Example: \texttt{256}.
\item
  \texttt{asn1Curve} \{string\} (Optional) The ASN.1 name of the OID of
  the elliptic curve. Well-known curves are identified by an OID. While
  it is unusual, it is possible that the curve is identified by its
  mathematical properties, in which case it will not have an OID.
  Example: \texttt{\textquotesingle{}prime256v1\textquotesingle{}}.
\item
  \texttt{nistCurve} \{string\} (Optional) The NIST name for the
  elliptic curve, if it has one (not all well-known curves have been
  assigned names by NIST). Example:
  \texttt{\textquotesingle{}P-256\textquotesingle{}}.
\end{itemize}

Example certificate:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\{ }\DataTypeTok{subject}\OperatorTok{:}
\NormalTok{   \{ }\DataTypeTok{OU}\OperatorTok{:}\NormalTok{ [ }\StringTok{\textquotesingle{}Domain Control Validated\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}PositiveSSL Wildcard\textquotesingle{}}\NormalTok{ ]}\OperatorTok{,}
     \DataTypeTok{CN}\OperatorTok{:} \StringTok{\textquotesingle{}*.nodejs.org\textquotesingle{}}\NormalTok{ \}}\OperatorTok{,}
  \DataTypeTok{issuer}\OperatorTok{:}
\NormalTok{   \{ }\DataTypeTok{C}\OperatorTok{:} \StringTok{\textquotesingle{}GB\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{ST}\OperatorTok{:} \StringTok{\textquotesingle{}Greater Manchester\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{L}\OperatorTok{:} \StringTok{\textquotesingle{}Salford\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{O}\OperatorTok{:} \StringTok{\textquotesingle{}COMODO CA Limited\textquotesingle{}}\OperatorTok{,}
     \DataTypeTok{CN}\OperatorTok{:} \StringTok{\textquotesingle{}COMODO RSA Domain Validation Secure Server CA\textquotesingle{}}\NormalTok{ \}}\OperatorTok{,}
  \DataTypeTok{subjectaltname}\OperatorTok{:} \StringTok{\textquotesingle{}DNS:*.nodejs.org, DNS:nodejs.org\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{infoAccess}\OperatorTok{:}
\NormalTok{   \{ }\StringTok{\textquotesingle{}CA Issuers {-} URI\textquotesingle{}}\OperatorTok{:}
\NormalTok{      [ }\StringTok{\textquotesingle{}http://crt.comodoca.com/COMODORSADomainValidationSecureServerCA.crt\textquotesingle{}}\NormalTok{ ]}\OperatorTok{,}
     \StringTok{\textquotesingle{}OCSP {-} URI\textquotesingle{}}\OperatorTok{:}\NormalTok{ [ }\StringTok{\textquotesingle{}http://ocsp.comodoca.com\textquotesingle{}}\NormalTok{ ] \}}\OperatorTok{,}
  \DataTypeTok{modulus}\OperatorTok{:} \StringTok{\textquotesingle{}B56CE45CB740B09A13F64AC543B712FF9EE8E4C284B542A1708A27E82A8D151CA178153E12E6DDA15BF70FFD96CB8A88618641BDFCCA03527E665B70D779C8A349A6F88FD4EF6557180BD4C98192872BCFE3AF56E863C09DDD8BC1EC58DF9D94F914F0369102B2870BECFA1348A0838C9C49BD1C20124B442477572347047506B1FCD658A80D0C44BCC16BC5C5496CFE6E4A8428EF654CD3D8972BF6E5BFAD59C93006830B5EB1056BBB38B53D1464FA6E02BFDF2FF66CD949486F0775EC43034EC2602AEFBF1703AD221DAA2A88353C3B6A688EFE8387811F645CEED7B3FE46E1F8B9F59FAD028F349B9BC14211D5830994D055EEA3D547911E07A0ADDEB8A82B9188E58720D95CD478EEC9AF1F17BE8141BE80906F1A339445A7EB5B285F68039B0F294598A7D1C0005FC22B5271B0752F58CCDEF8C8FD856FB7AE21C80B8A2CE983AE94046E53EDE4CB89F42502D31B5360771C01C80155918637490550E3F555E2EE75CC8C636DDE3633CFEDD62E91BF0F7688273694EEEBA20C2FC9F14A2A435517BC1D7373922463409AB603295CEB0BB53787A334C9CA3CA8B30005C5A62FC0715083462E00719A8FA3ED0A9828C3871360A73F8B04A4FC1E71302844E9BB9940B77E745C9D91F226D71AFCAD4B113AAF68D92B24DDB4A2136B55A1CD1ADF39605B63CB639038ED0F4C987689866743A68769CC55847E4A06D6E2E3F1\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{exponent}\OperatorTok{:} \StringTok{\textquotesingle{}0x10001\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{pubkey}\OperatorTok{:} \OperatorTok{\textless{}}\BuiltInTok{Buffer} \OperatorTok{...} \OperatorTok{\textgreater{},}
  \DataTypeTok{valid\_from}\OperatorTok{:} \StringTok{\textquotesingle{}Aug 14 00:00:00 2017 GMT\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{valid\_to}\OperatorTok{:} \StringTok{\textquotesingle{}Nov 20 23:59:59 2019 GMT\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{fingerprint}\OperatorTok{:} \StringTok{\textquotesingle{}01:02:59:D9:C3:D2:0D:08:F7:82:4E:44:A4:B4:53:C5:E2:3A:87:4D\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{fingerprint256}\OperatorTok{:} \StringTok{\textquotesingle{}69:AE:1A:6A:D4:3D:C6:C1:1B:EA:C6:23:DE:BA:2A:14:62:62:93:5C:7A:EA:06:41:9B:0B:BC:87:CE:48:4E:02\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{fingerprint512}\OperatorTok{:} \StringTok{\textquotesingle{}19:2B:3E:C3:B3:5B:32:E8:AE:BB:78:97:27:E4:BA:6C:39:C9:92:79:4F:31:46:39:E2:70:E5:5F:89:42:17:C9:E8:64:CA:FF:BB:72:56:73:6E:28:8A:92:7E:A3:2A:15:8B:C2:E0:45:CA:C3:BC:EA:40:52:EC:CA:A2:68:CB:32\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{ext\_key\_usage}\OperatorTok{:}\NormalTok{ [ }\StringTok{\textquotesingle{}1.3.6.1.5.5.7.3.1\textquotesingle{}}\OperatorTok{,} \StringTok{\textquotesingle{}1.3.6.1.5.5.7.3.2\textquotesingle{}}\NormalTok{ ]}\OperatorTok{,}
  \DataTypeTok{serialNumber}\OperatorTok{:} \StringTok{\textquotesingle{}66593D57F20CBC573E433381B5FEC280\textquotesingle{}}\OperatorTok{,}
  \DataTypeTok{raw}\OperatorTok{:} \OperatorTok{\textless{}}\BuiltInTok{Buffer} \OperatorTok{...} \OperatorTok{\textgreater{}}\NormalTok{ \}}
\end{Highlighting}
\end{Shaded}

\subsubsection{\texorpdfstring{\texttt{tlsSocket.getPeerFinished()}}{tlsSocket.getPeerFinished()}}\label{tlssocket.getpeerfinished}

\begin{itemize}
\tightlist
\item
  Returns: \{Buffer\textbar undefined\} The latest \texttt{Finished}
  message that is expected or has actually been received from the socket
  as part of a SSL/TLS handshake, or \texttt{undefined} if there is no
  \texttt{Finished} message so far.
\end{itemize}

As the \texttt{Finished} messages are message digests of the complete
handshake (with a total of 192 bits for TLS 1.0 and more for SSL 3.0),
they can be used for external authentication procedures when the
authentication provided by SSL/TLS is not desired or is not enough.

Corresponds to the \texttt{SSL\_get\_peer\_finished} routine in OpenSSL
and may be used to implement the \texttt{tls-unique} channel binding
from \href{https://tools.ietf.org/html/rfc5929}{RFC 5929}.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.getPeerX509Certificate()}}{tlsSocket.getPeerX509Certificate()}}\label{tlssocket.getpeerx509certificate}

\begin{itemize}
\tightlist
\item
  Returns: \{X509Certificate\}
\end{itemize}

Returns the peer certificate as an \{X509Certificate\} object.

If there is no peer certificate, or the socket has been destroyed,
\texttt{undefined} will be returned.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.getProtocol()}}{tlsSocket.getProtocol()}}\label{tlssocket.getprotocol}

\begin{itemize}
\tightlist
\item
  Returns: \{string\textbar null\}
\end{itemize}

Returns a string containing the negotiated SSL/TLS protocol version of
the current connection. The value
\texttt{\textquotesingle{}unknown\textquotesingle{}} will be returned
for connected sockets that have not completed the handshaking process.
The value \texttt{null} will be returned for server sockets or
disconnected client sockets.

Protocol versions are:

\begin{itemize}
\tightlist
\item
  \texttt{\textquotesingle{}SSLv3\textquotesingle{}}
\item
  \texttt{\textquotesingle{}TLSv1\textquotesingle{}}
\item
  \texttt{\textquotesingle{}TLSv1.1\textquotesingle{}}
\item
  \texttt{\textquotesingle{}TLSv1.2\textquotesingle{}}
\item
  \texttt{\textquotesingle{}TLSv1.3\textquotesingle{}}
\end{itemize}

See the OpenSSL
\href{https://www.openssl.org/docs/man1.1.1/man3/SSL_get_version.html}{\texttt{SSL\_get\_version}}
documentation for more information.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.getSession()}}{tlsSocket.getSession()}}\label{tlssocket.getsession}

\begin{itemize}
\tightlist
\item
  \{Buffer\}
\end{itemize}

Returns the TLS session data or \texttt{undefined} if no session was
negotiated. On the client, the data can be provided to the
\texttt{session} option of
\hyperref[tlsconnectoptions-callback]{\texttt{tls.connect()}} to resume
the connection. On the server, it may be useful for debugging.

See \hyperref[session-resumption]{Session Resumption} for more
information.

Note: \texttt{getSession()} works only for TLSv1.2 and below. For
TLSv1.3, applications must use the
\hyperref[event-session]{\texttt{\textquotesingle{}session\textquotesingle{}}}
event (it also works for TLSv1.2 and below).

\subsubsection{\texorpdfstring{\texttt{tlsSocket.getSharedSigalgs()}}{tlsSocket.getSharedSigalgs()}}\label{tlssocket.getsharedsigalgs}

\begin{itemize}
\tightlist
\item
  Returns: \{Array\} List of signature algorithms shared between the
  server and the client in the order of decreasing preference.
\end{itemize}

See
\href{https://www.openssl.org/docs/man1.1.1/man3/SSL_get_shared_sigalgs.html}{SSL\_get\_shared\_sigalgs}
for more information.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.getTLSTicket()}}{tlsSocket.getTLSTicket()}}\label{tlssocket.gettlsticket}

\begin{itemize}
\tightlist
\item
  \{Buffer\}
\end{itemize}

For a client, returns the TLS session ticket if one is available, or
\texttt{undefined}. For a server, always returns \texttt{undefined}.

It may be useful for debugging.

See \hyperref[session-resumption]{Session Resumption} for more
information.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.getX509Certificate()}}{tlsSocket.getX509Certificate()}}\label{tlssocket.getx509certificate}

\begin{itemize}
\tightlist
\item
  Returns: \{X509Certificate\}
\end{itemize}

Returns the local certificate as an \{X509Certificate\} object.

If there is no local certificate, or the socket has been destroyed,
\texttt{undefined} will be returned.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.isSessionReused()}}{tlsSocket.isSessionReused()}}\label{tlssocket.issessionreused}

\begin{itemize}
\tightlist
\item
  Returns: \{boolean\} \texttt{true} if the session was reused,
  \texttt{false} otherwise.
\end{itemize}

See \hyperref[session-resumption]{Session Resumption} for more
information.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.localAddress}}{tlsSocket.localAddress}}\label{tlssocket.localaddress}

\begin{itemize}
\tightlist
\item
  \{string\}
\end{itemize}

Returns the string representation of the local IP address.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.localPort}}{tlsSocket.localPort}}\label{tlssocket.localport}

\begin{itemize}
\tightlist
\item
  \{integer\}
\end{itemize}

Returns the numeric representation of the local port.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.remoteAddress}}{tlsSocket.remoteAddress}}\label{tlssocket.remoteaddress}

\begin{itemize}
\tightlist
\item
  \{string\}
\end{itemize}

Returns the string representation of the remote IP address. For example,
\texttt{\textquotesingle{}74.125.127.100\textquotesingle{}} or
\texttt{\textquotesingle{}2001:4860:a005::68\textquotesingle{}}.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.remoteFamily}}{tlsSocket.remoteFamily}}\label{tlssocket.remotefamily}

\begin{itemize}
\tightlist
\item
  \{string\}
\end{itemize}

Returns the string representation of the remote IP family.
\texttt{\textquotesingle{}IPv4\textquotesingle{}} or
\texttt{\textquotesingle{}IPv6\textquotesingle{}}.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.remotePort}}{tlsSocket.remotePort}}\label{tlssocket.remoteport}

\begin{itemize}
\tightlist
\item
  \{integer\}
\end{itemize}

Returns the numeric representation of the remote port. For example,
\texttt{443}.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.renegotiate(options,\ callback)}}{tlsSocket.renegotiate(options, callback)}}\label{tlssocket.renegotiateoptions-callback}

\begin{itemize}
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{rejectUnauthorized} \{boolean\} If not \texttt{false}, the
    server certificate is verified against the list of supplied CAs. An
    \texttt{\textquotesingle{}error\textquotesingle{}} event is emitted
    if verification fails; \texttt{err.code} contains the OpenSSL error
    code. \textbf{Default:} \texttt{true}.
  \item
    \texttt{requestCert}
  \end{itemize}
\item
  \texttt{callback} \{Function\} If \texttt{renegotiate()} returned
  \texttt{true}, callback is attached once to the
  \texttt{\textquotesingle{}secure\textquotesingle{}} event. If
  \texttt{renegotiate()} returned \texttt{false}, \texttt{callback} will
  be called in the next tick with an error, unless the
  \texttt{tlsSocket} has been destroyed, in which case \texttt{callback}
  will not be called at all.
\item
  Returns: \{boolean\} \texttt{true} if renegotiation was initiated,
  \texttt{false} otherwise.
\end{itemize}

The \texttt{tlsSocket.renegotiate()} method initiates a TLS
renegotiation process. Upon completion, the \texttt{callback} function
will be passed a single argument that is either an \texttt{Error} (if
the request failed) or \texttt{null}.

This method can be used to request a peer's certificate after the secure
connection has been established.

When running as the server, the socket will be destroyed with an error
after \texttt{handshakeTimeout} timeout.

For TLSv1.3, renegotiation cannot be initiated, it is not supported by
the protocol.

\subsubsection{\texorpdfstring{\texttt{tlsSocket.setMaxSendFragment(size)}}{tlsSocket.setMaxSendFragment(size)}}\label{tlssocket.setmaxsendfragmentsize}

\begin{itemize}
\tightlist
\item
  \texttt{size} \{number\} The maximum TLS fragment size. The maximum
  value is \texttt{16384}. \textbf{Default:} \texttt{16384}.
\item
  Returns: \{boolean\}
\end{itemize}

The \texttt{tlsSocket.setMaxSendFragment()} method sets the maximum TLS
fragment size. Returns \texttt{true} if setting the limit succeeded;
\texttt{false} otherwise.

Smaller fragment sizes decrease the buffering latency on the client:
larger fragments are buffered by the TLS layer until the entire fragment
is received and its integrity is verified; large fragments can span
multiple roundtrips and their processing can be delayed due to packet
loss or reordering. However, smaller fragments add extra TLS framing
bytes and CPU overhead, which may decrease overall server throughput.

\subsection{\texorpdfstring{\texttt{tls.checkServerIdentity(hostname,\ cert)}}{tls.checkServerIdentity(hostname, cert)}}\label{tls.checkserveridentityhostname-cert}

\begin{itemize}
\tightlist
\item
  \texttt{hostname} \{string\} The host name or IP address to verify the
  certificate against.
\item
  \texttt{cert} \{Object\} A \hyperref[certificate-object]{certificate
  object} representing the peer's certificate.
\item
  Returns: \{Error\textbar undefined\}
\end{itemize}

Verifies the certificate \texttt{cert} is issued to \texttt{hostname}.

Returns \{Error\} object, populating it with \texttt{reason},
\texttt{host}, and \texttt{cert} on failure. On success, returns
\{undefined\}.

This function is intended to be used in combination with the
\texttt{checkServerIdentity} option that can be passed to
\hyperref[tlsconnectoptions-callback]{\texttt{tls.connect()}} and as
such operates on a \hyperref[certificate-object]{certificate object}.
For other purposes, consider using
\href{crypto.md\#x509checkhostname-options}{\texttt{x509.checkHost()}}
instead.

This function can be overwritten by providing an alternative function as
the \texttt{options.checkServerIdentity} option that is passed to
\texttt{tls.connect()}. The overwriting function can call
\texttt{tls.checkServerIdentity()} of course, to augment the checks done
with additional verification.

This function is only called if the certificate passed all other checks,
such as being issued by trusted CA (\texttt{options.ca}).

Earlier versions of Node.js incorrectly accepted certificates for a
given \texttt{hostname} if a matching \texttt{uniformResourceIdentifier}
subject alternative name was present (see
\href{https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44531}{CVE-2021-44531}).
Applications that wish to accept \texttt{uniformResourceIdentifier}
subject alternative names can use a custom
\texttt{options.checkServerIdentity} function that implements the
desired behavior.

\subsection{\texorpdfstring{\texttt{tls.connect(options{[},\ callback{]})}}{tls.connect(options{[}, callback{]})}}\label{tls.connectoptions-callback}

\begin{itemize}
\tightlist
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \item
    \texttt{enableTrace}: See
    \hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}
  \item
    \texttt{host} \{string\} Host the client should connect to.
    \textbf{Default:}
    \texttt{\textquotesingle{}localhost\textquotesingle{}}.
  \item
    \texttt{port} \{number\} Port the client should connect to.
  \item
    \texttt{path} \{string\} Creates Unix socket connection to path. If
    this option is specified, \texttt{host} and \texttt{port} are
    ignored.
  \item
    \texttt{socket} \{stream.Duplex\} Establish secure connection on a
    given socket rather than creating a new socket. Typically, this is
    an instance of \href{net.md\#class-netsocket}{\texttt{net.Socket}},
    but any \texttt{Duplex} stream is allowed. If this option is
    specified, \texttt{path}, \texttt{host}, and \texttt{port} are
    ignored, except for certificate validation. Usually, a socket is
    already connected when passed to \texttt{tls.connect()}, but it can
    be connected later. Connection/disconnection/destruction of
    \texttt{socket} is the user's responsibility; calling
    \texttt{tls.connect()} will not cause \texttt{net.connect()} to be
    called.
  \item
    \texttt{allowHalfOpen} \{boolean\} If set to \texttt{false}, then
    the socket will automatically end the writable side when the
    readable side ends. If the \texttt{socket} option is set, this
    option has no effect. See the \texttt{allowHalfOpen} option of
    \href{net.md\#class-netsocket}{\texttt{net.Socket}} for details.
    \textbf{Default:} \texttt{false}.
  \item
    \texttt{rejectUnauthorized} \{boolean\} If not \texttt{false}, the
    server certificate is verified against the list of supplied CAs. An
    \texttt{\textquotesingle{}error\textquotesingle{}} event is emitted
    if verification fails; \texttt{err.code} contains the OpenSSL error
    code. \textbf{Default:} \texttt{true}.
  \item
    \texttt{pskCallback} \{Function\}

    \begin{itemize}
    \tightlist
    \item
      hint: \{string\} optional message sent from the server to help
      client decide which identity to use during negotiation. Always
      \texttt{null} if TLS 1.3 is used.
    \item
      Returns: \{Object\} in the form
      \texttt{\{\ psk:\ \textless{}Buffer\textbar{}TypedArray\textbar{}DataView\textgreater{},\ identity:\ \textless{}string\textgreater{}\ \}}
      or \texttt{null} to stop the negotiation process. \texttt{psk}
      must be compatible with the selected cipher's digest.
      \texttt{identity} must use UTF-8 encoding.
    \end{itemize}

    When negotiating TLS-PSK (pre-shared keys), this function is called
    with optional identity \texttt{hint} provided by the server or
    \texttt{null} in case of TLS 1.3 where \texttt{hint} was removed. It
    will be necessary to provide a custom
    \texttt{tls.checkServerIdentity()} for the connection as the default
    one will try to check host name/IP of the server against the
    certificate but that's not applicable for PSK because there won't be
    a certificate present. More information can be found in the
    \href{https://tools.ietf.org/html/rfc4279}{RFC 4279}.
  \item
    \texttt{ALPNProtocols}:
    \{string{[}{]}\textbar Buffer{[}{]}\textbar TypedArray{[}{]}\textbar DataView{[}{]}\textbar Buffer\textbar{}
    TypedArray\textbar DataView\} An array of strings, \texttt{Buffer}s,
    \texttt{TypedArray}s, or \texttt{DataView}s, or a single
    \texttt{Buffer}, \texttt{TypedArray}, or \texttt{DataView}
    containing the supported ALPN protocols. \texttt{Buffer}s should
    have the format \texttt{{[}len{]}{[}name{]}{[}len{]}{[}name{]}...}
    e.g.~\texttt{\textquotesingle{}\textbackslash{}x08http/1.1\textbackslash{}x08http/1.0\textquotesingle{}},
    where the \texttt{len} byte is the length of the next protocol name.
    Passing an array is usually much simpler, e.g.
    \texttt{{[}\textquotesingle{}http/1.1\textquotesingle{},\ \textquotesingle{}http/1.0\textquotesingle{}{]}}.
    Protocols earlier in the list have higher preference than those
    later.
  \item
    \texttt{servername}: \{string\} Server name for the SNI (Server Name
    Indication) TLS extension. It is the name of the host being
    connected to, and must be a host name, and not an IP address. It can
    be used by a multi-homed server to choose the correct certificate to
    present to the client, see the \texttt{SNICallback} option to
    \hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}.
  \item
    \texttt{checkServerIdentity(servername,\ cert)} \{Function\} A
    callback function to be used (instead of the builtin
    \texttt{tls.checkServerIdentity()} function) when checking the
    server's host name (or the provided \texttt{servername} when
    explicitly set) against the certificate. This should return an
    \{Error\} if verification fails. The method should return
    \texttt{undefined} if the \texttt{servername} and \texttt{cert} are
    verified.
  \item
    \texttt{session} \{Buffer\} A \texttt{Buffer} instance, containing
    TLS session.
  \item
    \texttt{minDHSize} \{number\} Minimum size of the DH parameter in
    bits to accept a TLS connection. When a server offers a DH parameter
    with a size less than \texttt{minDHSize}, the TLS connection is
    destroyed and an error is thrown. \textbf{Default:} \texttt{1024}.
  \item
    \texttt{highWaterMark}: \{number\} Consistent with the readable
    stream \texttt{highWaterMark} parameter. \textbf{Default:}
    \texttt{16\ *\ 1024}.
  \item
    \texttt{secureContext}: TLS context object created with
    \hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}.
    If a \texttt{secureContext} is \emph{not} provided, one will be
    created by passing the entire \texttt{options} object to
    \texttt{tls.createSecureContext()}.
  \item
    \texttt{onread} \{Object\} If the \texttt{socket} option is missing,
    incoming data is stored in a single \texttt{buffer} and passed to
    the supplied \texttt{callback} when data arrives on the socket,
    otherwise the option is ignored. See the \texttt{onread} option of
    \href{net.md\#class-netsocket}{\texttt{net.Socket}} for details.
  \item
    \ldots:
    \hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}
    options that are used if the \texttt{secureContext} option is
    missing, otherwise they are ignored.
  \item
    \ldots: Any
    \href{net.md\#socketconnectoptions-connectlistener}{\texttt{socket.connect()}}
    option not already listed.
  \end{itemize}
\item
  \texttt{callback} \{Function\}
\item
  Returns: \{tls.TLSSocket\}
\end{itemize}

The \texttt{callback} function, if specified, will be added as a
listener for the
\hyperref[event-secureconnect]{\texttt{\textquotesingle{}secureConnect\textquotesingle{}}}
event.

\texttt{tls.connect()} returns a
\hyperref[class-tlstlssocket]{\texttt{tls.TLSSocket}} object.

Unlike the \texttt{https} API, \texttt{tls.connect()} does not enable
the SNI (Server Name Indication) extension by default, which may cause
some servers to return an incorrect certificate or reject the connection
altogether. To enable SNI, set the \texttt{servername} option in
addition to \texttt{host}.

The following illustrates a client for the echo server example from
\hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// Assumes an echo server that is listening on port 8000.}
\KeywordTok{const}\NormalTok{ tls }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:tls\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ options }\OperatorTok{=}\NormalTok{ \{}
  \CommentTok{// Necessary only if the server requires client certificate authentication.}
  \DataTypeTok{key}\OperatorTok{:}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{readFileSync}\NormalTok{(}\StringTok{\textquotesingle{}client{-}key.pem\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
  \DataTypeTok{cert}\OperatorTok{:}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{readFileSync}\NormalTok{(}\StringTok{\textquotesingle{}client{-}cert.pem\textquotesingle{}}\NormalTok{)}\OperatorTok{,}

  \CommentTok{// Necessary only if the server uses a self{-}signed certificate.}
  \DataTypeTok{ca}\OperatorTok{:}\NormalTok{ [ fs}\OperatorTok{.}\FunctionTok{readFileSync}\NormalTok{(}\StringTok{\textquotesingle{}server{-}cert.pem\textquotesingle{}}\NormalTok{) ]}\OperatorTok{,}

  \CommentTok{// Necessary only if the server\textquotesingle{}s cert isn\textquotesingle{}t for "localhost".}
  \DataTypeTok{checkServerIdentity}\OperatorTok{:}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{ }\ControlFlowTok{return} \KeywordTok{null}\OperatorTok{;}\NormalTok{ \}}\OperatorTok{,}
\NormalTok{\}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ socket }\OperatorTok{=}\NormalTok{ tls}\OperatorTok{.}\FunctionTok{connect}\NormalTok{(}\DecValTok{8000}\OperatorTok{,}\NormalTok{ options}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}client connected\textquotesingle{}}\OperatorTok{,}
\NormalTok{              socket}\OperatorTok{.}\AttributeTok{authorized} \OperatorTok{?} \StringTok{\textquotesingle{}authorized\textquotesingle{}} \OperatorTok{:} \StringTok{\textquotesingle{}unauthorized\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
  \BuiltInTok{process}\OperatorTok{.}\AttributeTok{stdin}\OperatorTok{.}\FunctionTok{pipe}\NormalTok{(socket)}\OperatorTok{;}
  \BuiltInTok{process}\OperatorTok{.}\AttributeTok{stdin}\OperatorTok{.}\FunctionTok{resume}\NormalTok{()}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\NormalTok{socket}\OperatorTok{.}\FunctionTok{setEncoding}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{socket}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}data\textquotesingle{}}\OperatorTok{,}\NormalTok{ (data) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(data)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\NormalTok{socket}\OperatorTok{.}\FunctionTok{on}\NormalTok{(}\StringTok{\textquotesingle{}end\textquotesingle{}}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}server ends connection\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{tls.connect(path{[},\ options{]}{[},\ callback{]})}}{tls.connect(path{[}, options{]}{[}, callback{]})}}\label{tls.connectpath-options-callback}

\begin{itemize}
\tightlist
\item
  \texttt{path} \{string\} Default value for \texttt{options.path}.
\item
  \texttt{options} \{Object\} See
  \hyperref[tlsconnectoptions-callback]{\texttt{tls.connect()}}.
\item
  \texttt{callback} \{Function\} See
  \hyperref[tlsconnectoptions-callback]{\texttt{tls.connect()}}.
\item
  Returns: \{tls.TLSSocket\}
\end{itemize}

Same as \hyperref[tlsconnectoptions-callback]{\texttt{tls.connect()}}
except that \texttt{path} can be provided as an argument instead of an
option.

A path option, if specified, will take precedence over the path
argument.

\subsection{\texorpdfstring{\texttt{tls.connect(port{[},\ host{]}{[},\ options{]}{[},\ callback{]})}}{tls.connect(port{[}, host{]}{[}, options{]}{[}, callback{]})}}\label{tls.connectport-host-options-callback}

\begin{itemize}
\tightlist
\item
  \texttt{port} \{number\} Default value for \texttt{options.port}.
\item
  \texttt{host} \{string\} Default value for \texttt{options.host}.
\item
  \texttt{options} \{Object\} See
  \hyperref[tlsconnectoptions-callback]{\texttt{tls.connect()}}.
\item
  \texttt{callback} \{Function\} See
  \hyperref[tlsconnectoptions-callback]{\texttt{tls.connect()}}.
\item
  Returns: \{tls.TLSSocket\}
\end{itemize}

Same as \hyperref[tlsconnectoptions-callback]{\texttt{tls.connect()}}
except that \texttt{port} and \texttt{host} can be provided as arguments
instead of options.

A port or host option, if specified, will take precedence over any port
or host argument.

\subsection{\texorpdfstring{\texttt{tls.createSecureContext({[}options{]})}}{tls.createSecureContext({[}options{]})}}\label{tls.createsecurecontextoptions}

\begin{itemize}
\tightlist
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \tightlist
  \item
    \texttt{ca}
    \{string\textbar string{[}{]}\textbar Buffer\textbar Buffer{[}{]}\}
    Optionally override the trusted CA certificates. Default is to trust
    the well-known CAs curated by Mozilla. Mozilla's CAs are completely
    replaced when CAs are explicitly specified using this option. The
    value can be a string or \texttt{Buffer}, or an \texttt{Array} of
    strings and/or \texttt{Buffer}s. Any string or \texttt{Buffer} can
    contain multiple PEM CAs concatenated together. The peer's
    certificate must be chainable to a CA trusted by the server for the
    connection to be authenticated. When using certificates that are not
    chainable to a well-known CA, the certificate's CA must be
    explicitly specified as a trusted or the connection will fail to
    authenticate. If the peer uses a certificate that doesn't match or
    chain to one of the default CAs, use the \texttt{ca} option to
    provide a CA certificate that the peer's certificate can match or
    chain to. For self-signed certificates, the certificate is its own
    CA, and must be provided. For PEM encoded certificates, supported
    types are ``TRUSTED CERTIFICATE'', ``X509 CERTIFICATE'', and
    ``CERTIFICATE''. See also
    \hyperref[tlsrootcertificates]{\texttt{tls.rootCertificates}}.
  \item
    \texttt{cert}
    \{string\textbar string{[}{]}\textbar Buffer\textbar Buffer{[}{]}\}
    Cert chains in PEM format. One cert chain should be provided per
    private key. Each cert chain should consist of the PEM formatted
    certificate for a provided private \texttt{key}, followed by the PEM
    formatted intermediate certificates (if any), in order, and not
    including the root CA (the root CA must be pre-known to the peer,
    see \texttt{ca}). When providing multiple cert chains, they do not
    have to be in the same order as their private keys in \texttt{key}.
    If the intermediate certificates are not provided, the peer will not
    be able to validate the certificate, and the handshake will fail.
  \item
    \texttt{sigalgs} \{string\} Colon-separated list of supported
    signature algorithms. The list can contain digest algorithms
    (\texttt{SHA256}, \texttt{MD5} etc.), public key algorithms
    (\texttt{RSA-PSS}, \texttt{ECDSA} etc.), combination of both (e.g
    `RSA+SHA384') or TLS v1.3 scheme names
    (e.g.~\texttt{rsa\_pss\_pss\_sha512}). See
    \href{https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set1_sigalgs_list.html}{OpenSSL
    man pages} for more info.
  \item
    \texttt{ciphers} \{string\} Cipher suite specification, replacing
    the default. For more information, see
    \hyperref[modifying-the-default-tls-cipher-suite]{Modifying the
    default TLS cipher suite}. Permitted ciphers can be obtained via
    \hyperref[tlsgetciphers]{\texttt{tls.getCiphers()}}. Cipher names
    must be uppercased in order for OpenSSL to accept them.
  \item
    \texttt{clientCertEngine} \{string\} Name of an OpenSSL engine which
    can provide the client certificate.
  \item
    \texttt{crl}
    \{string\textbar string{[}{]}\textbar Buffer\textbar Buffer{[}{]}\}
    PEM formatted CRLs (Certificate Revocation Lists).
  \item
    \texttt{dhparam} \{string\textbar Buffer\}
    \texttt{\textquotesingle{}auto\textquotesingle{}} or custom
    Diffie-Hellman parameters, required for non-ECDHE
    \hyperref[perfect-forward-secrecy]{perfect forward secrecy}. If
    omitted or invalid, the parameters are silently discarded and DHE
    ciphers will not be available.
    \href{https://en.wikipedia.org/wiki/Elliptic_curve_Diffie\%E2\%80\%93Hellman}{ECDHE}-based
    \hyperref[perfect-forward-secrecy]{perfect forward secrecy} will
    still be available.
  \item
    \texttt{ecdhCurve} \{string\} A string describing a named curve or a
    colon separated list of curve NIDs or names, for example
    \texttt{P-521:P-384:P-256}, to use for ECDH key agreement. Set to
    \texttt{auto} to select the curve automatically. Use
    \href{crypto.md\#cryptogetcurves}{\texttt{crypto.getCurves()}} to
    obtain a list of available curve names. On recent releases,
    \texttt{openssl\ ecparam\ -list\_curves} will also display the name
    and description of each available elliptic curve. \textbf{Default:}
    \hyperref[tlsdefault_ecdh_curve]{\texttt{tls.DEFAULT\_ECDH\_CURVE}}.
  \item
    \texttt{honorCipherOrder} \{boolean\} Attempt to use the server's
    cipher suite preferences instead of the client's. When
    \texttt{true}, causes \texttt{SSL\_OP\_CIPHER\_SERVER\_PREFERENCE}
    to be set in \texttt{secureOptions}, see
    \href{crypto.md\#openssl-options}{OpenSSL Options} for more
    information.
  \item
    \texttt{key}
    \{string\textbar string{[}{]}\textbar Buffer\textbar Buffer{[}{]}\textbar Object{[}{]}\}
    Private keys in PEM format. PEM allows the option of private keys
    being encrypted. Encrypted keys will be decrypted with
    \texttt{options.passphrase}. Multiple keys using different
    algorithms can be provided either as an array of unencrypted key
    strings or buffers, or an array of objects in the form
    \texttt{\{pem:\ \textless{}string\textbar{}buffer\textgreater{}{[},\ passphrase:\ \textless{}string\textgreater{}{]}\}}.
    The object form can only occur in an array.
    \texttt{object.passphrase} is optional. Encrypted keys will be
    decrypted with \texttt{object.passphrase} if provided, or
    \texttt{options.passphrase} if it is not.
  \item
    \texttt{privateKeyEngine} \{string\} Name of an OpenSSL engine to
    get private key from. Should be used together with
    \texttt{privateKeyIdentifier}.
  \item
    \texttt{privateKeyIdentifier} \{string\} Identifier of a private key
    managed by an OpenSSL engine. Should be used together with
    \texttt{privateKeyEngine}. Should not be set together with
    \texttt{key}, because both options define a private key in different
    ways.
  \item
    \texttt{maxVersion} \{string\} Optionally set the maximum TLS
    version to allow. One of
    \texttt{\textquotesingle{}TLSv1.3\textquotesingle{}},
    \texttt{\textquotesingle{}TLSv1.2\textquotesingle{}},
    \texttt{\textquotesingle{}TLSv1.1\textquotesingle{}}, or
    \texttt{\textquotesingle{}TLSv1\textquotesingle{}}. Cannot be
    specified along with the \texttt{secureProtocol} option; use one or
    the other. \textbf{Default:}
    \hyperref[tlsdefault_max_version]{\texttt{tls.DEFAULT\_MAX\_VERSION}}.
  \item
    \texttt{minVersion} \{string\} Optionally set the minimum TLS
    version to allow. One of
    \texttt{\textquotesingle{}TLSv1.3\textquotesingle{}},
    \texttt{\textquotesingle{}TLSv1.2\textquotesingle{}},
    \texttt{\textquotesingle{}TLSv1.1\textquotesingle{}}, or
    \texttt{\textquotesingle{}TLSv1\textquotesingle{}}. Cannot be
    specified along with the \texttt{secureProtocol} option; use one or
    the other. Avoid setting to less than TLSv1.2, but it may be
    required for interoperability. \textbf{Default:}
    \hyperref[tlsdefault_min_version]{\texttt{tls.DEFAULT\_MIN\_VERSION}}.
  \item
    \texttt{passphrase} \{string\} Shared passphrase used for a single
    private key and/or a PFX.
  \item
    \texttt{pfx}
    \{string\textbar string{[}{]}\textbar Buffer\textbar Buffer{[}{]}\textbar Object{[}{]}\}
    PFX or PKCS12 encoded private key and certificate chain.
    \texttt{pfx} is an alternative to providing \texttt{key} and
    \texttt{cert} individually. PFX is usually encrypted, if it is,
    \texttt{passphrase} will be used to decrypt it. Multiple PFX can be
    provided either as an array of unencrypted PFX buffers, or an array
    of objects in the form
    \texttt{\{buf:\ \textless{}string\textbar{}buffer\textgreater{}{[},\ passphrase:\ \textless{}string\textgreater{}{]}\}}.
    The object form can only occur in an array.
    \texttt{object.passphrase} is optional. Encrypted PFX will be
    decrypted with \texttt{object.passphrase} if provided, or
    \texttt{options.passphrase} if it is not.
  \item
    \texttt{secureOptions} \{number\} Optionally affect the OpenSSL
    protocol behavior, which is not usually necessary. This should be
    used carefully if at all! Value is a numeric bitmask of the
    \texttt{SSL\_OP\_*} options from
    \href{crypto.md\#openssl-options}{OpenSSL Options}.
  \item
    \texttt{secureProtocol} \{string\} Legacy mechanism to select the
    TLS protocol version to use, it does not support independent control
    of the minimum and maximum version, and does not support limiting
    the protocol to TLSv1.3. Use \texttt{minVersion} and
    \texttt{maxVersion} instead. The possible values are listed as
    \href{https://www.openssl.org/docs/man1.1.1/man7/ssl.html\#Dealing-with-Protocol-Methods}{SSL\_METHODS},
    use the function names as strings. For example, use
    \texttt{\textquotesingle{}TLSv1\_1\_method\textquotesingle{}} to
    force TLS version 1.1, or
    \texttt{\textquotesingle{}TLS\_method\textquotesingle{}} to allow
    any TLS protocol version up to TLSv1.3. It is not recommended to use
    TLS versions less than 1.2, but it may be required for
    interoperability. \textbf{Default:} none, see \texttt{minVersion}.
  \item
    \texttt{sessionIdContext} \{string\} Opaque identifier used by
    servers to ensure session state is not shared between applications.
    Unused by clients.
  \item
    \texttt{ticketKeys}: \{Buffer\} 48-bytes of cryptographically strong
    pseudorandom data. See \hyperref[session-resumption]{Session
    Resumption} for more information.
  \item
    \texttt{sessionTimeout} \{number\} The number of seconds after which
    a TLS session created by the server will no longer be resumable. See
    \hyperref[session-resumption]{Session Resumption} for more
    information. \textbf{Default:} \texttt{300}.
  \end{itemize}
\end{itemize}

\hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}
sets the default value of the \texttt{honorCipherOrder} option to
\texttt{true}, other APIs that create secure contexts leave it unset.

\hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}
uses a 128 bit truncated SHA1 hash value generated from
\texttt{process.argv} as the default value of the
\texttt{sessionIdContext} option, other APIs that create secure contexts
have no default value.

The \texttt{tls.createSecureContext()} method creates a
\texttt{SecureContext} object. It is usable as an argument to several
\texttt{tls} APIs, such as
\hyperref[serveraddcontexthostname-context]{\texttt{server.addContext()}},
but has no public methods. The
\hyperref[class-tlsserver]{\texttt{tls.Server}} constructor and the
\hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}
method do not support the \texttt{secureContext} option.

A key is \emph{required} for ciphers that use certificates. Either
\texttt{key} or \texttt{pfx} can be used to provide it.

If the \texttt{ca} option is not given, then Node.js will default to
using
\href{https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt}{Mozilla's
publicly trusted list of CAs}.

Custom DHE parameters are discouraged in favor of the new
\texttt{dhparam:\ \textquotesingle{}auto\textquotesingle{}} option. When
set to \texttt{\textquotesingle{}auto\textquotesingle{}}, well-known DHE
parameters of sufficient strength will be selected automatically.
Otherwise, if necessary, \texttt{openssl\ dhparam} can be used to create
custom parameters. The key length must be greater than or equal to 1024
bits or else an error will be thrown. Although 1024 bits is permissible,
use 2048 bits or larger for stronger security.

\subsection{\texorpdfstring{\texttt{tls.createSecurePair({[}context{]}{[},\ isServer{]}{[},\ requestCert{]}{[},\ rejectUnauthorized{]}{[},\ options{]})}}{tls.createSecurePair({[}context{]}{[}, isServer{]}{[}, requestCert{]}{[}, rejectUnauthorized{]}{[}, options{]})}}\label{tls.createsecurepaircontext-isserver-requestcert-rejectunauthorized-options}

\begin{quote}
Stability: 0 - Deprecated: Use
\hyperref[class-tlstlssocket]{\texttt{tls.TLSSocket}} instead.
\end{quote}

\begin{itemize}
\tightlist
\item
  \texttt{context} \{Object\} A secure context object as returned by
  \texttt{tls.createSecureContext()}
\item
  \texttt{isServer} \{boolean\} \texttt{true} to specify that this TLS
  connection should be opened as a server.
\item
  \texttt{requestCert} \{boolean\} \texttt{true} to specify whether a
  server should request a certificate from a connecting client. Only
  applies when \texttt{isServer} is \texttt{true}.
\item
  \texttt{rejectUnauthorized} \{boolean\} If not \texttt{false} a server
  automatically reject clients with invalid certificates. Only applies
  when \texttt{isServer} is \texttt{true}.
\item
  \texttt{options}

  \begin{itemize}
  \tightlist
  \item
    \texttt{enableTrace}: See
    \hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}
  \item
    \texttt{secureContext}: A TLS context object from
    \hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}
  \item
    \texttt{isServer}: If \texttt{true} the TLS socket will be
    instantiated in server-mode. \textbf{Default:} \texttt{false}.
  \item
    \texttt{server} \{net.Server\} A
    \href{net.md\#class-netserver}{\texttt{net.Server}} instance
  \item
    \texttt{requestCert}: See
    \hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}
  \item
    \texttt{rejectUnauthorized}: See
    \hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}
  \item
    \texttt{ALPNProtocols}: See
    \hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}
  \item
    \texttt{SNICallback}: See
    \hyperref[tlscreateserveroptions-secureconnectionlistener]{\texttt{tls.createServer()}}
  \item
    \texttt{session} \{Buffer\} A \texttt{Buffer} instance containing a
    TLS session.
  \item
    \texttt{requestOCSP} \{boolean\} If \texttt{true}, specifies that
    the OCSP status request extension will be added to the client hello
    and an \texttt{\textquotesingle{}OCSPResponse\textquotesingle{}}
    event will be emitted on the socket before establishing a secure
    communication.
  \end{itemize}
\end{itemize}

Creates a new secure pair object with two streams, one of which reads
and writes the encrypted data and the other of which reads and writes
the cleartext data. Generally, the encrypted stream is piped to/from an
incoming encrypted data stream and the cleartext one is used as a
replacement for the initial encrypted stream.

\texttt{tls.createSecurePair()} returns a \texttt{tls.SecurePair} object
with \texttt{cleartext} and \texttt{encrypted} stream properties.

Using \texttt{cleartext} has the same API as
\hyperref[class-tlstlssocket]{\texttt{tls.TLSSocket}}.

The \texttt{tls.createSecurePair()} method is now deprecated in favor of
\texttt{tls.TLSSocket()}. For example, the code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pair }\OperatorTok{=}\NormalTok{ tls}\OperatorTok{.}\FunctionTok{createSecurePair}\NormalTok{(}\CommentTok{/* ... */}\NormalTok{)}\OperatorTok{;}
\NormalTok{pair}\OperatorTok{.}\AttributeTok{encrypted}\OperatorTok{.}\FunctionTok{pipe}\NormalTok{(socket)}\OperatorTok{;}
\NormalTok{socket}\OperatorTok{.}\FunctionTok{pipe}\NormalTok{(pair}\OperatorTok{.}\AttributeTok{encrypted}\NormalTok{)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

can be replaced by:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{secureSocket }\OperatorTok{=}\NormalTok{ tls}\OperatorTok{.}\FunctionTok{TLSSocket}\NormalTok{(socket}\OperatorTok{,}\NormalTok{ options)}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

where \texttt{secureSocket} has the same API as \texttt{pair.cleartext}.

\subsection{\texorpdfstring{\texttt{tls.createServer({[}options{]}{[},\ secureConnectionListener{]})}}{tls.createServer({[}options{]}{[}, secureConnectionListener{]})}}\label{tls.createserveroptions-secureconnectionlistener}

\begin{itemize}
\tightlist
\item
  \texttt{options} \{Object\}

  \begin{itemize}
  \item
    \texttt{ALPNProtocols}:
    \{string{[}{]}\textbar Buffer{[}{]}\textbar TypedArray{[}{]}\textbar DataView{[}{]}\textbar Buffer\textbar{}
    TypedArray\textbar DataView\} An array of strings, \texttt{Buffer}s,
    \texttt{TypedArray}s, or \texttt{DataView}s, or a single
    \texttt{Buffer}, \texttt{TypedArray}, or \texttt{DataView}
    containing the supported ALPN protocols. \texttt{Buffer}s should
    have the format \texttt{{[}len{]}{[}name{]}{[}len{]}{[}name{]}...}
    e.g.~\texttt{0x05hello0x05world}, where the first byte is the length
    of the next protocol name. Passing an array is usually much simpler,
    e.g.
    \texttt{{[}\textquotesingle{}hello\textquotesingle{},\ \textquotesingle{}world\textquotesingle{}{]}}.
    (Protocols should be ordered by their priority.)
  \item
    \texttt{ALPNCallback}: \{Function\} If set, this will be called when
    a client opens a connection using the ALPN extension. One argument
    will be passed to the callback: an object containing
    \texttt{servername} and \texttt{protocols} fields, respectively
    containing the server name from the SNI extension (if any) and an
    array of ALPN protocol name strings. The callback must return either
    one of the strings listed in \texttt{protocols}, which will be
    returned to the client as the selected ALPN protocol, or
    \texttt{undefined}, to reject the connection with a fatal alert. If
    a string is returned that does not match one of the client's ALPN
    protocols, an error will be thrown. This option cannot be used with
    the \texttt{ALPNProtocols} option, and setting both options will
    throw an error.
  \item
    \texttt{clientCertEngine} \{string\} Name of an OpenSSL engine which
    can provide the client certificate.
  \item
    \texttt{enableTrace} \{boolean\} If \texttt{true},
    \hyperref[tlssocketenabletrace]{\texttt{tls.TLSSocket.enableTrace()}}
    will be called on new connections. Tracing can be enabled after the
    secure connection is established, but this option must be used to
    trace the secure connection setup. \textbf{Default:} \texttt{false}.
  \item
    \texttt{handshakeTimeout} \{number\} Abort the connection if the
    SSL/TLS handshake does not finish in the specified number of
    milliseconds. A
    \texttt{\textquotesingle{}tlsClientError\textquotesingle{}} is
    emitted on the \texttt{tls.Server} object whenever a handshake times
    out. \textbf{Default:} \texttt{120000} (120 seconds).
  \item
    \texttt{rejectUnauthorized} \{boolean\} If not \texttt{false} the
    server will reject any connection which is not authorized with the
    list of supplied CAs. This option only has an effect if
    \texttt{requestCert} is \texttt{true}. \textbf{Default:}
    \texttt{true}.
  \item
    \texttt{requestCert} \{boolean\} If \texttt{true} the server will
    request a certificate from clients that connect and attempt to
    verify that certificate. \textbf{Default:} \texttt{false}.
  \item
    \texttt{sessionTimeout} \{number\} The number of seconds after which
    a TLS session created by the server will no longer be resumable. See
    \hyperref[session-resumption]{Session Resumption} for more
    information. \textbf{Default:} \texttt{300}.
  \item
    \texttt{SNICallback(servername,\ callback)} \{Function\} A function
    that will be called if the client supports SNI TLS extension. Two
    arguments will be passed when called: \texttt{servername} and
    \texttt{callback}. \texttt{callback} is an error-first callback that
    takes two optional arguments: \texttt{error} and \texttt{ctx}.
    \texttt{ctx}, if provided, is a \texttt{SecureContext} instance.
    \hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}
    can be used to get a proper \texttt{SecureContext}. If
    \texttt{callback} is called with a falsy \texttt{ctx} argument, the
    default secure context of the server will be used. If
    \texttt{SNICallback} wasn't provided the default callback with
    high-level API will be used (see below).
  \item
    \texttt{ticketKeys}: \{Buffer\} 48-bytes of cryptographically strong
    pseudorandom data. See \hyperref[session-resumption]{Session
    Resumption} for more information.
  \item
    \texttt{pskCallback} \{Function\}

    \begin{itemize}
    \tightlist
    \item
      socket: \{tls.TLSSocket\} the server
      \hyperref[class-tlstlssocket]{\texttt{tls.TLSSocket}} instance for
      this connection.
    \item
      identity: \{string\} identity parameter sent from the client.
    \item
      Returns: \{Buffer\textbar TypedArray\textbar DataView\} pre-shared
      key that must either be a buffer or \texttt{null} to stop the
      negotiation process. Returned PSK must be compatible with the
      selected cipher's digest.
    \end{itemize}

    When negotiating TLS-PSK (pre-shared keys), this function is called
    with the identity provided by the client. If the return value is
    \texttt{null} the negotiation process will stop and an
    ``unknown\_psk\_identity'' alert message will be sent to the other
    party. If the server wishes to hide the fact that the PSK identity
    was not known, the callback must provide some random data as
    \texttt{psk} to make the connection fail with ``decrypt\_error''
    before negotiation is finished. PSK ciphers are disabled by default,
    and using TLS-PSK thus requires explicitly specifying a cipher suite
    with the \texttt{ciphers} option. More information can be found in
    the \href{https://tools.ietf.org/html/rfc4279}{RFC 4279}.
  \item
    \texttt{pskIdentityHint} \{string\} optional hint to send to a
    client to help with selecting the identity during TLS-PSK
    negotiation. Will be ignored in TLS 1.3. Upon failing to set
    pskIdentityHint
    \texttt{\textquotesingle{}tlsClientError\textquotesingle{}} will be
    emitted with
    \texttt{\textquotesingle{}ERR\_TLS\_PSK\_SET\_IDENTIY\_HINT\_FAILED\textquotesingle{}}
    code.
  \item
    \ldots: Any
    \hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}
    option can be provided. For servers, the identity options
    (\texttt{pfx}, \texttt{key}/\texttt{cert}, or \texttt{pskCallback})
    are usually required.
  \item
    \ldots: Any
    \href{net.md\#netcreateserveroptions-connectionlistener}{\texttt{net.createServer()}}
    option can be provided.
  \end{itemize}
\item
  \texttt{secureConnectionListener} \{Function\}
\item
  Returns: \{tls.Server\}
\end{itemize}

Creates a new \hyperref[class-tlsserver]{\texttt{tls.Server}}. The
\texttt{secureConnectionListener}, if provided, is automatically set as
a listener for the
\hyperref[event-secureconnection]{\texttt{\textquotesingle{}secureConnection\textquotesingle{}}}
event.

The \texttt{ticketKeys} options is automatically shared between
\texttt{node:cluster} module workers.

The following illustrates a simple echo server:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{const}\NormalTok{ tls }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:tls\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\KeywordTok{const}\NormalTok{ fs }\OperatorTok{=} \PreprocessorTok{require}\NormalTok{(}\StringTok{\textquotesingle{}node:fs\textquotesingle{}}\NormalTok{)}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ options }\OperatorTok{=}\NormalTok{ \{}
  \DataTypeTok{key}\OperatorTok{:}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{readFileSync}\NormalTok{(}\StringTok{\textquotesingle{}server{-}key.pem\textquotesingle{}}\NormalTok{)}\OperatorTok{,}
  \DataTypeTok{cert}\OperatorTok{:}\NormalTok{ fs}\OperatorTok{.}\FunctionTok{readFileSync}\NormalTok{(}\StringTok{\textquotesingle{}server{-}cert.pem\textquotesingle{}}\NormalTok{)}\OperatorTok{,}

  \CommentTok{// This is necessary only if using client certificate authentication.}
  \DataTypeTok{requestCert}\OperatorTok{:} \KeywordTok{true}\OperatorTok{,}

  \CommentTok{// This is necessary only if the client uses a self{-}signed certificate.}
  \DataTypeTok{ca}\OperatorTok{:}\NormalTok{ [ fs}\OperatorTok{.}\FunctionTok{readFileSync}\NormalTok{(}\StringTok{\textquotesingle{}client{-}cert.pem\textquotesingle{}}\NormalTok{) ]}\OperatorTok{,}
\NormalTok{\}}\OperatorTok{;}

\KeywordTok{const}\NormalTok{ server }\OperatorTok{=}\NormalTok{ tls}\OperatorTok{.}\FunctionTok{createServer}\NormalTok{(options}\OperatorTok{,}\NormalTok{ (socket) }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}server connected\textquotesingle{}}\OperatorTok{,}
\NormalTok{              socket}\OperatorTok{.}\AttributeTok{authorized} \OperatorTok{?} \StringTok{\textquotesingle{}authorized\textquotesingle{}} \OperatorTok{:} \StringTok{\textquotesingle{}unauthorized\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  socket}\OperatorTok{.}\FunctionTok{write}\NormalTok{(}\StringTok{\textquotesingle{}welcome!}\SpecialCharTok{\textbackslash{}n}\StringTok{\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  socket}\OperatorTok{.}\FunctionTok{setEncoding}\NormalTok{(}\StringTok{\textquotesingle{}utf8\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{  socket}\OperatorTok{.}\FunctionTok{pipe}\NormalTok{(socket)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\NormalTok{server}\OperatorTok{.}\FunctionTok{listen}\NormalTok{(}\DecValTok{8000}\OperatorTok{,}\NormalTok{ () }\KeywordTok{=\textgreater{}}\NormalTok{ \{}
  \BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(}\StringTok{\textquotesingle{}server bound\textquotesingle{}}\NormalTok{)}\OperatorTok{;}
\NormalTok{\})}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

The server can be tested by connecting to it using the example client
from \hyperref[tlsconnectoptions-callback]{\texttt{tls.connect()}}.

\subsection{\texorpdfstring{\texttt{tls.getCiphers()}}{tls.getCiphers()}}\label{tls.getciphers}

\begin{itemize}
\tightlist
\item
  Returns: \{string{[}{]}\}
\end{itemize}

Returns an array with the names of the supported TLS ciphers. The names
are lower-case for historical reasons, but must be uppercased to be used
in the \texttt{ciphers} option of
\hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}.

Not all supported ciphers are enabled by default. See
\hyperref[modifying-the-default-tls-cipher-suite]{Modifying the default
TLS cipher suite}.

Cipher names that start with
\texttt{\textquotesingle{}tls\_\textquotesingle{}} are for TLSv1.3, all
the others are for TLSv1.2 and below.

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{console}\OperatorTok{.}\FunctionTok{log}\NormalTok{(tls}\OperatorTok{.}\FunctionTok{getCiphers}\NormalTok{())}\OperatorTok{;} \CommentTok{// [\textquotesingle{}aes128{-}gcm{-}sha256\textquotesingle{}, \textquotesingle{}aes128{-}sha\textquotesingle{}, ...]}
\end{Highlighting}
\end{Shaded}

\subsection{\texorpdfstring{\texttt{tls.rootCertificates}}{tls.rootCertificates}}\label{tls.rootcertificates}

\begin{itemize}
\tightlist
\item
  \{string{[}{]}\}
\end{itemize}

An immutable array of strings representing the root certificates (in PEM
format) from the bundled Mozilla CA store as supplied by the current
Node.js version.

The bundled CA store, as supplied by Node.js, is a snapshot of Mozilla
CA store that is fixed at release time. It is identical on all supported
platforms.

\subsection{\texorpdfstring{\texttt{tls.DEFAULT\_ECDH\_CURVE}}{tls.DEFAULT\_ECDH\_CURVE}}\label{tls.default_ecdh_curve}

The default curve name to use for ECDH key agreement in a tls server.
The default value is \texttt{\textquotesingle{}auto\textquotesingle{}}.
See
\hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}
for further information.

\subsection{\texorpdfstring{\texttt{tls.DEFAULT\_MAX\_VERSION}}{tls.DEFAULT\_MAX\_VERSION}}\label{tls.default_max_version}

\begin{itemize}
\tightlist
\item
  \{string\} The default value of the \texttt{maxVersion} option of
  \hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}.
  It can be assigned any of the supported TLS protocol versions,
  \texttt{\textquotesingle{}TLSv1.3\textquotesingle{}},
  \texttt{\textquotesingle{}TLSv1.2\textquotesingle{}},
  \texttt{\textquotesingle{}TLSv1.1\textquotesingle{}}, or
  \texttt{\textquotesingle{}TLSv1\textquotesingle{}}. \textbf{Default:}
  \texttt{\textquotesingle{}TLSv1.3\textquotesingle{}}, unless changed
  using CLI options. Using \texttt{-\/-tls-max-v1.2} sets the default to
  \texttt{\textquotesingle{}TLSv1.2\textquotesingle{}}. Using
  \texttt{-\/-tls-max-v1.3} sets the default to
  \texttt{\textquotesingle{}TLSv1.3\textquotesingle{}}. If multiple of
  the options are provided, the highest maximum is used.
\end{itemize}

\subsection{\texorpdfstring{\texttt{tls.DEFAULT\_MIN\_VERSION}}{tls.DEFAULT\_MIN\_VERSION}}\label{tls.default_min_version}

\begin{itemize}
\tightlist
\item
  \{string\} The default value of the \texttt{minVersion} option of
  \hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}.
  It can be assigned any of the supported TLS protocol versions,
  \texttt{\textquotesingle{}TLSv1.3\textquotesingle{}},
  \texttt{\textquotesingle{}TLSv1.2\textquotesingle{}},
  \texttt{\textquotesingle{}TLSv1.1\textquotesingle{}}, or
  \texttt{\textquotesingle{}TLSv1\textquotesingle{}}. \textbf{Default:}
  \texttt{\textquotesingle{}TLSv1.2\textquotesingle{}}, unless changed
  using CLI options. Using \texttt{-\/-tls-min-v1.0} sets the default to
  \texttt{\textquotesingle{}TLSv1\textquotesingle{}}. Using
  \texttt{-\/-tls-min-v1.1} sets the default to
  \texttt{\textquotesingle{}TLSv1.1\textquotesingle{}}. Using
  \texttt{-\/-tls-min-v1.3} sets the default to
  \texttt{\textquotesingle{}TLSv1.3\textquotesingle{}}. If multiple of
  the options are provided, the lowest minimum is used.
\end{itemize}

\subsection{\texorpdfstring{\texttt{tls.DEFAULT\_CIPHERS}}{tls.DEFAULT\_CIPHERS}}\label{tls.default_ciphers}

\begin{itemize}
\tightlist
\item
  \{string\} The default value of the \texttt{ciphers} option of
  \hyperref[tlscreatesecurecontextoptions]{\texttt{tls.createSecureContext()}}.
  It can be assigned any of the supported OpenSSL ciphers. Defaults to
  the content of \texttt{crypto.constants.defaultCoreCipherList}, unless
  changed using CLI options using \texttt{-\/-tls-default-ciphers}.
\end{itemize}
